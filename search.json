[
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html",
    "href": "08/exercises_lecture_working_with_numpy.html",
    "title": "Exercises - Working with NumPy",
    "section": "",
    "text": "Create a 1D NumPy array of integers from 10 to 19. Access the element at index 3.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Exercises - Working with NumPy"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "title": "Exercises - Working with NumPy",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\nimport math\nR = 10.0 #in metres\nomega = 2.0*2*math.pi/60. # in radians per second\nx0 = R # in metres\ny0 = 0 # in metres\ndt = 2.0 # in seconds\nduration = 20.0 #in seconds\nnum_iterations  = int(duration/dt)\nx, y = [], []\nt = 0\nfor _ in range(num_iterations):\n    x.append(R*math.cos(omega*t)+x0)\n    y.append(R*math.sin(omega*t)+y0)\n    t += dt \n\n# plotting, ignore the details for now sicne we will cover this in a later lecture\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\nplt.show()\n\n\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Exercises - Working with NumPy"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html",
    "href": "08/lecture_working_with_numpy.html",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "",
    "text": "NumPy is a powerful library for numerical computing in Python, providing efficient multi-dimensional array operations and a wide range of mathematical functions. With NumPy, you can perform fast element-wise computations, advanced indexing, slicing, and generate random data for simulations and analysis.\nThis notebook illustrates array indexing, boolean arrays, generating sequences using np.arange and np.linspace, and generating random samples with NumPy’s random number generator.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "href": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Array indexing, slicing, views and copies",
    "text": "Array indexing, slicing, views and copies\nIndexing in NumPy allows you to access and modify individual elements or groups of elements within an array. You can use integer indices, slices, and even boolean arrays to select data efficiently. For example:\n\nInteger Indexing: Select a single element by its position.\nSlicing: Extract a range of elements.\nBoolean Indexing: Filter elements based on a condition.\n\n\nInteger indexing\nWe have already seen that the lements of an array are idnexed similarly to lists. The syntax simply requires you to enter the integer index of the element you want to access. For example, if you have an array arr, you can access the element at index 1 using arr[1]. You can also slice arrays using the same syntax as lists, such as arr[1:4] to get elements from index 1 to 3.\n\nimport numpy as np\n\narr = np.array([10, 20, 30, 40, 50])\nprint(\"Array:\", arr)\nprint(\"Element at index 1:\", arr[1])\n\nArray: [10 20 30 40 50]\nElement at index 1: 20\n\n\n\n\nSlicing\nSlicing allows you to extract a portion of an array by specifying a start index, an end index, and an optional step. The syntax is similar to that used for lists in Python. For example, arr[1:4] retrieves elements from index 1 to 3 (the end index is exclusive).\n\nprint(\"Slice from index 1 to 3:\", arr[1:4])\n\nSlice from index 1 to 3: [20 30 40]\n\n\n\n\nAdvanced Slicing Techniques\nNumPy slicing can be extended beyond basic start and end indices:\n\nStep Size: Use a third parameter to specify the step, e.g., arr[::2] selects every other element.\nNegative Indices: Negative values index from the end, e.g., arr[-3:] gets the last three elements.\nReverse Slicing: Use a negative step to reverse an array, e.g., arr[::-1].\n\n\n# Step size: select every other element\nprint(\"Every other element:\", arr[::2])\n\n# Negative indices: last three elements\nprint(\"Last three elements:\", arr[-3:])\n\n# Reverse slicing: reverse the array\nprint(\"Reversed array:\", arr[::-1])\n\n# Selecting all elements\nprint(\"All elements:\", arr[:])\n\nEvery other element: [10 30 50]\nLast three elements: [30 40 50]\nReversed array: [50 40 30 20 10]\nAll elements: [10 20 30 40 50]\n\n\nSlicing creates views, not copies, so modifying a slice affects the original array. Use arr.copy() to create a copy if needed.\nA view is a new array object that looks at the same data as the original array. Changes made to a view will affect the original array, since they share the same underlying data. For example, arr[1:4] returns a view of arr, not a separate copy.\n\n# Demonstrating that slicing creates a view, not a copy\nslice_view = arr[2:5]\nprint(\"Original array before modification:\", arr)\nslice_view[0] = 99  # Modify the view\nprint(\"Modified slice_view:\", slice_view)\nprint(\"Original array after modification:\", arr)  # arr is also changed\n\nOriginal array before modification: [10 20 30 40 50]\nModified slice_view: [99 40 50]\nOriginal array after modification: [10 20 99 40 50]\n\n\nSlices can be programmaticaly generated using the slice function, which allows you to create a slice object that can be reused. For example, s = slice(1, 4) creates a slice object that can be used as arr[s] to get the same result as arr[1:4].\n\n# Creating an independent copy of a slice\nexample_slice = slice(1, 4, 2)\nprint(\"Using slice(1, 4, 2) on arr:\", arr[example_slice])\n\nUsing slice(1, 4, 2) on arr: [20 40]\n\n\nTo create an independent copy of an array (rather than a view), use the copy() method. For example, arr_copy = arr[1:4].copy() creates a new array with its own data, so changes to arr_copy will not affect the original arr. This is useful when you want to modify a subset of an array without altering the original data.\n\n# Creating an independent copy of a slice\narr_copy = arr[2:5].copy()\narr_copy[0] = 100  # Modify the copy\nprint(\"arr_copy:\", arr_copy)\nprint(\"Original arr:\", arr)  # arr remains unchanged\n\narr_copy: [100  40  50]\nOriginal arr: [10 20 99 40 50]\n\n\n\n\nBoolean Indexing\nBoolean indexing allows you to select elements from an array based on a condition. When you apply a condition to a NumPy array, it returns a boolean (an array that contains only True/False values ) array indicating which elements satisfy the condition. You can then use this boolean array to filter the original array, extracting only the elements that meet the criteria. This technique is powerful for data selection and analysis.\n\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\nbool_mask = arr &gt; threshold\nprint(\"Original array:\", arr)\nprint(f\"Boolean mask for threshold {threshold}:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\n\nOriginal array: [1 2 3 4 5 6]\nBoolean mask for threshold 3: [False False False  True  True  True]\nFiltered values: [4 5 6]\n\n\n\n\nUsing np.where for conditional selection\nThe np.where function in NumPy is a powerful tool for conditional selection and element-wise operations. It allows you to choose values from arrays based on a condition, returning indices or constructing new arrays.\n\nBasic usage:\nnp.where(condition) returns the indices where the condition is True.\n\n\nnp.where(arr &gt; threshold)\n\n(array([3, 4, 5]),)\n\n\nnp.where(arr &gt; threshold) returns a tuple because, for 1D arrays, it provides the indices where the condition is True. In NumPy, the output is always a tuple of arrays—one for each dimension of the input array. For a 1D array, it’s a single-element tuple containing the indices. For higher dimensions, it returns a tuple with arrays for each axis. This consistent tuple format makes it easy to handle multi-dimensional indexing.\nSo, for 1D arrays as the ones considered up to now, we should get the indices by extracting the first element of the tuple returned by np.where\n\nnp.where(arr &gt; threshold)[0]\n\narray([3, 4, 5])\n\n\n\nElement-wise selection:\nnp.where(condition, x, y) returns elements from x where the condition is True, and from y where it is False. Here the result is an array of the same shape as x and y, containing values from x where the condition is met, and from y otherwise. This is useful for creating new arrays based on conditions without using loops.\n\n\na  = np.array([1, 2, 3, 4, 5])\nb = np.array([-1,-2, -3, - 4, -5])\nc = np.array([10, 20, 30, 40, 50])\n\nresult = np.where(a &gt; 2, x, y)\nprint(result)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 5\n      2 b = np.array([-1,-2, -3, - 4, -5])\n      3 c = np.array([10, 20, 30, 40, 50])\n----&gt; 5 result = np.where(a &gt; 2, x, y)\n      6 print(result)\n\nNameError: name 'x' is not defined\n\n\n\nThis creates a new array where each element is 100 if the condition is met, otherwise 0.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "href": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Function to generate numerical arrays",
    "text": "Function to generate numerical arrays\nNumPy provides automated methods for generating numerical sequences, which are essential for simulations, sampling, and creating structured data.\n\nGenerating sequences\nThe two most used functions for generating ordered numerical sequences in NumPy are np.arange and np.linspace.\n\nnp.arange(start, stop, step): Generates an array of evenly spaced values within a specified range. The start value is inclusive, while the stop value is exclusive. The step parameter defines the spacing between values.\nExample: np.arange(0, 10, 2) produces [0, 2, 4, 6, 8].\nnp.linspace(start, stop, num): Creates an array of num evenly spaced values between start and stop, inclusive. This is useful for generating a specific number of points in a range.\n\n\nprint(\"np.arange(0, 10, 2):\", np.arange(0, 10, 2))\nprint(\"np.linspace(0, 1, 5):\", np.linspace(0, 1, 5))\n\nnp.arange(0, 10, 2): [0 2 4 6 8]\nnp.linspace(0, 1, 5): [0.   0.25 0.5  0.75 1.  ]\n\n\nMost importantly, these functions can be used to create arrays of any kinds of numerical data, including integers and floating-point numbers.\n\n# integers\nnp.arange(0, 10, 2)  # Creates an array with values from 0 to 10 with a step of 2\n\narray([0, 2, 4, 6, 8])\n\n\n\n# floating-point numbers\nnp.arange(0.0, 1.0, 0.2)  # Creates an array with values from 0.0 to 1.0 with a step of 0.2\n\narray([0. , 0.2, 0.4, 0.6, 0.8])\n\n\n\n# complex numbers, by using the data type specifier `dtype=complex`\nnp.arange(0, 10, 2, dtype=complex)  # Creates an array with complex numbers from 0 to 10 with a step of 2\n\narray([0.+0.j, 2.+0.j, 4.+0.j, 6.+0.j, 8.+0.j])\n\n\nNotice that linspace is useful when we know the start and end value and the specific number of points we want to generate, while arange is useful when we know the start and end value and the step size between the points.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "href": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Generating filled arrays",
    "text": "Generating filled arrays\nNumPy provides functions to create arrays filled with specific values, such as zeros, ones, or a constant value. These functions are useful for initializing arrays before performing computations.\nThe main functions for generating filled arrays are: - np.zeros(shape): Creates an array filled with zeros, where shape specifies the dimensions of the array. - np.ones(shape): Creates an array filled with ones. - np.full(shape, fill_value): Creates an array filled with a specified value (fill_value), where shape defines the dimensions of the array.\n- np.empty(shape): Creates an uninitialized array with the specified shape. The values in this array are not set to any particular value, so they may contain random data.\nThere are also functions that create arrays with the same shape and type as an existing array, which can be useful for initializing arrays that will be used in computations:\n\nnp.zeros_like(array): Creates an array of zeros with the same shape and type as the input array.\nnp.ones_like(array): Creates an array of ones with the same shape and type as the input array.\nnp.full_like(array, fill_value): Creates an array filled with a specified value, with the same shape and type as the input array.\n\n\n# Examples using filled array generation functions\n\n# Create a 1D array of zeros with the same shape as arr\nzeros_arr = np.zeros_like(arr)\nprint(\"Zeros array:\", zeros_arr)\n\n# Create a 1D array of ones with the same shape as arr\nones_arr = np.ones_like(arr)\nprint(\"Ones array:\", ones_arr)\n\n# Create a 1D array filled with the value 7, same shape as arr\nfull_arr = np.full_like(arr, 7)\nprint(\"Full array (filled with 7):\", full_arr)\n\n# Create an uninitialized array (values may be random, or zeros)\nempty_2d = np.empty(5)\nprint(\"An empty array:\\n\", empty_2d)\n\nZeros array: [0 0 0 0 0 0]\nOnes array: [1 1 1 1 1 1]\nFull array (filled with 7): [7 7 7 7 7 7]\nAn empty array:\n [0. 0. 0. 0. 0.]",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#random-data-generation",
    "href": "08/lecture_working_with_numpy.html#random-data-generation",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Random Data Generation",
    "text": "Random Data Generation\nRandom data generation is essential for simulations, statistical modeling, and testing algorithms.\nFor example, you might want to generate random samples from a normal distribution to simulate real-world data or create random datasets for testing purposes. Or you may want to simulate the effect of measurement errors in your data analysis. Or you may want to sub-sample a large dataset randomly to take a representative sample without bias.\nTo do all this, one needs methods to sample numbers that possess the statistical properties of the desired distribution, such as uniform, normal, or binomial distributions.\nStrictly speaking (classical) computers are deterministic machines, meaning they follow a set of rules and produce the same output for the same input every time. We have therefore to use algorithms to produce sequences of numbers that mimic the properties of random numbers.\nThese are called pseudo-random numbers. Pseudo-random number generators (PRNGs) use algorithms to produce sequences of numbers that appear random but are actually deterministic.\nA simple and classic example of a pseudo-random number generator is the Linear Congruential Generator (LCG). The LCG produces a sequence of numbers using the recurrence relation:\n\\[x_{n+1} = (a \\times  x_{n} + c)\\,\\mathrm{mod}\\, m\\]\nwhere\n- \\(x_n\\) is the current value,\n- \\(a\\) is the multiplier,\n- \\(c\\) is the increment,\n- \\(m\\) is the modulus.\nIn vanilla Python this looks like the following custom function\n\ndef lcg(seed, a=1664525, c=1013904223, m=2**32, size=10):\n    nums = []\n    x = seed\n    for _ in range(size):\n        x = (a * x + c) % m\n        nums.append(x)\n    return nums\n\n\n# Example usage:\nlcg_sequence = lcg(seed=42, size=5)\nprint(\"LCG sequence:\", lcg_sequence)\n\nLCG sequence: [1083814273, 378494188, 2479403867, 955863294, 1613448261]\n\n\nThis will generate a sequence of pseudo-random integers. The choice of parameters (a, c, m) affects the quality and period of the generator.\n\n# Example of LCG with a short period by choosing small modulus\nshort_period_seq = lcg(seed=1,  a=5, c=3, m=16, size=20)\nprint(\"LCG sequence with short period:\", short_period_seq)\n\nLCG sequence with short period: [8, 11, 10, 5, 12, 15, 14, 9, 0, 3, 2, 13, 4, 7, 6, 1, 8, 11, 10, 5]\n\n\nThe seed is crucial: it is the initial value that starts the algorithm to determin the subsequent values in the sequence. By setting the seed, you can ensure that the sequence is reproducible, meaning that running the same code with the same seed will produce the same sequence of numbers every time.\nIn numpy, we do not need to implement our own LCG, as it provides a built-in random number generator that is based on the Mersenne Twister algorithm, which is a widely used and efficient pseudo-random numbwer generator.\nWhat we do instead is to use the numpy.random sub-module, which provides a wide range of functions for generating random numbers from various distributions, including uniform, normal, and binomial distributions.\nThe standard way to to use it is the following:\n\nfirst, one initialises a new kind of object called a random number generator (RNG) using np.random.default_rng(). This is a numpy object capable of generating random numbers from various distributions. It allows us in particular to set the seed and therefore ensure reproducibility.\n\n\nrng = np.random.default_rng(seed=123)\n\nWe can do this at any point in our code, but it is a good practice to do it at the beginning of our script or notebook, so that we can ensure that all random numbers generated in the script are reproducible. Putting the generator elsewhere (for example, inside a function) could lead to unexpected results, as the generator would be re-initialised each time the function is called.\nOnce we have a generator we can access any of its method to sample numbers from various distributions\nFor example:\n\nIntegers\nTo sample uniformly distributed integers, we can use the integers method of the generator. This method allows us to specify a range and the number of integers to generate.\n\nrng.integers(0, 100, size=5)  # 5 random integers between 0 and 100\n\narray([ 1, 68, 59,  5, 90])\n\n\n\n\n[0-1) uniform floats\nTo sample uniformly distributed floats between 0 and 1, we can use the random method of the generator. This method generates random floats in the range [0.0, 1.0) (which means 0 included and 1 excluded).\n\nrng.random(1000)\n\narray([1.84371811e-01, 1.75905901e-01, 8.12094507e-01, 9.23344998e-01,\n       2.76574398e-01, 8.19754562e-01, 8.89892693e-01, 5.12970455e-01,\n       2.44964601e-01, 8.24241596e-01, 2.13762963e-01, 7.41467052e-01,\n       6.29940205e-01, 9.27407259e-01, 2.31908189e-01, 7.99125129e-01,\n       5.18165037e-01, 2.31555625e-01, 1.65903993e-01, 4.97788968e-01,\n       5.82724641e-01, 1.84337987e-01, 1.48949168e-02, 4.71133229e-01,\n       7.28243328e-01, 9.18600492e-01, 6.25534006e-01, 9.17122573e-01,\n       8.64690251e-01, 2.18142873e-01, 8.66127431e-01, 7.30751936e-01,\n       2.77865290e-01, 7.97043553e-01, 8.65221713e-01, 2.99437896e-01,\n       5.27042084e-01, 7.14868066e-02, 5.83238410e-01, 2.37906400e-01,\n       7.64963646e-01, 1.73631636e-01, 3.12742256e-01, 1.44744768e-02,\n       3.25519216e-02, 4.96701842e-01, 4.68312534e-01, 1.27690323e-01,\n       2.57562505e-01, 3.18110929e-03, 3.81067748e-01, 5.75873084e-01,\n       4.27298771e-01, 8.35102347e-01, 6.16491251e-01, 2.66083912e-01,\n       8.11022111e-01, 4.99486750e-01, 7.58810321e-01, 5.66089086e-01,\n       4.37440362e-01, 3.96154444e-01, 2.22352879e-02, 4.69350788e-01,\n       6.23558402e-01, 9.46113421e-01, 4.35326080e-01, 4.85641403e-01,\n       5.19115144e-01, 4.08590980e-01, 5.78795719e-01, 7.03506733e-02,\n       4.88383831e-01, 6.10144828e-01, 7.43879107e-01, 4.29830320e-01,\n       3.02802133e-01, 5.89003332e-03, 7.56478970e-01, 7.75759702e-02,\n       4.89988038e-01, 3.04361097e-01, 8.40822162e-01, 9.50475862e-01,\n       3.18874579e-01, 8.97768289e-01, 3.37529051e-01, 8.12112111e-01,\n       7.98843598e-01, 6.55285177e-01, 2.28703455e-01, 1.37674465e-01,\n       4.24371139e-01, 1.51538753e-01, 8.73272949e-01, 1.79126757e-01,\n       3.02946616e-02, 5.59249677e-01, 4.28806253e-01, 8.58597422e-01,\n       1.60831376e-01, 3.60353699e-01, 6.40509937e-01, 9.31079350e-01,\n       2.61801022e-01, 6.88098414e-01, 1.49052652e-01, 7.40154973e-01,\n       2.93181283e-01, 2.43745105e-01, 2.29821438e-01, 3.70651165e-01,\n       3.28555087e-01, 6.12641672e-01, 5.44715400e-01, 7.49643105e-01,\n       2.94954285e-01, 9.60553728e-01, 5.43482759e-01, 6.79424148e-01,\n       6.88259248e-01, 1.52297793e-01, 1.45024452e-01, 4.62043822e-01,\n       5.21933533e-01, 2.72044753e-01, 1.80120947e-01, 5.03921087e-01,\n       6.59638348e-01, 2.28754453e-01, 2.18418231e-01, 9.54899059e-01,\n       7.24892934e-01, 3.43368483e-02, 9.81617034e-01, 8.49616629e-03,\n       2.64961882e-01, 9.17324152e-01, 8.03877164e-02, 8.54715704e-01,\n       1.44677397e-01, 1.79241078e-01, 7.84673473e-01, 8.95424057e-01,\n       4.60734326e-01, 3.84836822e-02, 3.15305260e-01, 1.52932497e-02,\n       3.49173685e-01, 6.59310019e-01, 2.65216132e-01, 6.52018838e-01,\n       9.27480197e-01, 4.66138759e-01, 2.07109561e-01, 9.22714245e-01,\n       9.45856611e-01, 1.34905654e-01, 8.99638534e-01, 2.92149167e-01,\n       1.28175443e-01, 1.18076690e-01, 7.59450077e-01, 8.84425144e-02,\n       7.63151744e-01, 2.39618554e-01, 4.18783790e-01, 1.43017706e-01,\n       6.52669797e-01, 4.57785927e-01, 3.93830151e-01, 8.04673138e-01,\n       4.59015110e-01, 6.91568337e-01, 7.81989077e-01, 6.14881258e-01,\n       9.61390895e-01, 5.50878047e-01, 2.19012527e-01, 5.41879843e-01,\n       2.44556981e-01, 8.33270172e-02, 7.56362092e-01, 2.64497549e-01,\n       3.13640437e-01, 9.88342858e-01, 4.00557832e-01, 4.41312096e-01,\n       9.20598730e-01, 7.90066378e-01, 8.59482088e-01, 4.68356714e-01,\n       2.12503574e-01, 6.56388165e-02, 7.98140191e-02, 1.36989553e-01,\n       2.69348924e-01, 7.77373950e-01, 2.29526009e-01, 4.21793581e-01,\n       4.58136535e-01, 3.09685992e-01, 1.77010903e-01, 2.68030787e-01,\n       8.52354381e-01, 9.94072275e-01, 3.70674245e-01, 4.61750909e-01,\n       3.34988554e-01, 3.65438705e-01, 6.87173494e-01, 7.35326314e-01,\n       3.17037589e-01, 1.45020086e-01, 7.07526003e-01, 4.39390997e-01,\n       9.16295276e-01, 4.09334109e-01, 2.77150070e-02, 7.26138640e-01,\n       9.85781890e-01, 4.66361827e-01, 9.52649389e-01, 1.62589708e-01,\n       2.12859688e-01, 3.41512042e-01, 4.05946036e-01, 8.99458188e-01,\n       9.72509770e-01, 5.10212230e-01, 6.96744277e-01, 6.27618975e-01,\n       8.60532754e-01, 1.07781528e-01, 5.61674829e-01, 8.08329407e-01,\n       7.74227117e-01, 7.67461953e-01, 9.81200035e-01, 2.83038159e-02,\n       1.06097737e-01, 1.53329230e-01, 5.80881814e-01, 4.30837283e-01,\n       6.41294099e-02, 2.79183123e-01, 3.90760254e-01, 5.05871219e-01,\n       7.55738892e-01, 4.89023703e-01, 8.25727590e-01, 5.40468140e-01,\n       3.57183202e-01, 8.05977481e-01, 1.86378547e-01, 8.89289032e-01,\n       6.73413707e-01, 9.53377252e-01, 2.09842996e-01, 2.32745704e-01,\n       4.56558778e-01, 1.48755812e-01, 3.97266148e-02, 3.51908111e-01,\n       7.51073437e-01, 8.88985034e-01, 2.33330969e-01, 9.44303691e-01,\n       7.92382452e-02, 7.82914944e-02, 7.05380588e-01, 6.78028455e-02,\n       9.70647394e-01, 2.74209810e-01, 1.28723815e-01, 7.68454465e-01,\n       4.22450862e-01, 9.00075386e-01, 4.92458541e-01, 7.98362805e-03,\n       1.63343123e-01, 9.93855166e-02, 1.81349494e-01, 2.70568170e-01,\n       7.53784338e-02, 8.78925401e-01, 6.73292806e-01, 4.43977331e-01,\n       8.98713315e-01, 6.11667746e-01, 6.81721781e-01, 7.12645562e-01,\n       4.39463988e-01, 2.93164240e-01, 8.86758579e-01, 3.69086347e-01,\n       4.36794215e-01, 2.76273452e-01, 5.53644595e-01, 5.38142965e-01,\n       4.31733785e-01, 3.53278547e-01, 5.41743078e-01, 3.82057942e-01,\n       7.79098989e-01, 1.53412210e-01, 7.20461787e-01, 2.08668011e-01,\n       9.32024800e-01, 3.84991713e-01, 3.23780149e-01, 9.00976329e-01,\n       4.73760930e-02, 9.77634923e-01, 9.28686984e-01, 6.64628650e-01,\n       5.69600819e-01, 5.24352848e-01, 8.34164345e-02, 9.07821313e-02,\n       6.90645119e-01, 9.57967677e-01, 5.10249274e-01, 1.01844895e-03,\n       8.28841928e-01, 8.30527092e-01, 3.36511890e-01, 6.79818631e-01,\n       1.41583649e-01, 1.63237978e-01, 7.11432537e-01, 5.09927237e-01,\n       5.88925603e-01, 5.23705849e-01, 9.40467623e-01, 7.88692180e-01,\n       8.99123374e-01, 2.91613581e-01, 9.79610619e-01, 8.18777761e-01,\n       9.95662196e-02, 8.71069391e-02, 1.91521038e-01, 3.36374640e-01,\n       2.19437735e-01, 5.18401453e-02, 4.45013130e-01, 2.62511860e-01,\n       4.62669935e-01, 7.83487475e-01, 3.21772672e-01, 4.03029885e-02,\n       8.34537973e-01, 4.90318507e-01, 2.44148858e-01, 9.28257314e-01,\n       7.35195053e-01, 4.21703964e-01, 3.47123735e-01, 7.10517888e-02,\n       2.85652304e-01, 7.15829431e-01, 7.56348747e-02, 3.76477949e-01,\n       5.91571543e-01, 7.39956524e-01, 7.42822511e-01, 2.92607877e-01,\n       3.29242395e-01, 1.57348400e-01, 7.29287841e-01, 2.65469563e-01,\n       4.80423341e-01, 8.99725840e-01, 6.42896243e-03, 8.56693461e-01,\n       7.39848839e-01, 6.45152381e-01, 4.07077242e-01, 6.24018428e-01,\n       9.48596887e-01, 9.52827932e-02, 6.77719450e-02, 3.40497035e-01,\n       1.03056557e-01, 9.17756634e-01, 7.87378214e-01, 1.58418307e-01,\n       3.73626915e-01, 4.15391292e-01, 9.54422908e-01, 3.29219753e-01,\n       4.80208521e-01, 5.28962176e-01, 7.81803274e-01, 8.68044648e-01,\n       6.70774506e-01, 3.63329218e-01, 2.29046003e-01, 3.98075545e-01,\n       5.75837731e-01, 7.66922112e-01, 9.59497014e-01, 8.73402359e-01,\n       7.87775841e-01, 9.00659757e-01, 6.96050335e-01, 9.45490228e-01,\n       5.13548471e-01, 9.10756934e-02, 7.29521894e-01, 9.48477875e-01,\n       3.10402712e-02, 6.22092795e-01, 3.04768507e-01, 4.04182471e-01,\n       9.18098826e-01, 3.34389520e-01, 6.25812967e-01, 4.23398749e-01,\n       9.26832129e-01, 3.68676160e-01, 9.93795752e-02, 4.18998728e-01,\n       4.05119062e-01, 8.85378822e-01, 3.31414354e-01, 2.94004444e-01,\n       4.07031481e-01, 6.91009738e-01, 4.22313249e-01, 5.22053089e-01,\n       7.10217611e-01, 2.67980368e-02, 1.33159234e-01, 7.25115476e-01,\n       9.07175470e-01, 8.67027162e-01, 7.07202750e-01, 9.81854660e-01,\n       8.52905505e-01, 6.93752664e-01, 6.40121696e-01, 8.53131626e-01,\n       8.80156165e-01, 2.74037982e-01, 8.54019135e-01, 5.88206803e-01,\n       1.86379777e-04, 1.97099418e-01, 7.79598163e-01, 3.42190497e-01,\n       8.43060960e-01, 6.02672523e-01, 9.86654937e-01, 7.63854232e-01,\n       9.30444278e-02, 8.37787891e-01, 6.63912156e-01, 2.20122755e-01,\n       5.16804413e-01, 1.60351790e-01, 3.73046077e-01, 7.44788479e-01,\n       4.53366397e-01, 6.61458118e-01, 8.99345144e-01, 7.01525089e-01,\n       9.20566999e-02, 4.12473460e-01, 3.16132834e-01, 4.78451996e-01,\n       8.96847839e-01, 3.42900315e-01, 7.41429784e-01, 4.68276663e-01,\n       8.37718614e-01, 2.35700386e-01, 5.23455616e-01, 6.31811742e-01,\n       3.76699726e-01, 5.63502651e-01, 2.96738637e-01, 9.87425770e-01,\n       6.87260695e-01, 6.29460053e-01, 9.34547524e-01, 4.40673000e-01,\n       9.81269351e-01, 9.00139631e-02, 9.88211527e-01, 7.19692087e-01,\n       5.79939881e-01, 3.56486538e-01, 2.03086688e-01, 9.82557875e-01,\n       2.35221673e-01, 8.80107684e-01, 5.70474295e-02, 8.01264314e-01,\n       8.69584494e-01, 2.44912426e-01, 9.76953176e-01, 3.71831094e-01,\n       1.58355891e-01, 4.19490157e-01, 9.72325640e-01, 1.13491229e-01,\n       6.92972289e-01, 1.36092032e-01, 6.85297152e-01, 1.54219934e-01,\n       9.43749823e-01, 9.13711151e-01, 9.84413406e-01, 8.78415554e-01,\n       3.85919890e-01, 4.65802671e-01, 3.13890072e-01, 4.92166010e-01,\n       2.37900547e-01, 9.60058750e-01, 4.17853706e-01, 3.36021029e-01,\n       9.35275132e-01, 3.47530896e-01, 4.21498557e-01, 6.27928406e-01,\n       7.30556551e-01, 4.25667830e-01, 2.22257876e-01, 6.21894105e-01,\n       1.70135598e-01, 6.18882849e-01, 6.42565172e-01, 6.38895026e-01,\n       3.51982564e-01, 3.96320815e-01, 2.65015454e-01, 7.89367513e-01,\n       7.16239201e-01, 6.91437570e-01, 9.71314939e-01, 8.86818231e-01,\n       4.29160537e-01, 7.57904842e-01, 6.44050284e-01, 5.37030350e-01,\n       1.40040249e-01, 4.93648641e-01, 2.16956963e-01, 8.08458170e-01,\n       7.39295663e-01, 1.79091296e-01, 9.03285198e-02, 1.08586391e-01,\n       7.83586979e-01, 9.41516049e-01, 2.89726949e-01, 1.09244985e-01,\n       7.07720088e-01, 5.22596691e-01, 6.05670467e-01, 5.01821423e-01,\n       8.09740839e-01, 5.84896971e-01, 8.02212848e-01, 6.57759409e-01,\n       6.84953179e-01, 7.36580632e-01, 5.78187585e-01, 3.59761003e-01,\n       3.96263174e-01, 2.23260703e-02, 3.71782090e-02, 4.64820602e-01,\n       8.01973219e-01, 7.07226413e-01, 3.84889505e-01, 4.79529675e-01,\n       8.38114215e-01, 7.87692873e-01, 6.10222185e-01, 8.49063075e-01,\n       9.79207663e-01, 6.22966362e-01, 9.69881649e-01, 7.80090568e-02,\n       7.75855776e-01, 9.61048047e-02, 2.21691318e-01, 3.39170089e-01,\n       1.16700789e-01, 7.15962826e-01, 3.49435446e-01, 1.68633123e-01,\n       2.14742590e-01, 2.47672902e-02, 9.60535205e-01, 9.51182093e-01,\n       2.54441148e-01, 6.99273568e-01, 4.64313594e-02, 3.49571461e-01,\n       6.76266217e-01, 2.27676696e-01, 3.39148914e-01, 1.31136392e-01,\n       1.51316642e-01, 6.21017714e-03, 3.38630900e-01, 4.25739019e-01,\n       4.22599751e-01, 2.84916502e-01, 5.31731583e-01, 2.53781815e-02,\n       4.05774435e-01, 6.12898421e-01, 7.64075727e-01, 9.92727201e-01,\n       4.39374925e-01, 9.40188607e-01, 9.16371994e-01, 1.39190844e-01,\n       5.00843313e-01, 2.24280699e-01, 7.93077513e-01, 7.35168059e-01,\n       9.73456559e-01, 5.93342214e-02, 4.33034747e-01, 3.64531796e-01,\n       6.55678105e-01, 5.30821139e-01, 5.70188154e-01, 1.42042459e-01,\n       9.41130038e-01, 3.24981732e-01, 3.93215105e-01, 2.28596939e-01,\n       3.03361353e-01, 3.78744798e-01, 2.60604557e-01, 4.53498545e-01,\n       8.33089640e-01, 8.43666133e-01, 6.12317203e-01, 5.52709486e-01,\n       6.02282676e-01, 5.04238757e-01, 7.10020576e-02, 1.01995977e-01,\n       4.78667187e-01, 7.38418414e-02, 1.29717098e-01, 6.25772270e-01,\n       9.45583945e-01, 3.47629781e-02, 6.02315044e-01, 4.52489476e-01,\n       3.95084990e-02, 7.80372045e-01, 7.04680631e-01, 9.34338102e-01,\n       6.63940453e-01, 7.15504435e-01, 3.60105197e-01, 5.79098519e-01,\n       6.20473130e-01, 1.16505534e-01, 1.99216124e-01, 2.36086058e-01,\n       6.09880241e-01, 5.42884698e-01, 3.22745858e-01, 7.89789443e-01,\n       6.91813852e-01, 1.39315464e-01, 7.89802302e-01, 3.09553223e-01,\n       4.66120187e-01, 1.81748724e-01, 4.03280255e-01, 2.29615358e-01,\n       7.33369033e-01, 5.88246449e-01, 8.81447262e-01, 1.58060193e-01,\n       5.74691483e-01, 4.72075225e-01, 4.76160368e-01, 7.55445869e-01,\n       4.14679282e-01, 6.95271222e-01, 2.78711499e-01, 1.27075953e-01,\n       7.92857877e-01, 5.25856417e-01, 2.47756200e-01, 4.51794210e-01,\n       6.32646492e-01, 2.46935350e-01, 1.80625697e-01, 9.90570705e-01,\n       1.84435744e-01, 3.34265115e-01, 3.98346351e-01, 8.61159621e-01,\n       2.78233797e-01, 2.21618214e-01, 1.26682913e-01, 7.60594687e-01,\n       5.65182951e-01, 9.42787883e-02, 4.54948466e-01, 9.88445048e-01,\n       9.23071934e-01, 5.62383859e-01, 2.35183420e-01, 5.88979107e-01,\n       5.12704297e-01, 9.69980113e-01, 1.50404598e-02, 3.11346496e-01,\n       4.03148074e-01, 7.30309455e-01, 7.49192551e-01, 7.34195577e-01,\n       5.68886818e-01, 5.51682285e-01, 2.90253650e-01, 8.68864839e-01,\n       4.26876456e-01, 3.57536909e-01, 7.95125315e-01, 7.24742588e-01,\n       3.18551534e-01, 2.36879864e-02, 8.38310718e-03, 8.50825909e-01,\n       1.51046580e-01, 6.02445589e-01, 5.90731652e-01, 2.25353624e-01,\n       4.45584992e-01, 4.19023040e-01, 5.02707937e-01, 8.57022140e-01,\n       9.15971624e-01, 8.65700471e-02, 4.29082699e-01, 2.94536932e-01,\n       7.87849073e-01, 3.45847897e-01, 4.85105598e-01, 7.06576725e-01,\n       6.35219271e-01, 7.43435940e-01, 4.30920168e-01, 5.41323170e-01,\n       2.72144070e-01, 7.77095084e-01, 8.66290049e-01, 3.02129491e-01,\n       4.97757480e-01, 1.04605450e-01, 1.11726740e-01, 1.44628744e-01,\n       6.29905356e-01, 7.86264040e-01, 1.29190474e-01, 9.97435899e-01,\n       3.53866468e-01, 8.93344644e-01, 9.99608624e-01, 8.41059435e-01,\n       3.80353548e-01, 2.41634372e-02, 5.07971669e-01, 4.87943326e-01,\n       3.51834111e-03, 8.68652395e-01, 1.46184072e-01, 6.27005376e-01,\n       2.62514882e-01, 4.14292580e-01, 4.69887143e-01, 5.87663680e-01,\n       5.19519352e-01, 3.64439271e-01, 4.04623206e-02, 1.26604592e-01,\n       6.23990975e-01, 6.06017770e-01, 6.68272217e-01, 8.03770268e-02,\n       2.49796689e-01, 2.34870364e-01, 8.14631148e-01, 7.59801548e-01,\n       7.51641514e-01, 9.71902838e-01, 9.15851294e-01, 6.44074919e-01,\n       5.08843946e-01, 8.17654038e-01, 5.49662595e-01, 7.67618746e-01,\n       1.80170976e-01, 5.13005646e-01, 4.83605604e-01, 4.84650633e-01,\n       5.19503300e-01, 6.13990319e-01, 6.05418128e-01, 9.52585636e-01,\n       2.19548381e-01, 1.43917481e-01, 7.29420234e-01, 2.43480099e-01,\n       2.80502889e-01, 1.79434111e-01, 4.77527810e-01, 4.09491510e-01,\n       9.75167208e-01, 6.75184193e-01, 5.84872619e-01, 5.77342807e-01,\n       2.85003405e-01, 8.87184719e-01, 1.16355801e-01, 7.35554824e-01,\n       1.24013004e-01, 4.98390320e-01, 2.16397744e-01, 5.53822787e-01,\n       1.96260005e-01, 5.02868933e-01, 3.11090563e-02, 2.46768705e-01,\n       7.35394909e-01, 5.19689621e-01, 4.95135275e-01, 6.36488593e-01,\n       5.25254822e-01, 2.63066968e-01, 8.89971280e-01, 3.13161731e-01,\n       1.82308237e-02, 1.89502519e-01, 4.09071206e-01, 9.76064011e-03,\n       5.45704311e-01, 9.53276151e-01, 5.59704505e-01, 2.07067188e-01,\n       6.41759332e-02, 5.40570751e-01, 6.85448654e-01, 6.41559203e-01,\n       5.67484382e-01, 3.67901675e-01, 3.88360406e-01, 8.62396452e-01,\n       4.83391607e-02, 2.98826500e-01, 2.87245366e-01, 9.81379650e-01,\n       5.01772265e-01, 1.81215893e-01, 8.47957394e-01, 3.73746504e-01,\n       3.85041209e-01, 3.37156609e-01, 1.50255558e-01, 4.46627035e-01,\n       5.49211816e-01, 4.52836646e-01, 3.81312948e-01, 2.29694327e-01,\n       8.58702776e-01, 8.63031827e-01, 5.62718035e-01, 7.10165693e-01,\n       9.10979874e-01, 1.60458306e-01, 1.27352099e-01, 1.98341592e-01,\n       5.91370725e-01, 7.33427875e-02, 7.33828716e-01, 4.99027872e-02,\n       2.56524814e-02, 9.66295697e-01, 3.53274248e-01, 5.59386955e-01,\n       4.82919017e-01, 6.47204067e-01, 9.42171578e-01, 5.57108997e-01,\n       3.22657791e-01, 4.04844321e-02, 6.44860711e-01, 4.20518623e-01,\n       9.55370116e-01, 5.85203790e-01, 6.34037553e-01, 6.41387498e-01,\n       5.42994115e-01, 3.88003153e-01, 4.61014667e-01, 6.82868933e-01,\n       2.38841304e-01, 1.82540351e-01, 8.99260513e-01, 6.82811763e-01,\n       8.71299481e-01, 3.67317126e-01, 5.75866982e-01, 6.04302596e-01,\n       8.94619187e-01, 8.77432271e-01, 2.60269946e-01, 9.68562352e-01,\n       3.72231077e-01, 6.09669515e-01, 9.93231610e-01, 4.07178709e-01,\n       6.41876306e-01, 9.88305005e-01, 6.29292661e-01, 6.57618907e-01,\n       7.88160705e-01, 7.87910291e-01, 9.48015524e-01, 6.48913074e-01,\n       2.51063503e-01, 6.11801501e-02, 7.97181219e-02, 9.62301018e-01,\n       8.23306828e-01, 5.93376564e-01, 8.99971486e-01, 8.70132481e-01,\n       3.59576234e-01, 8.09451971e-01, 1.99053249e-01, 9.83838075e-01,\n       3.16119220e-01, 2.79590636e-01, 1.82316030e-01, 5.55344640e-01,\n       9.01338225e-01, 5.54274114e-01, 3.89840504e-02, 5.33396917e-02,\n       5.18277669e-01, 8.89943918e-01, 5.83347833e-01, 7.46426878e-01,\n       8.36735442e-01, 1.31531810e-01, 4.28953841e-01, 3.81465212e-03,\n       4.18834672e-01, 8.58456078e-01, 7.87468105e-01, 3.34499223e-01,\n       7.12883037e-01, 7.12539124e-01, 4.91427391e-01, 1.03870391e-01,\n       9.26174898e-01, 5.72580403e-01, 1.78409738e-01, 6.73914909e-01,\n       7.71047912e-01, 1.11449991e-01, 4.24989628e-01, 9.49653830e-01,\n       5.87384706e-01, 7.84826859e-01, 1.51450563e-01, 2.67089098e-01,\n       9.63130696e-01, 8.07866729e-02, 8.94102677e-01, 6.35593048e-02,\n       5.94423335e-01, 1.37989970e-02, 9.02332677e-01, 5.34706480e-01,\n       5.37337899e-01, 3.88505423e-01, 6.97279170e-01, 6.67139924e-01,\n       6.01679114e-01, 4.61518241e-01, 1.89506686e-01, 5.79511760e-01])\n\n\nAlternatively, we can use the uniform method to sample uniformly distributed floats in a specified range. This method allows us to specify the lower and upper bounds of the range, as well as the number of samples to generate.\n\nrng.uniform(0,1,1000)\n\narray([9.39046881e-01, 2.99072349e-01, 4.60476377e-01, 5.75651076e-02,\n       8.53021741e-02, 1.99444561e-01, 6.30163990e-01, 2.72450314e-01,\n       9.49816269e-01, 4.16201503e-01, 6.24219978e-01, 5.65506017e-01,\n       4.97016101e-01, 3.99685405e-01, 4.46141742e-01, 9.96016783e-01,\n       9.20760027e-02, 9.66146235e-01, 2.53428386e-01, 7.98048289e-01,\n       2.30934744e-01, 3.91438675e-01, 7.12524762e-01, 9.24495876e-01,\n       4.36304104e-01, 6.09645109e-01, 3.47455055e-01, 2.09448681e-01,\n       9.40345824e-01, 9.39048542e-01, 9.76034937e-01, 9.78221913e-01,\n       9.02928508e-01, 5.60702051e-01, 3.09192067e-01, 3.91578411e-01,\n       2.92628804e-01, 3.17626904e-01, 7.66354541e-01, 9.39779224e-01,\n       5.69968327e-01, 7.13253015e-01, 2.74080220e-01, 8.95021851e-01,\n       5.30589171e-01, 6.62250513e-01, 8.64017361e-01, 3.16234042e-01,\n       1.88104862e-01, 5.57143310e-01, 8.17542081e-01, 8.58312274e-01,\n       5.01593115e-02, 7.92609803e-01, 2.75257158e-01, 1.06116893e-01,\n       2.96840193e-01, 1.21722548e-01, 3.73409647e-01, 4.84855204e-01,\n       9.22876849e-01, 8.74894519e-01, 7.52243348e-01, 9.78958211e-02,\n       4.50270849e-01, 3.30712733e-01, 9.77906312e-01, 9.14776224e-01,\n       9.13868879e-01, 8.38384506e-01, 7.49295400e-01, 7.10760466e-01,\n       5.26938341e-01, 5.82278280e-01, 4.80260639e-01, 5.05936164e-01,\n       1.61046049e-01, 2.43229116e-01, 2.34171132e-01, 3.40931217e-01,\n       4.66680644e-01, 4.43303703e-01, 9.16474167e-01, 1.64046955e-01,\n       4.32778458e-01, 2.50382062e-01, 9.69336428e-01, 5.05868856e-01,\n       5.97572988e-01, 9.61026988e-01, 6.88217480e-01, 5.12134690e-01,\n       3.64972923e-01, 7.74441496e-01, 4.08990526e-01, 7.56958925e-01,\n       2.00530754e-01, 2.37046734e-02, 3.14880132e-01, 7.18777612e-01,\n       9.93411364e-01, 2.04545022e-01, 8.13393436e-01, 6.02388676e-01,\n       4.72424496e-01, 9.15535640e-01, 5.49467740e-01, 5.53611078e-01,\n       3.79539326e-02, 6.23560704e-01, 7.76300109e-01, 5.83428729e-01,\n       8.06469228e-01, 5.88682791e-01, 7.01220649e-01, 2.81851476e-01,\n       1.52021601e-01, 5.65156070e-01, 7.32794705e-01, 5.48162882e-01,\n       1.77599121e-01, 8.06796579e-01, 1.76029382e-01, 4.15069242e-01,\n       8.61067741e-01, 2.03767686e-01, 3.03374987e-01, 9.56281712e-01,\n       4.96929571e-01, 2.63140565e-01, 5.48214506e-03, 5.07201406e-01,\n       8.67810292e-01, 2.55675259e-01, 6.05977714e-01, 4.75479148e-02,\n       3.11960444e-03, 5.54840591e-01, 1.10582273e-01, 9.77321754e-01,\n       6.44707923e-01, 4.92329798e-01, 4.38426760e-01, 9.96039697e-02,\n       7.20558841e-01, 9.66520259e-01, 5.57218602e-01, 5.66755844e-01,\n       2.00055375e-01, 2.01626605e-01, 1.97593822e-02, 7.08782545e-01,\n       7.83318769e-01, 6.05374008e-01, 8.84005733e-02, 9.24494874e-02,\n       3.37631718e-01, 6.71974027e-01, 8.11094465e-01, 6.48130078e-01,\n       8.56567945e-02, 4.15919142e-01, 1.13229127e-01, 3.84815962e-01,\n       8.98405796e-01, 8.28333721e-01, 6.31976262e-01, 2.10819193e-01,\n       1.02017242e-01, 8.48920389e-01, 5.02509110e-01, 8.23674751e-02,\n       8.78193787e-01, 5.43596167e-01, 9.36220894e-01, 3.72718503e-02,\n       2.33907671e-01, 3.32317764e-01, 1.16643626e-01, 1.79741474e-01,\n       5.50346034e-01, 3.14914038e-01, 4.66292031e-01, 1.19050105e-01,\n       9.67330379e-01, 5.17209722e-01, 3.29413257e-01, 5.06939964e-01,\n       6.77473761e-01, 4.39335185e-01, 5.36633968e-01, 5.08119033e-01,\n       6.60915553e-01, 2.81602932e-01, 7.67412814e-01, 4.37584231e-01,\n       8.53253295e-01, 3.60466663e-01, 1.99149777e-01, 2.73663273e-01,\n       8.36071859e-02, 6.51674516e-01, 2.40058390e-01, 3.99561750e-01,\n       2.94306151e-01, 2.59131632e-01, 9.21081146e-01, 9.77457778e-01,\n       7.59463906e-01, 9.17235823e-01, 2.24739173e-01, 8.95179168e-03,\n       3.32654963e-01, 1.85178069e-01, 1.56566257e-01, 9.86649044e-01,\n       1.83058118e-01, 3.60504984e-01, 3.47485932e-02, 7.00267040e-01,\n       4.87796298e-01, 1.26143539e-01, 2.68842854e-01, 5.48578408e-02,\n       9.76707585e-01, 3.06238432e-01, 6.29145369e-02, 8.71402212e-01,\n       5.46726494e-01, 5.70306434e-01, 3.83497303e-01, 6.60174228e-01,\n       3.03535071e-01, 5.92221133e-01, 2.48318360e-01, 4.25080529e-01,\n       2.38926593e-01, 9.21466382e-01, 4.86994228e-01, 5.98600799e-01,\n       6.02966315e-01, 8.81515304e-01, 5.01991498e-01, 9.55579830e-01,\n       8.03049675e-01, 8.89482334e-01, 5.86259040e-01, 2.98590937e-01,\n       1.70701098e-01, 6.76465597e-01, 4.68659805e-02, 5.81771565e-01,\n       4.30385329e-01, 1.94970270e-01, 8.74490822e-01, 2.76041618e-01,\n       1.11886334e-01, 2.73645781e-01, 4.51729674e-01, 5.64951892e-01,\n       9.49877563e-01, 3.57451532e-01, 8.21238186e-01, 7.82852812e-01,\n       3.15079437e-01, 6.57408126e-01, 6.75003130e-01, 1.97777437e-01,\n       9.33368675e-01, 6.36717139e-02, 6.18067652e-02, 5.53587160e-01,\n       3.13264006e-01, 5.52835105e-01, 2.96553226e-01, 8.86666517e-01,\n       4.54500199e-01, 1.12838032e-01, 2.73088770e-01, 1.60579622e-01,\n       9.88848127e-01, 7.64797877e-01, 2.38755209e-01, 2.06513489e-01,\n       7.09747436e-01, 7.83601141e-01, 4.98321584e-01, 9.22615238e-01,\n       4.33066353e-01, 5.96670489e-01, 6.22017475e-02, 5.40068839e-01,\n       2.28925449e-01, 1.21800229e-01, 3.62077305e-01, 5.96335034e-01,\n       8.45790418e-01, 3.33130975e-01, 5.15639637e-01, 6.67838071e-01,\n       1.07683183e-02, 5.64992104e-01, 6.03295561e-01, 1.21048449e-01,\n       4.45780525e-01, 4.40698882e-01, 7.45671182e-01, 3.15114678e-01,\n       3.63511342e-01, 6.04209884e-02, 2.46925855e-01, 6.54217948e-01,\n       3.15348568e-01, 5.93983769e-01, 3.61622656e-01, 5.89536917e-01,\n       6.51420483e-01, 4.05148560e-01, 8.85472566e-01, 5.94187764e-03,\n       1.29931134e-01, 5.54676669e-01, 1.58565413e-01, 2.97718421e-01,\n       2.39183839e-01, 8.13161632e-01, 2.56432174e-01, 4.55495082e-01,\n       8.66773335e-01, 4.74161695e-01, 8.79824388e-01, 6.13388923e-01,\n       8.05616862e-01, 3.89964154e-01, 5.49124034e-01, 1.88516834e-02,\n       6.78648866e-01, 2.11352893e-02, 7.47267428e-01, 9.93132865e-01,\n       9.56919666e-01, 6.28902825e-01, 7.84826963e-01, 2.31412155e-01,\n       4.61915361e-01, 7.40138069e-01, 1.30809776e-01, 2.89822950e-01,\n       1.72577763e-01, 2.58512370e-01, 1.11739129e-01, 2.05501170e-01,\n       6.21224997e-01, 9.57338512e-01, 5.45806568e-01, 9.25340888e-01,\n       3.65686268e-01, 7.11680890e-01, 3.39997009e-01, 5.11716892e-01,\n       1.48922035e-01, 7.67503817e-01, 2.62191161e-01, 4.70173622e-01,\n       9.72929519e-01, 4.69575122e-01, 9.09733151e-01, 8.44748028e-01,\n       5.02236810e-01, 1.34381388e-01, 1.85123585e-01, 4.22317586e-01,\n       4.36513643e-01, 7.68556667e-01, 7.44617946e-01, 8.07089891e-02,\n       3.67476926e-01, 3.92403075e-02, 2.27581056e-01, 9.55978199e-01,\n       2.67355271e-01, 1.09349430e-01, 6.84934585e-01, 9.57111536e-02,\n       9.15547961e-01, 6.26693750e-01, 6.91814895e-01, 5.52959059e-01,\n       3.60970462e-01, 3.03738771e-02, 2.86480059e-01, 5.99010907e-02,\n       7.71218831e-01, 4.30088632e-01, 6.74977103e-01, 8.35081532e-01,\n       2.95654631e-01, 8.74616706e-01, 1.24960991e-01, 5.26928286e-01,\n       7.77395342e-01, 7.39842315e-01, 6.60814147e-01, 5.65130412e-01,\n       2.20348043e-01, 2.38456453e-01, 9.31657446e-03, 4.48256654e-01,\n       2.65352845e-01, 2.40815269e-01, 6.38530143e-01, 1.56858034e-01,\n       2.36504980e-01, 7.46484788e-01, 3.97029208e-01, 7.67796987e-01,\n       1.80498800e-01, 3.82578022e-01, 6.21753653e-01, 5.82020157e-01,\n       2.96019333e-01, 9.92414322e-01, 3.89788153e-01, 6.38642355e-01,\n       1.66983293e-01, 1.73415192e-01, 1.37398670e-02, 2.37580668e-01,\n       1.99639036e-01, 7.95087954e-01, 1.77660488e-01, 3.70720849e-01,\n       9.26332543e-01, 3.83092454e-01, 1.57896459e-01, 8.87986269e-01,\n       1.62724795e-01, 9.43776004e-01, 9.47770523e-01, 2.08565739e-01,\n       2.56907715e-01, 6.80663558e-01, 3.41946270e-01, 1.34994192e-01,\n       4.94789023e-01, 5.66743643e-03, 2.45165622e-01, 6.19023288e-01,\n       9.75593920e-01, 5.92461338e-02, 9.09004205e-02, 4.63243802e-01,\n       8.22387350e-01, 1.70918091e-01, 5.75100984e-01, 3.35140369e-01,\n       4.68705969e-01, 1.47151202e-01, 8.47253985e-01, 4.19769574e-01,\n       2.68394636e-02, 6.12353914e-01, 2.57518300e-01, 7.60307339e-01,\n       1.18149812e-02, 4.16342047e-01, 6.39608253e-01, 3.22392740e-01,\n       3.74420155e-01, 3.90134937e-01, 6.81239224e-01, 9.29478422e-01,\n       9.29048739e-01, 2.20197109e-01, 5.48000828e-01, 4.47280939e-01,\n       2.26052968e-01, 6.74115280e-01, 8.49571863e-01, 6.92680684e-01,\n       2.41917850e-01, 8.63866200e-01, 7.37356681e-01, 3.91472579e-01,\n       6.11947071e-01, 7.22743143e-01, 7.29350342e-01, 3.82094538e-01,\n       1.13268130e-01, 6.61689390e-01, 5.48965399e-01, 5.78609601e-01,\n       8.28296877e-01, 8.66148183e-01, 6.06183160e-01, 7.43907862e-01,\n       6.84041139e-01, 5.04629593e-01, 5.85694492e-01, 5.44613518e-01,\n       5.04709317e-01, 3.67703861e-01, 7.06676888e-01, 8.14875765e-02,\n       4.58417580e-01, 5.44996000e-01, 8.40103325e-01, 4.09019151e-01,\n       4.54258064e-01, 5.01554503e-01, 8.82274163e-01, 6.98791958e-01,\n       4.94292773e-01, 2.70974854e-01, 9.80345041e-01, 3.77745309e-01,\n       3.54225457e-01, 3.57946109e-01, 1.63522213e-01, 5.04434221e-01,\n       1.57169153e-01, 2.62902242e-01, 7.54080831e-01, 1.42662222e-01,\n       4.89198857e-02, 8.96956676e-01, 1.66028183e-01, 1.05744495e-01,\n       5.77262122e-01, 4.95333468e-01, 2.69221539e-01, 7.50629043e-02,\n       8.00641226e-01, 6.37875957e-01, 1.44590932e-01, 2.89403720e-01,\n       8.29014256e-01, 9.06232511e-01, 5.34988220e-01, 1.88377352e-01,\n       1.40360738e-02, 1.21884387e-01, 8.53648493e-01, 7.39454445e-01,\n       2.55709883e-01, 4.96526758e-01, 1.41675501e-01, 1.10881288e-01,\n       2.27003581e-02, 5.06955737e-01, 7.12320947e-01, 6.13523558e-02,\n       4.05780570e-01, 5.75356159e-01, 4.27570251e-01, 3.91731663e-02,\n       3.59125118e-01, 6.07530855e-01, 2.09980493e-01, 6.37577808e-01,\n       4.67977959e-01, 6.67936873e-01, 5.15925675e-01, 1.72443532e-02,\n       9.90899812e-01, 6.63725434e-01, 2.65976611e-02, 3.29401293e-01,\n       2.03772643e-01, 5.25321081e-01, 5.21774029e-01, 3.61756661e-01,\n       7.01433873e-01, 8.60661979e-01, 2.83490606e-01, 9.75994671e-02,\n       9.97636879e-01, 8.39402421e-01, 2.89122434e-01, 6.01370400e-01,\n       7.78274265e-02, 9.58840484e-01, 2.95308935e-01, 2.73414800e-01,\n       2.15145912e-01, 2.32607254e-01, 8.99541130e-01, 2.61819681e-01,\n       4.29901612e-01, 5.09332053e-01, 7.76760074e-01, 9.66727606e-01,\n       9.03271662e-01, 5.21577287e-01, 7.01896898e-01, 2.48531042e-01,\n       5.48329026e-01, 1.89795727e-01, 1.16278273e-01, 7.70498781e-02,\n       7.98109521e-01, 3.07431651e-01, 9.33656812e-01, 7.09477107e-01,\n       6.03351999e-01, 3.42529819e-01, 3.89799751e-01, 8.14044765e-01,\n       5.48647495e-01, 6.78955853e-01, 5.27875352e-01, 9.22524052e-01,\n       4.64668625e-01, 7.77288260e-01, 6.63861343e-01, 7.56830805e-01,\n       3.87510118e-01, 3.39214872e-01, 4.09521302e-01, 4.99021471e-02,\n       6.71094039e-02, 8.71835442e-01, 7.14479803e-01, 8.71500636e-01,\n       4.70883837e-01, 3.38454678e-01, 1.93298748e-01, 9.08053118e-03,\n       1.19849570e-02, 8.25213241e-01, 3.45732425e-02, 1.25061895e-01,\n       9.67070867e-01, 9.52576638e-02, 1.13074586e-01, 8.66017214e-01,\n       8.56738468e-01, 6.34160252e-01, 5.21817310e-01, 2.37326991e-02,\n       4.45799054e-02, 1.17434528e-01, 8.40408591e-01, 5.55745783e-01,\n       7.56024738e-01, 6.23063634e-01, 2.26936673e-01, 6.02586173e-01,\n       7.99224608e-02, 2.75581484e-01, 7.36358231e-01, 3.16760623e-01,\n       3.88639057e-01, 3.14300712e-01, 7.05166414e-01, 9.96209335e-01,\n       8.13363557e-01, 3.00410449e-02, 3.44026549e-01, 6.82195590e-01,\n       4.77584431e-01, 1.08808256e-01, 9.29270784e-01, 1.16843153e-01,\n       6.11075707e-01, 9.44947830e-01, 2.16341973e-01, 1.38111313e-01,\n       2.31941259e-01, 7.93296534e-01, 7.84660508e-01, 9.62220776e-01,\n       9.78038714e-01, 2.56622990e-01, 2.52882748e-01, 8.58728884e-01,\n       2.47908013e-01, 8.25546762e-01, 5.73483018e-01, 5.18959054e-01,\n       8.54767299e-01, 5.67634881e-01, 7.72012376e-01, 8.45391591e-01,\n       2.53787662e-01, 9.26891731e-01, 4.02300539e-01, 4.04906953e-01,\n       8.96553754e-01, 4.03917983e-01, 2.46264529e-01, 6.63359181e-01,\n       7.97039743e-01, 1.21872038e-01, 2.47078205e-02, 3.44022010e-01,\n       6.14689214e-01, 2.46268973e-01, 1.16183060e-01, 5.92593818e-02,\n       9.36196851e-01, 1.80862637e-01, 1.56036063e-01, 3.28245470e-01,\n       6.25056396e-01, 9.60057105e-01, 9.80454137e-01, 7.38615659e-01,\n       6.38647060e-01, 4.21520023e-01, 6.41029746e-01, 1.55398359e-01,\n       1.38090820e-01, 4.41676356e-01, 2.09316965e-01, 1.39274604e-01,\n       6.20597119e-01, 2.93102739e-01, 4.77086274e-01, 4.94198881e-01,\n       1.81244310e-01, 4.66419340e-04, 2.20412012e-01, 4.65466297e-01,\n       3.86666608e-01, 6.60946666e-01, 7.13174475e-01, 9.10054744e-01,\n       2.58206349e-01, 8.46718455e-01, 4.40410752e-01, 1.81451945e-01,\n       5.64716926e-01, 6.01446750e-01, 1.06598346e-01, 3.37186056e-01,\n       4.10934087e-01, 3.00209335e-01, 6.95339769e-01, 1.37981177e-01,\n       4.69806787e-01, 8.22103214e-03, 2.93250660e-01, 9.72403853e-01,\n       9.10775460e-02, 7.68391492e-01, 4.71175346e-01, 2.40473886e-01,\n       6.39844114e-01, 7.71800659e-01, 1.41401672e-01, 8.53959169e-01,\n       2.47556814e-01, 7.74939840e-01, 4.45042170e-02, 2.73398114e-01,\n       5.54265246e-01, 8.63758971e-01, 7.74219411e-01, 4.16773829e-01,\n       7.25118538e-01, 5.39290104e-01, 1.08711474e-01, 8.25583851e-02,\n       3.06353166e-01, 3.83219529e-01, 8.60839451e-01, 6.79976844e-01,\n       7.25867199e-01, 9.85427779e-01, 4.16377951e-02, 5.28858098e-02,\n       3.77562877e-02, 7.36128174e-01, 9.58813188e-01, 1.35057390e-02,\n       3.90703157e-01, 9.18964128e-01, 2.34047390e-01, 4.81482219e-01,\n       4.56424670e-01, 6.74335839e-01, 7.76822974e-01, 8.24378193e-01,\n       7.11327420e-01, 1.47612393e-01, 1.15066955e-02, 9.90341638e-01,\n       8.25234650e-01, 7.49161961e-01, 8.16225638e-01, 4.60326996e-01,\n       2.97124482e-01, 8.54610518e-01, 5.38353447e-01, 9.61631350e-01,\n       2.02053203e-01, 3.98745264e-01, 8.97869081e-01, 2.17531012e-01,\n       7.17190664e-01, 8.42895400e-01, 5.09209175e-01, 2.77850835e-01,\n       7.70385101e-01, 8.98876379e-01, 2.26329732e-02, 7.01434107e-01,\n       4.83751864e-01, 5.78432737e-01, 8.58170356e-01, 6.29490891e-02,\n       1.36025401e-01, 5.23700295e-01, 4.73706162e-01, 3.11395564e-01,\n       3.40342608e-01, 3.84414625e-01, 2.87871960e-01, 2.53824671e-01,\n       5.81916507e-01, 5.30911228e-01, 9.35411249e-01, 2.77090201e-03,\n       2.87714150e-01, 2.84669971e-01, 6.69182996e-01, 5.17995845e-01,\n       8.30357304e-01, 4.08039237e-01, 6.70209778e-01, 7.09472033e-01,\n       9.77039514e-01, 1.30699083e-01, 7.45993968e-01, 6.47610354e-02,\n       6.18952393e-01, 1.07269919e-01, 6.18547614e-02, 6.14745389e-01,\n       8.45125076e-01, 1.37897722e-01, 7.49469598e-01, 3.09935872e-01,\n       1.57855778e-01, 9.14563453e-01, 4.60090006e-01, 6.86840379e-01,\n       6.13167260e-01, 5.71956868e-01, 1.84486682e-01, 4.19567448e-01,\n       8.01451099e-01, 2.59943308e-01, 8.23728384e-02, 6.84533421e-01,\n       7.52549554e-01, 8.28840346e-01, 6.17659030e-01, 2.97600327e-01,\n       1.73955591e-01, 3.05756051e-01, 2.03569042e-03, 2.54816952e-01,\n       4.81229534e-01, 8.34690453e-01, 2.58826221e-01, 1.11862945e-01,\n       3.10177435e-01, 8.08646191e-01, 9.51128390e-01, 7.56449872e-02,\n       7.83386996e-01, 4.60595694e-01, 4.58201195e-01, 5.10289507e-01,\n       7.58101706e-01, 9.16468399e-01, 1.28482444e-01, 2.58583506e-01,\n       6.96765118e-01, 5.84025781e-03, 6.92299901e-01, 4.59616732e-01,\n       4.50523518e-01, 7.40215177e-01, 3.62022582e-01, 1.37208974e-01,\n       6.51771446e-01, 7.82904524e-01, 9.52234843e-01, 2.89850315e-01,\n       6.88595675e-01, 7.69937931e-01, 4.58378344e-01, 9.38766474e-01,\n       7.63179411e-01, 1.36882670e-01, 5.56652611e-01, 4.64698167e-01,\n       2.43621928e-01, 1.34920453e-01, 5.40979105e-01, 9.16859843e-01,\n       7.63449237e-01, 1.51858144e-01, 8.46576703e-01, 2.21823340e-01,\n       8.16840578e-01, 9.24855411e-01, 4.55731745e-01, 7.04288066e-01,\n       4.78152964e-01, 4.25379117e-01, 4.75146881e-01, 3.36648240e-01,\n       3.66605023e-01, 1.88449642e-01, 6.46731540e-01, 9.75416668e-01,\n       1.63605016e-01, 3.90714947e-01, 2.82926824e-01, 7.73025605e-01,\n       3.60698230e-01, 4.32143099e-03, 3.13347157e-01, 4.75902720e-01,\n       1.58720271e-01, 1.73788611e-01, 1.45198501e-01, 8.55673458e-01,\n       1.85380867e-01, 5.08237057e-01, 3.55181571e-01, 9.86155074e-01,\n       7.14983227e-01, 4.80624993e-01, 9.08687883e-01, 2.45265759e-01,\n       3.94426028e-02, 2.72335210e-01, 5.45585942e-01, 9.67169884e-01,\n       3.83255134e-01, 6.22768792e-01, 5.42178103e-01, 6.89709536e-01,\n       4.53036264e-01, 2.74958603e-01, 5.31887941e-01, 4.07142284e-01,\n       3.96566101e-02, 9.52339397e-01, 9.80892467e-01, 1.61702610e-01,\n       9.16305525e-01, 8.12907902e-01, 7.82202816e-01, 6.91177192e-01,\n       6.48327907e-01, 5.89161241e-01, 2.09708712e-01, 9.87087151e-01,\n       8.80355881e-01, 2.39709542e-02, 9.80054161e-01, 5.58697731e-01,\n       7.66711638e-01, 8.39535815e-01, 2.76899511e-01, 1.12798250e-01,\n       5.19525737e-01, 5.50361612e-01, 2.69184868e-01, 4.55888948e-01,\n       1.14524741e-01, 7.97432455e-01, 9.47297306e-01, 2.10065007e-03,\n       3.25631610e-01, 3.93960918e-01, 1.70772596e-01, 9.78050550e-01,\n       2.29130937e-01, 7.56058374e-01, 3.67350583e-01, 6.92963971e-01,\n       8.69916159e-02, 2.93356699e-01, 6.65430208e-01, 1.86539047e-01,\n       3.98378860e-01, 9.84440292e-01, 6.01335919e-01, 1.05915265e-01,\n       4.35912414e-02, 3.47717412e-01, 9.45176602e-01, 9.58938703e-01])\n\n\n\n\nNormal distribution\nTo sample from a normal distribution, we can use the normal method of the generator. This method allows us to specify the mean and standard deviation of the distribution, as well as the number of samples to generate. The generated samples will follow a normal (Gaussian) distribution with the specified parameters.\n\nnormal_rv = rng.normal(loc=0, scale=4, size=10000)  # 10000 samples from a normal distribution with mean 0 and std dev 1\n\n\n# check that the sample mean and standard deviation are close to the specified values \n\nnormal_rv.mean()\n\n-0.00030211517930401043\n\n\n\nnormal_rv.std()\n\n3.988386668060006",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "href": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "title": "Working with Arrays in NumPy: Indexing and Random Data Generation",
    "section": "Sampling a siingle value",
    "text": "Sampling a siingle value\nIf we only want to sample a single value, we can simply not specify the size parameter, or set it to 1. This will return a single value sampled from the specified distribution.\n\nrng.integers(0,100) # run this multiple times to observe the random nature of the output\n\n22\n\n\nHowever, this can sometimes be more computationally costly than generating a larger sample and then selecting a single value from it.\n\nimport time\n\n# Timing a for loop that generates a random integer in each iteration\nstart_time = time.time()\nsteps = 1000000\nfor _ in range(steps):\n    # use a random value\n    val = 2*rng.integers(0, 100)\nelapsed_no_prealloc = time.time() - start_time\n\n# Timing a for loop that uses preallocated random integers\npreallocated = rng.integers(0, 100, size=steps)\nstart_time = time.time()\nfor u in preallocated:\n    val = 2*u  # use the preallocated value\nelapsed_prealloc = time.time() - start_time\n\nprint(f\"Time without preallocation: {elapsed_no_prealloc:.4f} seconds\")\nprint(f\"Time with preallocation: {elapsed_prealloc:.4f} seconds\")\n\nTime without preallocation: 0.9014 seconds\nTime with preallocation: 0.0658 seconds\n\n\nThis is a good example of the tradeoff between memory usage and computational efficiency: in modern machines, memory is quite cheap, so it is often more efficient to preallocate a larger array and then sample from it, rather than generating a single value at a time.\nA good size for preallocated numbers depends on your use case and available memory. Typical choices are:\n\nSmall tasks: 100 to 1,000 elements\nMedium tasks: 10,000 to 100,000 elements\nLarge tasks: 1,000,000 or more elements\n\nFor most data analysis or simulation tasks, starting with 100,000 elements is practical and efficient. Always ensure the size fits within your system’s memory limits.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with Arrays in NumPy: Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "09/exercises_plotting_data_from_file.html",
    "href": "09/exercises_plotting_data_from_file.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\ndata_filename = \"data/FIRST ORDER_k=0.0005.txt\"\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\nopen_file = open(data_filename)\ndata_from_file = open_file.read()\nprint(data_from_file[0:200])\n\nTime    A   B   \n0   1   0   \n100 0.950565    0.0494353   \n200 0.903573    0.0964268   \n300 0.858905    0.141095    \n400 0.816445    0.183555    \n500 0.776083    0.223917    \n600 0.737717    0.262283    \n700 0.701248    0.298752    \n800 0.666582    0.33341\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\nimport numpy as np\n\ndata_kinetic_k0005 = np.genfromtxt(\"data/FIRST ORDER_k=0.0005.txt\", names=True)\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\ndata_kinetic_k0005.dtype.names\n\n('Time', 'A', 'B')\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\ndata_kinetic_k0005['A']\n\narray([1.        , 0.950565  , 0.903573  , 0.858905  , 0.816445  ,\n       0.776083  , 0.737717  , 0.701248  , 0.666582  , 0.633629  ,\n       0.602305  , 0.57253   , 0.544227  , 0.517323  , 0.491749  ,\n       0.467439  , 0.444331  , 0.422365  , 0.401486  , 0.381638  ,\n       0.362772  , 0.344838  , 0.327791  , 0.311586  , 0.296183  ,\n       0.281541  , 0.267623  , 0.254393  , 0.241817  , 0.229863  ,\n       0.218499  , 0.207698  , 0.19743   , 0.18767   , 0.178393  ,\n       0.169574  , 0.161191  , 0.153222  , 0.145648  , 0.138447  ,\n       0.131603  , 0.125097  , 0.118913  , 0.113035  , 0.107447  ,\n       0.102135  , 0.097086  , 0.0922865 , 0.0877243 , 0.0833876 ,\n       0.0792653 , 0.0753468 , 0.071622  , 0.0680813 , 0.0647157 ,\n       0.0615165 , 0.0584754 , 0.0555846 , 0.0528368 , 0.0502248 ,\n       0.0477419 , 0.0453818 , 0.0431383 , 0.0410057 , 0.0389786 ,\n       0.0370517 , 0.03522   , 0.0334789 , 0.0318239 , 0.0302506 ,\n       0.0287552 , 0.0273337 , 0.0259824 , 0.024698  , 0.023477  ,\n       0.0223164 , 0.0212132 , 0.0201645 , 0.0191677 , 0.0182201 ,\n       0.0173194 , 0.0164632 , 0.0156493 , 0.0148757 , 0.0141403 ,\n       0.0134413 , 0.0127768 , 0.0121452 , 0.0115448 , 0.0109741 ,\n       0.0104316 , 0.00991587, 0.00942568, 0.00895972, 0.00851679,\n       0.00809576, 0.00769554, 0.00731511, 0.00695349, 0.00660974,\n       0.00628298])\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\ndata_kinetic_k0005 ['Time']\n\narray([    0.,   100.,   200.,   300.,   400.,   500.,   600.,   700.,\n         800.,   900.,  1000.,  1100.,  1200.,  1300.,  1400.,  1500.,\n        1600.,  1700.,  1800.,  1900.,  2000.,  2100.,  2200.,  2300.,\n        2400.,  2500.,  2600.,  2700.,  2800.,  2900.,  3000.,  3100.,\n        3200.,  3300.,  3400.,  3500.,  3600.,  3700.,  3800.,  3900.,\n        4000.,  4100.,  4200.,  4300.,  4400.,  4500.,  4600.,  4700.,\n        4800.,  4900.,  5000.,  5100.,  5200.,  5300.,  5400.,  5500.,\n        5600.,  5700.,  5800.,  5900.,  6000.,  6100.,  6200.,  6300.,\n        6400.,  6500.,  6600.,  6700.,  6800.,  6900.,  7000.,  7100.,\n        7200.,  7300.,  7400.,  7500.,  7600.,  7700.,  7800.,  7900.,\n        8000.,  8100.,  8200.,  8300.,  8400.,  8500.,  8600.,  8700.,\n        8800.,  8900.,  9000.,  9100.,  9200.,  9300.,  9400.,  9500.,\n        9600.,  9700.,  9800.,  9900., 10000.])\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n# Extract time and concentration of A from our array\ntime = data_kinetic_k0005['Time']\nconcentration_A = data_kinetic_k0005[\"A\"]\n\nWe could then use matplotlib to plot this:\n\nimport matplotlib.pyplot as plt\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time, concentration_A)\n\n# Add x and y labels for this data\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\n\nText(0, 0.5, 'Concentration')\n\n\n\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\nmask = concentration_A &lt;= 0.5\nconcentration_A_low = concentration_A[mask]\n# Make sure to match the time values (index) to our filtered data\ntime_low = time[mask]\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time_low, concentration_A_low)\n\n# Note: Alternative syntax! we can set multiple properties at once\nax.set(xlabel = \"Time (s)\",  ylabel=\"Concentration\")\n\n\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting data from file"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html",
    "href": "09/lecture_intro_matplotlib.html",
    "title": "Plotting with matplotlib",
    "section": "",
    "text": "One way to plot a graph in Python is to use the matplotlib package.\nMatplotlib is a powerful and widely-used Python library for creating static, animated, and interactive visualizations. It provides a flexible framework for generating a wide variety of plots and charts, making it a popular choice for data analysis and scientific research. With matplotlib, you can customize every aspect of your figures, from colors and styles to labels and legends.\nWe start by importing the pyplot sub-module from matplotlib.\nThe most widespread convention is to use the shorthand plt to refer to this package with the as syntax and so we can import this in the following way:\nimport matplotlib.pyplot as plt",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "href": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "title": "Plotting with matplotlib",
    "section": "Figure and Axes",
    "text": "Figure and Axes\nThere are two main interfaces for plotting using matplotlib.\n\nThe first is to use Pyplot (plt) to create a plot directly e.g. using plt.plot(). This is the type of syntax you may see often when looking online. This way of interacting with and plotting data was created to replicate the functionality of an alternative, and common programming language called MATLAB, which a lot of early Python adopters were familiar with.\nThe second, more modern way to create plots is to use the object-oriented approach where the figure is created first and then explicitly referenced when creating a plot. One way to do this is by calling the subplots() function to create a Figure (the canvas) and an Axes (the x-y axes) object which can then be used for plotting.\n\nfig, ax = plt.subplots()\nWe can plot using the ax object directly using whichever type of graph we want to create e.g.  - for a simple line graph we can use the plot() function - for a scatter graph we can use the scatter() function. - for a 1D histogram we can the hist() function\nYou can also add multiple graphs to the same set of Axes to plot sets of data on top of each other:\n\nimport numpy as np\nfrom numpy import random\n\nrng = random.default_rng(seed=124)\n\nx = np.arange(1, 56, 5)\ny1 = x**2\ny2 = x**2 + rng.normal(size=len(x))*100 # Add random noise to our scatter points\n\n\nfig, ax = plt.subplots()\nax.plot(x, y1)      # Plot line plot\nax.scatter(x, y2)   # Plot scatter plot as well\n\n\n\n\n\n\n\n\nYou may notice that unlike other Python you have been writing, in Jupyter notebooks you should keep your plotting code together in one code cell as this will immediately be displayed when the code cell is run.\nTo create another plot in a new cell you can create new Figure and Axes objects using the same names fig, ax or name them something different if you’d prefer.\nMatplotlib sample plots - https://matplotlib.org/3.3.3/tutorials/introductory/sample_plots.html\n\nAside: subplots\nYou may ask why the function for creating a new plot is called subplots(). By default, this function allows you to create one plot on one figure, which is usually what you want for an initial plot. However, it is possible to use the subplots() function to create multiple plots on the same figure. One way to do this is by specifying the number of rows (nrows) and number of columns (ncols) you want when using the subplots() function. Note that this will pass back an array of Axes objects rather than just one which you can then use to plot.\nWe won’t explore this further, but for more details on how this is done have a look at the subplots demo.\n\n\n\nExercise A\nFor this exercise, we have created some random sample data which we can plot. Here we have created several numpy arrays each 100 elements long (based on num_points).\n\nfrom numpy import random\n\nrng = random.default_rng(seed=68)\nnum_points = 100\n\nx_range = np.linspace(0.0, 1.0, num_points)\n\nrandom_sample1 = rng.normal(0.1, 0.5, size=num_points)\nrandom_sample2 = rng.random(num_points)\n\n\nCreate a scatter plot of x_range versus random_sample1.\n\n\nStart by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the scatter method to plot your data using your Axes object\n\n\n### ADD CODE HERE\n\n\nCreate a line plot of x_range versus random_sample2\n\n\nAs before, start by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the plot method to plot your data using your Axes object\n\n\n### ADD CODE HERE",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "href": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "title": "Plotting with matplotlib",
    "section": "Annotating and adding features",
    "text": "Annotating and adding features\nAs well as plotting you can, and should, add additional information to your plot as appropriate. For instance, you can:\n\nchange the style, colour etc. of your initial plot (e.g. see examples within matplotlib decoration)\nadd additional features such as axis labels, legend etc.\n\nThe code below demonstrates how we could customise the plot above using these inputs:\n\n1. Using more of the available plotting options\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\")\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n\n\n\n\n\n\n\nWe can include more inputs for both our subplots function and our plotting functions such as plot() and scatter():\n\nFor the subplots() initial step we specified the figure size, figsize, as an input. This is set using a tuple of (width, height) in inches.\nFor the plot function we set:\n\nthe colour to be a named colour called “slategrey” using the color input\nthe style of the line to be dashed, using “–” and the linestyle input\n\nFor the scatter function we set:\n\nthe colour to be a named colour called “indianred” using the color input\nthe marker shape to a cross shape, using “+” and the marker input\nsize to be 60 (area of the marker) using the s input\n\n\nFor in-built options see: - Colours - https://matplotlib.org/stable/gallery/color/named_colors.html - Line style - https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html - Markers - https://matplotlib.org/api/markers_api.html\n\n\n2. Setting properties on the plot\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\")\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n### ADDED x and y labels and an x limit\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_xlim(0, 52)\n\n\n\n\n\n\n\n\nHere we set additional parameters for the plot - the x and y labels and an x limit. We have done this by calling the relevant functions (e.g. set_xlabel, set_ylim) on our ax variable.\nFor some examples of different Axes functions of this type see: - Axes - labels and limits - https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend - Axes - tick labels - https://matplotlib.org/stable/api/axes_api.html#ticks-and-tick-labels\n\n\n3. Additional labelling - legend\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\n### Added labels for each of the plots\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\", label=\"Fitted line\")  # label input added when plotting\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60, label=\"Measurements\")  # label input added when plotting\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nax.set_xlim(0, 52)\n\n### Asked for a legend to be displayed\nax.legend()\n\n\n\n\n\n\n\n\nA legend can be created using the .legend() function (method) and this will use the label value supplied when creating each plot. If ax.legend() is not included then, even if a label variable is specified, no legend will be added to the plot.\nSee: - legend function - https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#other-plot-types",
    "href": "09/lecture_intro_matplotlib.html#other-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Other plot types",
    "text": "Other plot types\nWe can also apply similiar principles to other plot types. We can generate some more random data to look at this. Here we have created two normal distributions containing different numbers of points.\n\n# Create random numbers (normal distribution) to plot\nfrom numpy import random\n\nrng = random.default_rng(seed=68)\nnumber_of_points_1 = 5000\nnumber_of_points_2 = 500\n\nx_rand1 = rng.normal(size=number_of_points_1)\nx_rand2 = rng.normal(size=number_of_points_2)\n\nWe could create a simple plot using the subplots function and the hist() function:\n\nfig, ax = plt.subplots()\n\nax.hist(x_rand1)\nax.hist(x_rand2)\n\n(array([ 10.,  30.,  66., 103.,  93.,  93.,  55.,  40.,   7.,   3.]),\n array([-2.48175617, -1.9278922 , -1.37402822, -0.82016424, -0.26630026,\n         0.28756372,  0.8414277 ,  1.39529168,  1.94915565,  2.50301963,\n         3.05688361]),\n &lt;BarContainer object of 10 artists&gt;)\n\n\n\n\n\n\n\n\n\nUsing the exact same data we could update our plot using relevant inputs for our hist function and setting values on our axis:\n\nfig, ax = plt.subplots()\n\n# Create an explicit range to use for our histogram bins\nbins = np.arange(-3, 3, 0.2)\n\n# Include colour, transparency (alpha), plot type (density) inputs as well as a label\nax.hist(x_rand1, color=\"skyblue\", alpha=0.7, bins=bins, density=True, label=\"Sample 1\")\nax.hist(x_rand2, color=\"tan\", alpha=0.7, bins=bins, density=True, label=\"Sample 2\")\n\n# Update plotting area to label and set axes limits\nax.set_xlabel(\"y\")\nax.set_ylabel(\"Number in x\")\nax.set_xlim(-3, 3)\nax.set_ylim(0, 0.5)\n\n# Add legend to the plot (uses labels defined above)\nax.legend()\n\n\n\n\n\n\n\n\nFor our histogram, in addition to options we used for our scatter and line plot, we have set more options available to us: - alpha - This allows us to make our data partially transparent to better view overlapping data - bins - We defined and included an input for the bin sizes rather than using the default - density - This is a plot type we can set which normalised our data for the different datasets. This can be useful if you are comparing datasets which have different sample sizes.\nIn general, you will need to look at the specific documentation for each of the the plot types to see what options are available.",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "href": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a figure",
    "text": "Anatomy of a figure\nThis is a summary image to show the make up (anatomy) of a plot in matplotlib.\n\nYou can see some features we have described above such as “Figure”, “Axes”, “x axis label”, “y axis label”, “legend”. But you can also see how our inputs have influenced other aspects of the plot e.g. “Major tick”, “Minor tick”, “Major tick label”, “Minor tick label”, which were updated when we set the limits on the x and y axes, and “Markers” from our scatter plot which updated the marker style and colour.\nBecoming familiar with this terminology when applied to a matplotlib figure allows you to put a name to any part of the plot you wish to modify and to dig into the features offered for how to update these plots.\n\n\nExercise B\n\nCreate a scatter plot with the same data from Exercise A showing x_range versus random_sample1 adding or setting the following features:\n\n\nchanging the marker and colour\nsetting appropriate x and y labels\n\nRemember, you always need to recreate your fig and ax objects using the subplots function to create a new plot using Jupyter notebooks\n\n### ADD CODE HERE (copy code from Exercise A1 to start)\n\n\nCreate a histogram plot overlaying data from random_sample1 and random_sample2.\n\n\nExperiment with different inputs to see if you can improve the default plot (e.g. setting the bin size, including transparency, changing the colours etc.)\nYou can also look at the hist() function documentation for more inputs to try e.g. histtype.\n\n\n### ADD CODE HERE\n\nExtra. Create a plot containing both a scatter plot for x_range versus random_sample1 AND a line plot for x_range versus random_sample2. Add or set the following features: - changing the line style and colour - setting a title for your plot\nHint: Look at “set_” commands within https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend\n\n### ADD CODE HERE\n\n\nExtended: Pick an interesting plot from the matplotlib gallery and see if you replicate some of the additional features for these plots.\n\nYou can now proceed with the remaining exercises\n\nExercise C - Plotting data from a file\nA fun session - Using matplotlib to create a fun plot",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html",
    "href": "07/exercises_numpy_solutions.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape.\n\nimport numpy as np\n\narr = np.array([2, 4, 6, 8, 10, 12])\nprint(\"Array:\", arr)\nprint(\"Data type:\", arr.dtype)\nprint(\"Shape:\", arr.shape)\n\nArray: [ 2  4  6  8 10 12]\nData type: int64\nShape: (6,)",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element\n\n\nprint(\"First element:\", arr[0])\nprint(\"Last element:\", arr[-1])\nprint(\"Elements from index 2 to 4:\", arr[2:5])\nprint(\"Every second element:\", arr[::2])\n\nFirst element: 2\nLast element: 12\nElements from index 2 to 4: [ 6  8 10]\nEvery second element: [ 2  6 10]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element\n\n\narr = np.array([1, 4, 9, 16, 25])\nprint(\"Original array:\", arr)\nprint(\"Multiply by 3:\", arr * 3)\nprint(\"Add 10:\", arr + 10)\nprint(\"Square root:\", np.sqrt(arr))\nprint(\"Sine function:\", np.sin(arr))\n\nOriginal array: [ 1  4  9 16 25]\nMultiply by 3: [ 3 12 27 48 75]\nAdd 10: [11 14 19 26 35]\nSquare root: [1. 2. 3. 4. 5.]\nSine function: [ 0.84147098 -0.7568025   0.41211849 -0.28790332 -0.13235175]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1\n\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nprint(\"arr1:\", arr1)\nprint(\"arr2:\", arr2)\nprint(\"Addition:\", arr1 + arr2)\nprint(\"Subtraction (arr2 - arr1):\", arr2 - arr1)\nprint(\"Multiplication:\", arr1 * arr2)\nprint(\"Division (arr2 / arr1):\", arr2 / arr1)\n\narr1: [1 2 3 4 5]\narr2: [10 20 30 40 50]\nAddition: [11 22 33 44 55]\nSubtraction (arr2 - arr1): [ 9 18 27 36 45]\nMultiplication: [ 10  40  90 160 250]\nDivision (arr2 / arr1): [10. 10. 10. 10. 10.]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment.\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nprint(\"arr_a:\", arr_a)\nprint(\"arr_b:\", arr_b)\n\ntry:\n    result = arr_a + arr_b\n    print(\"Result:\", result)\nexcept ValueError as e:\n    print(\"Error occurred:\", e)\n    \n# This happens because the arrays have different shapes: (4,) and (2,)\n# NumPy cannot broadcast these shapes together for element-wise operations\n# The arrays must have compatible shapes for element-wise operations\n\narr_a: [1 2 3 4]\narr_b: [10 20]\nError occurred: operands could not be broadcast together with shapes (4,) (2,)",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation\n\n\ndata = np.array([12, 8, 15, 3, 7, 20, 11, 9])\n\nprint(\"Data:\", data)\nprint(\"Sum:\", np.sum(data))\nprint(\"Mean:\", np.mean(data))\nprint(\"Maximum:\", np.max(data))\nprint(\"Minimum:\", np.min(data))\nprint(\"Standard deviation:\", np.std(data))\n\nData: [12  8 15  3  7 20 11  9]\nSum: 85\nMean: 10.625\nMaximum: 20\nMinimum: 3\nStandard deviation: 4.871793817476269",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements\n\n\nnumbers = np.array([5, 2, 8, 1, 9, 3])\nprint(\"Original numbers:\", numbers)\nprint(\"Sorted array:\", np.sort(numbers))\nprint(\"Cumulative sum:\", np.cumsum(numbers))\n\nwith_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1])\nprint(\"Array with duplicates:\", with_duplicates)\nprint(\"Unique elements:\", np.unique(with_duplicates))\n\nOriginal numbers: [5 2 8 1 9 3]\nSorted array: [1 2 3 5 8 9]\nCumulative sum: [ 5  7 15 16 25 28]\nArray with duplicates: [5 2 8 1 9 3 5 2 1]\nUnique elements: [1 2 3 5 8 9]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results.\n\n\n# Mixed data types\nmixed_list = [1, 'hello', 3.14, True]\nprint(\"Mixed list:\", mixed_list)\n\nmixed_array = np.array(mixed_list)\nprint(\"NumPy array from mixed list:\", mixed_array)\nprint(\"Array dtype:\", mixed_array.dtype)\nprint(\"# NumPy converted everything to strings (the most general type)\")\n\n# List multiplication vs NumPy\nnum_list = [1, 2, 3, 4, 5]\nprint(\"\\nNumeric list:\", num_list)\nprint(\"List * 2:\", num_list * 2)\nprint(\"# List multiplication repeats the entire list\")\n\nnum_array = np.array([1, 2, 3, 4, 5])\nprint(\"NumPy array:\", num_array)\nprint(\"Array * 2:\", num_array * 2)\nprint(\"# NumPy multiplication is element-wise\")\n\nMixed list: [1, 'hello', 3.14, True]\nNumPy array from mixed list: ['1' 'hello' '3.14' 'True']\nArray dtype: &lt;U32\n# NumPy converted everything to strings (the most general type)\n\nNumeric list: [1, 2, 3, 4, 5]\nList * 2: [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]\n# List multiplication repeats the entire list\nNumPy array: [1 2 3 4 5]\nArray * 2: [ 2  4  6  8 10]\n# NumPy multiplication is element-wise",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is\n\n\nimport time\n\nnum_range = 50000\ntest_array = np.arange(num_range)\n\n# List comprehension timing\ntime1 = time.time()\nlist_squared = [x**2 for x in test_array]\ntime2 = time.time()\nlist_time = time2 - time1\n\n# NumPy operation timing\ntime1 = time.time()\narr_squared = test_array**2\ntime2 = time.time()\narr_time = time2 - time1\n\nprint(f\"List comprehension time: {list_time:.6f} seconds\")\nprint(f\"NumPy operation time: {arr_time:.6f} seconds\")\n\nif arr_time &gt; 0:\n    print(f\"NumPy is {list_time/arr_time:.1f} times faster\")\nelse:\n    print(\"NumPy operation was too fast to measure accurately\")\n\nList comprehension time: 0.002060 seconds\nNumPy operation time: 0.000089 seconds\nNumPy is 23.2 times faster",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180])\n\nConvert these angles to radians (hint: multiply by π/180, use np.pi)\nCalculate the sine and cosine of each angle\nVerify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos())\nPrint all results\n\n\nangles_deg = np.array([0, 30, 45, 60, 90, 120, 180])\nprint(\"Angles in degrees:\", angles_deg)\n\n# Convert to radians\nangles_rad = angles_deg * np.pi / 180\nprint(\"Angles in radians:\", angles_rad)\n\n# Calculate sine and cosine\nsin_values = np.sin(angles_rad)\ncos_values = np.cos(angles_rad)\nprint(\"Sine values:\", sin_values)\nprint(\"Cosine values:\", cos_values)\n\n# Verify sin²(x) + cos²(x) = 1\nverification = sin_values**2 + cos_values**2\nprint(\"sin²(x) + cos²(x):\", verification)\nprint(\"All close to 1?\", np.allclose(verification, 1))\n\nAngles in degrees: [  0  30  45  60  90 120 180]\nAngles in radians: [0.         0.52359878 0.78539816 1.04719755 1.57079633 2.0943951\n 3.14159265]\nSine values: [0.00000000e+00 5.00000000e-01 7.07106781e-01 8.66025404e-01\n 1.00000000e+00 8.66025404e-01 1.22464680e-16]\nCosine values: [ 1.00000000e+00  8.66025404e-01  7.07106781e-01  5.00000000e-01\n  6.12323400e-17 -5.00000000e-01 -1.00000000e+00]\nsin²(x) + cos²(x): [1. 1. 1. 1. 1. 1. 1.]\nAll close to 1? True\n\n\n\n# Additional verification - showing the identity holds for each angle\nfor i, angle in enumerate(angles_deg):\n    identity_value = sin_values[i]**2 + cos_values[i]**2\n    print(f\"{angle}°: sin²({angle}) + cos²({angle}) = {identity_value:.10f}\")\n\n0°: sin²(0) + cos²(0) = 1.0000000000\n30°: sin²(30) + cos²(30) = 1.0000000000\n45°: sin²(45) + cos²(45) = 1.0000000000\n60°: sin²(60) + cos²(60) = 1.0000000000\n90°: sin²(90) + cos²(90) = 1.0000000000\n120°: sin²(120) + cos²(120) = 1.0000000000\n180°: sin²(180) + cos²(180) = 1.0000000000",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "href": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge Exercise: Temperature Conversion",
    "text": "Challenge Exercise: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale\n\n\ncelsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\nprint(\"Celsius temperatures:\", celsius_temps)\n\n# Convert to Fahrenheit\nfahrenheit_temps = (celsius_temps * 9/5) + 32\nprint(\"Fahrenheit temperatures:\", fahrenheit_temps)\n\n# Convert to Kelvin\nkelvin_temps = celsius_temps + 273.15\nprint(\"Kelvin temperatures:\", kelvin_temps)\n\n# Calculate temperature ranges\ncelsius_range = np.max(celsius_temps) - np.min(celsius_temps)\nfahrenheit_range = np.max(fahrenheit_temps) - np.min(fahrenheit_temps)\nkelvin_range = np.max(kelvin_temps) - np.min(kelvin_temps)\n\nprint(f\"\\nTemperature ranges:\")\nprint(f\"Celsius: {celsius_range}°C\")\nprint(f\"Fahrenheit: {fahrenheit_range}°F\") \nprint(f\"Kelvin: {kelvin_range}K\")\n\n# Note: The range in Celsius and Kelvin is the same because it's just a shift\n# The range in Fahrenheit is larger due to the scaling factor (9/5)\n\nCelsius temperatures: [ 0 10 20 25 30 35 40]\nFahrenheit temperatures: [ 32.  50.  68.  77.  86.  95. 104.]\nKelvin temperatures: [273.15 283.15 293.15 298.15 303.15 308.15 313.15]\n\nTemperature ranges:\nCelsius: 40°C\nFahrenheit: 72.0°F\nKelvin: 40.0K\n\n\n## Challenge 2: Kinetic energy\n\n**Task** Given arrays of mass (kg) and velocity (m/s) for several objects:\n```python\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n```\n\n1. Calculate the kinetic energy $K$ for each object using the formula: \n\n$$K =  \\dfrac{1}{2}m v^2$$\n\n2. Calculate the total kinetic energy of the system (sum of all objects)\n\nimport numpy as np\n\nmasses = np.array([2.0, 1.5, 3.0, 0.5])       # kg\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # m/s\n\n# 1. Kinetic energy for each object\nkinetic_energy = 0.5 * masses * velocities**2\nprint(\"Kinetic energy of each object:\", kinetic_energy)\n\n# 2. Total kinetic energy of the system\ntotal_ke = np.sum(kinetic_energy)\nprint(\"Total kinetic energy:\", total_ke)\n\nKinetic energy of each object: [100.   300.   337.5    6.25]\nTotal kinetic energy: 743.75",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature.\n\n\nimport numpy as np\n\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\n\n# 1. Top 3 hottest days\ntop3_indices = np.argsort(temperatures)[-3:][::-1]\ntop3_temps = temperatures[top3_indices]\nprint(\"Top 3 hottest days (indices and temperatures):\", list(zip(top3_indices, top3_temps)))\n\n# 2. Day-to-day percentage change\npct_change = (temperatures[1:] - temperatures[:-1]) / temperatures[:-1] * 100\nprint(\"Day-to-day percentage change:\", pct_change)\n\nTop 3 hottest days (indices and temperatures): [(26, 27.7), (21, 27.6), (16, 27.5)]\nDay-to-day percentage change: [  2.12765957 -11.66666667  20.75471698 -10.9375       4.8245614\n   9.20502092   4.59770115 -20.51282051   3.68663594   9.33333333\n   4.87804878 -18.99224806   6.69856459  10.76233184   5.26315789\n   5.76923077 -23.63636364   9.04761905   8.29694323   4.43548387\n   6.56370656 -24.63768116   9.13461538   7.92951542   6.93877551\n   5.72519084 -25.99277978  10.24390244  10.17699115]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#aims",
    "href": "slides/07_intro_numpy_slides.html#aims",
    "title": "The numpy module",
    "section": "Aims",
    "text": "Aims\nBy the end of this lecture, you will be able to:\n\nExplain what the NumPy module is and why it is used\nCreate and manipulate NumPy arrays\nPerform element-wise operations and mathematical functions on arrays\nCompare NumPy arrays with Python lists in terms of performance and functionality\nUse basic aggregation and array manipulation functions in NumPy"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "href": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "title": "The numpy module",
    "section": "What is numpy?",
    "text": "What is numpy?\nNumPy is a Python library that makes working with numbers and large collections of data fast and easy.\n\nComplete description at https://numpy.orgIt provides special array objects and tools for doing math efficiently, which is useful for data analysis and scientific computing.\n\nIt is imported in your session using the following command\nimport numpy\n\n\nWe will follow a common practice and use a shorthand with the as syntax\nimport numpy as np\n\n\nSo np will always mean numpy for us."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "title": "The numpy module",
    "section": "Arrays vs lists",
    "text": "Arrays vs lists\n\n\nPython Lists\n\nOrdered, Mutable\n\nMixed data types\nExplicit operations needed\nSlower performance\n\n\nNumPy Arrays\n\nOrdered, Mutable\nOne data type per array\nElement-wise operations\nFast & memory efficient\n\n\n\n\n\n\nlist_ex = [1, 2, 3, 4]\nprint(list_ex)\n\n[1, 2, 3, 4]\n\n\n\n\nimport numpy as np\n#notice that we explicitly call the np.array()\narr_ex = np.array([1, 2, 3, 4]) \nprint(arr_ex)\n\n[1 2 3 4]\n\n\n\nWe are going to see these differences in detail."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "title": "The numpy module",
    "section": "Arrays from lists",
    "text": "Arrays from lists\nA purely numerical list can readily be converted to an array.\n\nimport numpy as np\n# Create array from list\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\nprint(arr1)\n\n[1. 1. 2. 3. 5. 8.]\n\n\n\nThe type of the elements yields the data type of the array\n\nprint(arr1.dtype)\n\nfloat64\n\n\n\nTry and change the list1 object to contain only integers and see the change!"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#array-properties",
    "href": "slides/07_intro_numpy_slides.html#array-properties",
    "title": "The numpy module",
    "section": "Array properties",
    "text": "Array properties\nArrays possess plenty of properties.\nThese are accessed with the . notation1.\n\nprint(f\"Data type: {arr1.dtype}\")\nprint(f\"Shape: {arr1.shape}\")\nprint(f\"Shape: {arr1.size}\")\n\nData type: float64\nShape: (6,)\nShape: 6\n\n\nFor now, we consider only 1d arrays, i.e. sequences. Their length is is their size and corresponds to the first element of the property shape.\nuse . and then TAB to see all of the properties"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "href": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "title": "The numpy module",
    "section": "Accessing array elements",
    "text": "Accessing array elements\nSimilarly to lists, we access an element in an array via zero-based indexing\n\nprint(arr1[0])    # First element\nprint(arr1[-1])   # Last element\n\n1.0\n8.0\n\n\nAgain, similarly to lists, we can access regions of the array via slicing\n\nprint(arr1[3:6])  # Elements from index 3 to 6\n\n[3. 5. 8.]"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe main motivation to use arrays is that lists are cumbersome when performing maths.\nSuppose we have a list and want to double all of its elements:\n\nlist1 = [1,2,3,4]\n\nWe need to loop over all of them and create a new list\n\nlist2 = []\nfor item in list1:\n    list2.append(2*item)\nprint(list2)\n\n[2, 4, 6, 8]\n\n\nIn fact, we can do this in a slightly more compact way using list comprehension\n\nlist2 = [item*2 for item in list1]\n\nStill, an explicit loop is needed. Loops in Python are slow."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe numpy syntax avoids the explicit Python loop.\n\narr1 = np.array(list1)\narr2 = 2*arr1\nprint(arr2)\n\n[2 4 6 8]\n\n\nThis is not just a cosmetic change: under the hood numpy uses an efficient architecture that performs operations in compiled code, making it much faster than Python loops."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#performance-advantage",
    "href": "slides/07_intro_numpy_slides.html#performance-advantage",
    "title": "The numpy module",
    "section": "Performance advantage",
    "text": "Performance advantage\nThis performance difference can be tracked explicitly.\nWe create a large list and a large array with identical content\n\n# Create a large list and array\nlarge_list = list(range(1_000_000))\nlarge_array = np.array(large_list)\n\nAnd then track the time for the two operations\n\nimport time\n#  Track the time taken for the list multiplication\nstart = time.time()\nlist_result = [x * 2 for x in large_list]\nend = time.time()\nprint(f\"List comprehension time: {end - start:.5f} seconds\")\n\n# Time array multiplication\nstart = time.time()\narray_result = large_array * 2\nend = time.time()\nprint(f\"NumPy array time: {end - start:.5f} seconds\")\n\nList comprehension time: 0.01995 seconds\nNumPy array time: 0.00118 seconds"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "href": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "title": "The numpy module",
    "section": "General mathematical functions",
    "text": "General mathematical functions\nThe multiplication we performed earlier is done element-wise: every element is update according to teh same rule.\nWe can apply plenty of element-wise operations to the arrays.\nMany of these are available as numpy functions directly accessed from the np. module\n\n# Element-wise functions\nprint(f\"Square root: {np.sqrt(arr1)}\")\nprint(f\"Mean: {np.mean(arr1)}\")\nprint(f\"Cosine: {np.cos(arr1)}\")\n\nSquare root: [1.         1.41421356 1.73205081 2.        ]\nMean: 2.5\nCosine: [ 0.54030231 -0.41614684 -0.9899925  -0.65364362]\n\n\n\nThe operations do not modify the original array, but produce new copies\n\narr2 = arr1*3/2 + 5\nprint(f\"Original: {arr1}\")\nprint(f\"Modified: {arr2}\")\n\nOriginal: [1 2 3 4]\nModified: [ 6.5  8.   9.5 11. ]"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums",
    "href": "slides/07_intro_numpy_slides.html#sums",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nOther convenent numpy functions allow you to accumulate values without loops.\nAssume we have an array \\(x\\)\n\nx = np.array([1,2,3,4,5,6,7,8])\n\nSums\n\\[\nS = \\sum_{i=1}^{n} x_i\n\\]\nIn NumPy, this is translated as:\n\nS = np.sum(x)\nprint(S)\n\n36"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums-1",
    "href": "slides/07_intro_numpy_slides.html#sums-1",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nCumulative sums\nA cumulative sum is a sequence where each element is the sum of all previous elements up to that position. \\[\ny_i = \\sum_{j=1}^{i} x_j\n\\]\nIn NumPy, this is translated as:\n\n y = np.cumsum(x)\n print(y)\n\n[ 1  3  6 10 15 21 28 36]"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "href": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "title": "The numpy module",
    "section": "Example: molecular masses",
    "text": "Example: molecular masses\nLet’s consider the formula for the molecular mass of a compound:\n\\[\nM = \\sum_{i=1}^{n} a_i m_i\n\\]\nwhere\n\n\\(a_i\\) is the number of atoms of element \\(i\\)\n\\(m_i\\) is the atomic mass of element \\(i\\)\n\n\nWith numpy, you can compute this as:\n\na = np.array([2, 1, 4])      # Number of atoms for each element\nm = np.array([12.01, 1.01, 16.00])  # Atomic masses (e.g., C, H, O)\nM = np.sum(a * m)\nprint(f\"Molecular mass: {M}\")\n\nMolecular mass: 89.03"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "href": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "title": "The numpy module",
    "section": "Operations between arrays",
    "text": "Operations between arrays\nYou can perform arithmetic operations directly between arrays of the same shape. Operations like addition, subtraction, multiplication, and division are applied element-wise.\nFor example:\nElement-wise operations:\n\nadded = arr1 + arr2\nmultiplied = arr1 * arr2\nprint(f\"Added: {added}\")\nprint(f\"Multiplied: {multiplied}\")\n\nAdded: [ 7.5 10.  12.5 15. ]\nMultiplied: [ 6.5 16.  28.5 44. ]\n\n\n\nNote: Arrays must have compatible shapes!\n\narr3 = np.array([1, 2, 3])\narr4 = np.array([4, 5])\nresult = arr3 + arr4\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[21], line 3\n      1 arr3 = np.array([1, 2, 3])\n      2 arr4 = np.array([4, 5])\n----&gt; 3 result = arr3 + arr4\n\nValueError: operands could not be broadcast together with shapes (3,) (2,)"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#combining-arrays",
    "href": "slides/07_intro_numpy_slides.html#combining-arrays",
    "title": "The numpy module",
    "section": "Combining arrays",
    "text": "Combining arrays\nWith lists, the + operator concatenated different lists. Since for arrays the sign + corresponds to true mathematical addition, a dedicated concatenation function exists:\n\ncombined = np.concatenate([arr1, arr2])\nprint(f\"Unique elements: {combined}\")\n\nUnique elements: [ 1.   2.   3.   4.   6.5  8.   9.5 11. ]\n\n\nMany other variations of concatenation exist. Consult the documentation."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#key-takeaways",
    "href": "slides/07_intro_numpy_slides.html#key-takeaways",
    "title": "The numpy module",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy arrays are optimized for numerical operations\nElement-wise operations work implicitly\nPerformance benefits for large datasets\nMathematical functions apply to entire arrays\nShape compatibility required for operations\nChoose the right tool for your task"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "href": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "title": "Multi-dimensional Arrays",
    "section": "NumPy Arrays Beyond 1D",
    "text": "NumPy Arrays Beyond 1D\nMulti-dimensional arrays enable representation of: - 2D: Grid/Matrix (rows × columns) - 3D: Cuboid/Tensor (depth × rows × columns) - nD: Higher dimensions\n\nimport numpy as np\nfrom numpy import random\nrng = random.default_rng(seed=24)\n\n# 2D array (3×3 matrix)\narray_2d = rng.random((3, 3))\nprint(f\"Shape: {array_2d.shape}\")\nprint(array_2d)\n\nShape: (3, 3)\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]\n [0.87411653 0.08643046 0.74247527]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Indexing Multi-dimensional Arrays",
    "text": "Indexing Multi-dimensional Arrays\nRow-major order: [row, column] (like [y, x])\n\n# Access single element\nprint(\"Element at [1,2]:\", array_2d[1, 2])\n\n# Access entire row\nprint(\"First row:\", array_2d[0, :])\n\n# Access entire column  \nprint(\"First column:\", array_2d[:, 0])\n\nElement at [1,2]: 0.5696873105084019\nFirst row: [0.33026884 0.40517732 0.57473782]\nFirst column: [0.33026884 0.50639977 0.87411653]\n\n\nSlicing works with multiple dimensions:\n\nprint(\"First 2 rows:\\n\", array_2d[:2])\n\nFirst 2 rows:\n [[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "href": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "title": "Multi-dimensional Arrays",
    "section": "Array Properties",
    "text": "Array Properties\n\n# Creating arrays with different shapes\nzeros_2d = np.zeros((2, 3))  # 2 rows, 3 columns\nrandom_3d = rng.integers(0, 3, size=(2, 3, 4))  # 2×3×4 tensor\n\nprint(\"2D shape:\", zeros_2d.shape)\nprint(\"3D shape:\", random_3d.shape)\nprint(\"3D rank/dimensions:\", random_3d.ndim)\n\n2D shape: (2, 3)\n3D shape: (2, 3, 4)\n3D rank/dimensions: 3\n\n\nTerminology: - Rank/ndim: Number of dimensions - Matrix: Rank 2 array - Tensor: Rank 3+ array"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "href": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "title": "Multi-dimensional Arrays",
    "section": "Operations Along Axes",
    "text": "Operations Along Axes\nAxis-specific operations:\n\nmatrix = rng.integers(0, 5, size=(3, 4))\nprint(\"Original matrix:\\n\", matrix)\n\nprint(\"Sum along axis 0 (columns):\", matrix.sum(axis=0))\nprint(\"Sum along axis 1 (rows):\", matrix.sum(axis=1))\nprint(\"Mean along axis 0:\", np.mean(matrix, axis=0))\n\nOriginal matrix:\n [[0 2 4 3]\n [4 1 4 0]\n [2 3 4 3]]\nSum along axis 0 (columns): [ 6  6 12  6]\nSum along axis 1 (rows): [ 9  9 12]\nMean along axis 0: [2. 2. 4. 2.]\n\n\nAxis 0: Operations across rows (result has column shape)\nAxis 1: Operations across columns (result has row shape)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "href": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "title": "Multi-dimensional Arrays",
    "section": "Reshaping and Flattening",
    "text": "Reshaping and Flattening\nReshape without changing data:\n\narr_1d = np.arange(12)\narr_2d = arr_1d.reshape((3, 4))\narr_3d = arr_1d.reshape((2, 2, 3))\n\nprint(\"1D:\", arr_1d)\nprint(\"2D (3×4):\\n\", arr_2d)\nprint(\"3D shape:\", arr_3d.shape)\n\n1D: [ 0  1  2  3  4  5  6  7  8  9 10 11]\n2D (3×4):\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]\n3D shape: (2, 2, 3)\n\n\nUsing -1 for automatic dimension:\n\n# -1 means \"figure out this dimension\"\nauto_reshape = arr_1d.reshape(-1, 4)  # ? rows, 4 columns\nprint(\"Auto-reshaped:\\n\", auto_reshape)\n\nAuto-reshaped:\n [[ 0  1  2  3]\n [ 4  5  6  7]\n [ 8  9 10 11]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Flattening Arrays",
    "text": "Flattening Arrays\nravel() - returns view (shares data):\n\nmatrix = rng.integers(0, 10, (2, 3))\nprint(\"Original:\\n\", matrix)\n\nview = matrix.ravel()\nview[0] = 99  # Changes original!\nprint(\"After modifying view:\\n\", matrix)\n\nOriginal:\n [[7 0 4]\n [4 7 4]]\nAfter modifying view:\n [[99  0  4]\n [ 4  7  4]]\n\n\nflatten() - returns copy:\n\nmatrix = rng.integers(0, 10, (2, 3))\ncopy = matrix.flatten()\ncopy[0] = 99  # Original unchanged\nprint(\"Original unchanged:\\n\", matrix)\n\nOriginal unchanged:\n [[6 9 5]\n [5 5 3]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "href": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "title": "Multi-dimensional Arrays",
    "section": "Broadcasting",
    "text": "Broadcasting\nCombine arrays of different shapes automatically:\n\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Vector is broadcast to each row\nresult = matrix + vector\nprint(\"Matrix + Vector:\\n\", result)\n\nMatrix + Vector:\n [[11 22 33]\n [14 25 36]]\n\n\nCreate grids with broadcasting:\n\nrow_vec = np.arange(3).reshape(1, -1)    # Shape: (1, 3)\ncol_vec = np.arange(3).reshape(-1, 1)    # Shape: (3, 1)\ngrid = row_vec + col_vec                 # Shape: (3, 3)\nprint(\"Broadcast grid:\\n\", grid)\n\nBroadcast grid:\n [[0 1 2]\n [1 2 3]\n [2 3 4]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra with NumPy",
    "text": "Linear Algebra with NumPy\nMatrix operations for solving systems: \\[A\\mathbf{x} = \\mathbf{b}\\]\n\n# System: 2x + 3y + z = 5, 4x - y = 1, 2y + z = 3\nA = np.array([[2, 3, 1], \n              [4, -1, 0], \n              [0, 2, 1]])\nb = np.array([[5], [1], [3]])\n\n# Solve the system\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x.flatten())\n\n# Verify: A @ x should equal b\nprint(\"Verification:\\n\", A @ x)\n\nSolution: [0.5 1.  1. ]\nVerification:\n [[5.]\n [1.]\n [3.]]"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra Operations",
    "text": "Linear Algebra Operations\n\n# Matrix multiplication with @\nresult = A @ x\n\n# Transpose with .T\nprint(\"b transpose:\", b.T)\n\n# Dot product\ndot_product = np.dot(b.T, b)\nprint(\"Dot product:\", dot_product)\n\n# Matrix inverse\nA_inv = np.linalg.inv(A)\nx_alt = A_inv @ b  # Alternative solution method\n\nb transpose: [[5 1 3]]\nDot product: [[35]]\n\n\nNumPy.linalg provides: inverse, solve, eigenvalues, SVD, etc."
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "href": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "title": "Multi-dimensional Arrays",
    "section": "Arrays as Images",
    "text": "Arrays as Images\nVisualize 2D arrays as images:\n\nimport matplotlib.pyplot as plt\n\n# Simple matrix visualization\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\nax1.matshow(matrix)\nax1.set_title('matshow')\n\nax2.imshow(matrix, origin='lower')\nax2.set_title('imshow (origin=lower)')\n\nText(0.5, 1.0, 'imshow (origin=lower)')"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "href": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "title": "Multi-dimensional Arrays",
    "section": "Working with Real Images",
    "text": "Working with Real Images\n\nfrom skimage import data\n\n# Grayscale image\ngray_image = data.camera()\nprint(\"Image shape:\", gray_image.shape)\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(gray_image, cmap='gray')\nax.set_title('Grayscale Image')\n\nImage shape: (512, 512)\n\n\nText(0.5, 1.0, 'Grayscale Image')\n\n\n\nImages are arrays: Each pixel is a number (intensity)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Color Images (3D Arrays)",
    "text": "Color Images (3D Arrays)\n\n# Color image has 3 channels: RGB\ncolor_image = data.chelsea()\nprint(\"Color image shape:\", color_image.shape)\n\nfig, axes = plt.subplots(1, 4, figsize=(15, 4))\n\naxes[0].imshow(color_image)\naxes[0].set_title('Full Color')\n\n# Individual color channels\nchannels = ['Reds', 'Greens', 'Blues']\ntitles = ['Red Channel', 'Green Channel', 'Blue Channel']\n\nfor i, (cmap, title) in enumerate(zip(channels, titles)):\n    axes[i+1].imshow(color_image[:, :, i], cmap=cmap)\n    axes[i+1].set_title(title)\n\nColor image shape: (300, 451, 3)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "href": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "title": "Multi-dimensional Arrays",
    "section": "Boolean Operations on Images",
    "text": "Boolean Operations on Images\n\n# Extract green channel\ngreen = color_image[:, :, 1]\n\n# Create binary mask\nthreshold_mask = green &gt; 120\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\nax1.imshow(green, cmap='Greens')\nax1.set_title('Green Channel')\n\nax2.imshow(threshold_mask, cmap='gray')\nax2.set_title('Thresholded (&gt;120)')\n\nText(0.5, 1.0, 'Thresholded (&gt;120)')\n\n\n\nLogical operations: & (AND), | (OR), ~ (NOT)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "href": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "title": "Multi-dimensional Arrays",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nMulti-dimensional arrays represent grids, images, tensors\nIndexing: [row, col] for 2D arrays\nAxis operations reduce along specific dimensions\nReshaping changes shape without changing data\nBroadcasting enables operations on different shapes\nLinear algebra operations available in np.linalg\nImages are just arrays of pixel values\nBoolean indexing works on multi-dimensional arrays"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "href": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Array Indexing & Slicing",
    "text": "Array Indexing & Slicing\n\nimport numpy as np\narr = np.array([10, 20, 30, 40, 50])\n\n# Integer indexing\nprint(\"Element at index 1:\", arr[1])\n\n# Basic slicing\nprint(\"Slice [1:4]:\", arr[1:4])\n\nElement at index 1: 20\nSlice [1:4]: [20 30 40]\n\n\nAdvanced slicing:\n\nprint(\"Every other element:\", arr[::2])\nprint(\"Last three elements:\", arr[-3:])\nprint(\"Reversed array:\", arr[::-1])\n\nEvery other element: [10 30 50]\nLast three elements: [30 40 50]\nReversed array: [50 40 30 20 10]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#views-vs-copies",
    "href": "slides/08_working_numpy_slides.html#views-vs-copies",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Views vs Copies",
    "text": "Views vs Copies\nSlicing creates views (shared data):\n\nslice_view = arr[2:5]\nslice_view[0] = 99\nprint(\"Original after view modification:\", arr)\n\nOriginal after view modification: [10 20 99 40 50]\n\n\nCreating independent copies:\n\narr = np.array([10, 20, 30, 40, 50])  # Reset\narr_copy = arr[2:5].copy()\narr_copy[0] = 100\nprint(\"Copy:\", arr_copy)\nprint(\"Original unchanged:\", arr)\n\nCopy: [100  40  50]\nOriginal unchanged: [10 20 30 40 50]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#boolean-indexing",
    "href": "slides/08_working_numpy_slides.html#boolean-indexing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nFilter data with conditions:\n\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\n\nbool_mask = arr &gt; threshold\nprint(\"Boolean mask:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\n\nBoolean mask: [False False False  True  True  True]\nFiltered values: [4 5 6]\n\n\nUsing np.where:\n\n# Get indices where condition is True\nindices = np.where(arr &gt; threshold)[0]\nprint(\"Indices:\", indices)\n\n# Conditional selection\nresult = np.where(arr &gt; 3, arr, 0)\nprint(\"Conditional result:\", result)\n\nIndices: [3 4 5]\nConditional result: [0 0 0 4 5 6]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#generating-sequences",
    "href": "slides/08_working_numpy_slides.html#generating-sequences",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Generating Sequences",
    "text": "Generating Sequences\nnp.arange - step-based:\n\nprint(\"Integers:\", np.arange(0, 10, 2))\nprint(\"Floats:\", np.arange(0.0, 1.0, 0.2))\n\nIntegers: [0 2 4 6 8]\nFloats: [0.  0.2 0.4 0.6 0.8]\n\n\nnp.linspace - count-based:\n\nprint(\"5 points from 0 to 1:\", np.linspace(0, 1, 5))\n\n5 points from 0 to 1: [0.   0.25 0.5  0.75 1.  ]\n\n\n\narange: Use when you know the step size\nlinspace: Use when you know the number of points"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#filled-arrays",
    "href": "slides/08_working_numpy_slides.html#filled-arrays",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Filled Arrays",
    "text": "Filled Arrays\n\n# Create arrays with specific values\nzeros_arr = np.zeros(5)\nones_arr = np.ones(4)\nfull_arr = np.full(3, 7)\n\nprint(\"Zeros:\", zeros_arr)\nprint(\"Ones:\", ones_arr)\nprint(\"Full:\", full_arr)\n\nZeros: [0. 0. 0. 0. 0.]\nOnes: [1. 1. 1. 1.]\nFull: [7 7 7]\n\n\nSame shape as existing array:\n\ntemplate = np.array([1, 2, 3])\nprint(\"Zeros like:\", np.zeros_like(template))\nprint(\"Ones like:\", np.ones_like(template))\nprint(\"Full like:\", np.full_like(template, 9))\n\nZeros like: [0 0 0]\nOnes like: [1 1 1]\nFull like: [9 9 9]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#random-number-generation",
    "href": "slides/08_working_numpy_slides.html#random-number-generation",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Random Number Generation",
    "text": "Random Number Generation\nInitialize generator (for reproducibility):\n\nrng = np.random.default_rng(seed=123)\n\nDifferent distributions:\n\n# Random integers\nprint(\"Random integers:\", rng.integers(0, 100, size=5))\n\n# Uniform floats [0, 1)\nprint(\"Uniform [0,1):\", rng.random(5))\n\n# Normal distribution\nnormal_samples = rng.normal(loc=0, scale=1, size=5)\nprint(\"Normal samples:\", normal_samples)\n\nRandom integers: [ 1 68 59  5 90]\nUniform [0,1): [0.18437181 0.1759059  0.81209451 0.923345   0.2765744 ]\nNormal samples: [-0.31659545 -0.32238912  0.09716732 -1.52593041  1.1921661 ]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "href": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Pseudo-Random Numbers",
    "text": "Pseudo-Random Numbers\nComputers are deterministic - they use algorithms to generate “pseudo-random” sequences\nLinear Congruential Generator example: \\[x_{n+1} = (a \\times x_n + c) \\bmod m\\]\nKey concept: Seeds enable reproducibility\n\n# Same seed = same sequence\nrng1 = np.random.default_rng(seed=42)\nrng2 = np.random.default_rng(seed=42)\n\nprint(\"RNG1:\", rng1.integers(0, 10, size=3))\nprint(\"RNG2:\", rng2.integers(0, 10, size=3))  # Same output!\n\nRNG1: [0 7 6]\nRNG2: [0 7 6]"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#performance-tips",
    "href": "slides/08_working_numpy_slides.html#performance-tips",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Performance Tips",
    "text": "Performance Tips\nPreallocate for efficiency:\n\n# Less efficient: generate one at a time\n# for _ in range(1000):\n#     val = rng.integers(0, 100)\n\n# More efficient: preallocate\nprealloc = rng.integers(0, 100, size=1000)\n# Then use values from prealloc array\n\nMemory vs Speed tradeoff: - Small tasks: 100-1,000 elements - Medium tasks: 10,000-100,000 elements\n- Large tasks: 1,000,000+ elements"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#key-takeaways",
    "href": "slides/08_working_numpy_slides.html#key-takeaways",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nViews share data, copies are independent\nBoolean indexing enables powerful data filtering\narange vs linspace serve different use cases\nRandom generators need seeds for reproducibility\nPreallocating arrays improves performance\nChoose array generation method based on your needs"
  },
  {
    "objectID": "10/exercises_part2_solutions.html",
    "href": "10/exercises_part2_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"ngc253_small.png\"\nim = np.array(Image.open(im_filename))\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\nprint(im.shape)\n\n(907, 1000, 3)\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im, origin=\"lower\")\n\n\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.\n\n\n\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\ndef inside_ellipse(x, y, centre=(0,0), a=2, b=1, alpha=0):\n    \n    x0,y0 = centre\n    \n    # Convert alpha in degrees to radians for use with cos/sin function\n    alpha_rad = np.radians(alpha)\n    \n    term1 = ((x-x0)*np.cos(alpha_rad) + (y-y0)*np.sin(alpha_rad))**2 / a**2\n    term2 = ((x-x0)*np.sin(alpha_rad) - (y-y0)*np.cos(alpha_rad))**2 / b**2\n    \n    total = term1 + term2\n\n    return total&lt;1\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\nx1 = 0\ny1 = 0\nposition_is_in_ellipse1 = inside_ellipse(x1, y1, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x1}, {y1}) inside the ellipse? {position_is_in_ellipse1}\")\n\nx2 = 0\ny2 = 4\nposition_is_in_ellipse2 = inside_ellipse(x2, y2, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x2}, {y2}) inside the ellipse? {position_is_in_ellipse2}\")\n\nIs position (0, 0) inside the ellipse? True\nIs position (0, 4) inside the ellipse? False\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n# ADD CODE HERE\nrows, cols = np.indices((im.shape[0], im.shape[1]))\ncentre = (500,470)\na = 365\nb = 70\nalpha = 33\nmask = inside_ellipse (cols, rows, centre, a, b , alpha)\n\nim_masked = im.copy()\nim_masked[np.logical_not(mask),:] = 0 # you can use ~ instead of the logical_not function\n\n\n# UNCOMMENT THIS CODE TO PLOT YOUR MASKED IMAGE\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int),origin=\"lower\")\n\n\n\n\n\n\n\n\n\n\n\n\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html\n\n# ADD CODE HERE\n\n# Select the third channel (B) and calculate the sum\nim_B_channel = im_masked[:, :, 2]\nsummed_B = np.sum(im_B_channel)\n\n# Apply the scale factor to get approximated flux value\nscale_factor = 2.8e-7\nflux_scaled_B = summed_B*scale_factor\n\n# Calculate the magnitude using the np.log10 function\nmagnitude_B = -2.5*np.log10(flux_scaled_B) + 8.90\nprint(magnitude_B)\n\n8.070961081466722",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "href": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"ngc253_small.png\"\nim = np.array(Image.open(im_filename))\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\nprint(im.shape)\n\n(907, 1000, 3)\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im, origin=\"lower\")\n\n\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "title": "Answers",
    "section": "",
    "text": "The inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\ndef inside_ellipse(x, y, centre=(0,0), a=2, b=1, alpha=0):\n    \n    x0,y0 = centre\n    \n    # Convert alpha in degrees to radians for use with cos/sin function\n    alpha_rad = np.radians(alpha)\n    \n    term1 = ((x-x0)*np.cos(alpha_rad) + (y-y0)*np.sin(alpha_rad))**2 / a**2\n    term2 = ((x-x0)*np.sin(alpha_rad) - (y-y0)*np.cos(alpha_rad))**2 / b**2\n    \n    total = term1 + term2\n\n    return total&lt;1\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\nx1 = 0\ny1 = 0\nposition_is_in_ellipse1 = inside_ellipse(x1, y1, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x1}, {y1}) inside the ellipse? {position_is_in_ellipse1}\")\n\nx2 = 0\ny2 = 4\nposition_is_in_ellipse2 = inside_ellipse(x2, y2, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x2}, {y2}) inside the ellipse? {position_is_in_ellipse2}\")\n\nIs position (0, 0) inside the ellipse? True\nIs position (0, 4) inside the ellipse? False\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n# ADD CODE HERE\nrows, cols = np.indices((im.shape[0], im.shape[1]))\ncentre = (500,470)\na = 365\nb = 70\nalpha = 33\nmask = inside_ellipse (cols, rows, centre, a, b , alpha)\n\nim_masked = im.copy()\nim_masked[np.logical_not(mask),:] = 0 # you can use ~ instead of the logical_not function\n\n\n# UNCOMMENT THIS CODE TO PLOT YOUR MASKED IMAGE\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int),origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "href": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "title": "Answers",
    "section": "",
    "text": "Now that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html\n\n# ADD CODE HERE\n\n# Select the third channel (B) and calculate the sum\nim_B_channel = im_masked[:, :, 2]\nsummed_B = np.sum(im_B_channel)\n\n# Apply the scale factor to get approximated flux value\nscale_factor = 2.8e-7\nflux_scaled_B = summed_B*scale_factor\n\n# Calculate the magnitude using the np.log10 function\nmagnitude_B = -2.5*np.log10(flux_scaled_B) + 8.90\nprint(magnitude_B)\n\n8.070961081466722",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 2"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html",
    "href": "10/lecture_multidimensionalArrays.html",
    "title": "Multi-dimensional arrays",
    "section": "",
    "text": "A numpy.ndarray is the more complete term for a numpy array object. Up until this point we have mainly been dealing with and using one dimensional arrays. Numpy arrays (unlike lists) have the concept of shape whicih means they can be multi-dimensional. This means they can represent a grid (2D), a cuboid (3D) and so forth.\nThe code below generates a numpy.array object containing random numbers. This is a 2D array with a 3 x 3 shape:\nfrom numpy import random\n\nrng = random.default_rng(seed=24)\nimport numpy as np\n\nshape = (3,3)\narray1 = rng.random(shape)\nprint(array1.shape)\nprint(array1)\n\n(3, 3)\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]\n [0.87411653 0.08643046 0.74247527]]\nWe can select one element from this array using the following syntax. We still use square brackets and pass an index value but now we can pass values for each dimension seperated by a comma (,). This index is selecting the third column within the second row:\nprint(array1[1, 2])\n\n0.5696873105084019\nUsing slicing (Start:Stop) syntax you can select an entire dimension at once by omitting both the Start and Stop values and just using :. You can see how this works if you try the slice with just the Start or just the Stop e.g.\nprint(array1[:2])\nprint(array1[2:])\n\n[[0.33026884 0.40517732 0.57473782]\n [0.50639977 0.56421251 0.56968731]]\n[[0.87411653 0.08643046 0.74247527]]\nNot including a Start index includes values from the beginning of the array/list etc. up to (but not including) the Stop.\nNot including a Stop index reads from the Start to the end of the array/list etc.\nSo just using : with no Start or Stop selects all elements for that dimension.\nThis following syntax returns first row (first row, every column):\nprint(array1[0,:])\n\n[0.33026884 0.40517732 0.57473782]\nAnd this would return the first column (every row, first column):\nprint(array1[:,0])\n\n[0.33026884 0.50639977 0.87411653]\nnumpy array objects store data in row-major order. Essentially this means for a 2D index this would be the equivalent of [y, x] rather than [x, y].",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "href": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "title": "Multi-dimensional arrays",
    "section": "Basic properties of multi-dimensional arrays",
    "text": "Basic properties of multi-dimensional arrays\n\nShape\nThe shape of a multi-dimensional array is a tuple that describes the size of each dimension. For example, a 2D array with 3 rows and 4 columns has a shape of (3, 4). You can access the shape of an array using the .shape attribute.\nWe can use many of the array initialisation functions we haver seen for 1d arrays also to create multi-dimensional arrays. For example, we can use np.zeros to create a 2D array of zeros, or np.ones to create a 2D array of ones. We can also use np.random.rand to create a 2D array of random numbers.\n\narray_of_zeros = np.zeros(shape=(2, 3)) # 2 rows, 3 columns\n\n\nnp.ones_like(array_of_zeros)\n\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\n\nAxis and Rank\nA multi-dimensional array has multiple dimensions, each of which can be thought of as an axis. The number of dimensions is called the rank of the array. For example, a 2D array has a rank of 2, while a 3D array has a rank of 3. It is accessible via the .ndim attribute.\nWe typically call a rank 2 array a matrix. A rank 3 array (or higher) is often called a tensor.\n\nrng = random.default_rng(seed=24)\nrandom_matrix = rng.uniform(-1,1,size=(2,5)) # random floats between -1 and 1, 2 rows, 5 columns\nrandom_matrix\n\narray([[-0.33946233, -0.18964537,  0.14947564,  0.01279953,  0.12842501],\n       [ 0.13937462,  0.74823306, -0.82713908,  0.48495054,  0.64073453]])\n\n\n\nrandom_matrix.ndim # two dimensions, rank 2, a matrix\n\n2\n\n\n\nrandom_tensor = rng.integers(0,3,size=(2,3,4)) # random integes in [0,3), 2x3x4 tensor\nrandom_tensor\n\narray([[[0, 2, 1, 1],\n        [2, 2, 0, 0],\n        [1, 2, 0, 1]],\n\n       [[2, 0, 1, 0],\n        [0, 1, 1, 0],\n        [0, 1, 0, 1]]])\n\n\n\nrandom_tensor.ndim\n\n3\n\n\nWe can perform operations along specific axes of a multi-dimensional array. For example, we can sum all the elements along a specific axis using the np.sum function with the axis parameter.\n\nsmall_matrix = rng.integers(0,2,size=(3,2)) \nsmall_matrix\n\narray([[1, 1],\n       [1, 0],\n       [1, 0]])\n\n\n\nsmall_matrix.sum(axis=0) # sum along the first axis (rows)\n\narray([3, 1])\n\n\n\nsmall_matrix.sum(axis=1) # sum along the second axis (columns), can you explain the resulting shape?\n\narray([2, 1, 1])\n\n\nOne can do the same also with useful statistical descriptors such as np.mean, np.std, etc.\n\nnp.mean(small_matrix, axis=0) # mean along the first axis (rows)\n\narray([1.        , 0.33333333])\n\n\n\n\nSlicing\nSlicing works similarly to 1D arrays, but you can slice along multiple axes. For example, you can slice a 2D array to get a submatrix or a specific row or column.\n\nsmall_matrix[:, 0] # all rows, first column\n\narray([1, 1, 1])\n\n\n\nsmall_matrix[:2,:] # first two rows, all columns\n\narray([[1, 1],\n       [1, 0]])\n\n\n\nsmall_matrix[::-1,:1]\n\narray([[1],\n       [1],\n       [1]])\n\n\n\n\nReshaping and flattening\nThe last example show an inetresting case: we extracted a single column from the matrix, but it is still a 2D array with shape (3, 1).\n\nselection = small_matrix[::-1,:1]\n\nprint(\"shape\", selection.shape)\nprint(\"rank\", selection.ndim)\n\nshape (3, 1)\nrank 2\n\n\nWhat if we wanted a truly 1d array (rank 1)? We need to reshape the array.\nWe can use the np.reshape function to change the shape of an array without changing its data. For example, we can reshape a 2D array into a 1D array or vice versa.\nReshape takes a tuple of the new shape as an argument. If you want to flatten an array (convert it to a 1D array), you can use -1 as one of the dimensions, which tells NumPy to infer the size of that dimension based on the total number of elements.\n\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape((3,))  # reshape to a 1D array excplicitly\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n\nreshaped shape (3,)\nreshaped rank 1\nreshaped selection [1 1 1]\n\n\n\n#same code as above, but with inferred shape\nselection = small_matrix[::-1,:1]\nreshaped_selection = selection.reshape(-1)  # infererd shape\nprint(\"reshaped shape\", reshaped_selection.shape)\nprint(\"reshaped rank\", reshaped_selection.ndim)\nprint(\"reshaped selection\", reshaped_selection)\n\nreshaped shape (3,)\nreshaped rank 1\nreshaped selection [1 1 1]\n\n\nAnother way to cast a multi-dimensional array to a 1D array is to use the np.ravel() function, which returns a flattened view of the array (not a copy).\n\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"Original matrix:\\n\", a_matrix)\nravelled_view = a_matrix.ravel()\nprint(\"Flattened view:\", ravelled_view)  # flatten the array to a 1D array\n\nOriginal matrix:\n [[4 7 8]\n [7 7 0]]\nFlattened view: [4 7 8 7 7 0]\n\n\nIf we modify the view, we modify the original array as well.\n\nravelled_view[0] = 100  # modify the view\nprint(\"Modified view:\", ravelled_view)  # the view is modified\nprint(\"Original array:\", a_matrix)  # the original array is modified as well\n\nModified view: [100   7   8   7   7   0]\nOriginal array: [[100   7   8]\n [  7   7   0]]\n\n\nTo obtain a completely independent flattened copy of the array, you can use the np.flatten() method, which returns a copy of the array in a 1D format.\n\na_matrix = rng.integers(0,10,size=(2,3)) # random integers in [0,10), 2x3 matrix\nprint(\"The original:\\n\",a_matrix)\nflattened_copy = a_matrix.flatten()\nprint(\"Flattened:\",flattened_copy)  # flatten the array to a 1D array\nflattened_copy[0] = 100  # modify the copy\nprint(\"Flattened after modification:\",flattened_copy)  # the copy is modified\nprint(\"The original:\\n\",a_matrix)  # the original array is not modified\n\nThe original:\n [[4 4 7]\n [4 6 9]]\nFlattened: [4 4 7 4 6 9]\nFlattened after modification: [100   4   7   4   6   9]\nThe original:\n [[4 4 7]\n [4 6 9]]\n\n\nWe can also do the opposite and increase the rank of an array by reshaping it. For example, we can reshape a 1D array into a 2D array with one column or one row.\n\none_dimensional_array = rng.integers(0,10,size=(5,))  # random integers in [0,10), 1D array\nprint(\"One-dimensional array:\", one_dimensional_array)\nreshaped_array = one_dimensional_array.reshape((5,1))  # reshape to a  2D array with one column\nprint(\"Reshaped array:\\n\", reshaped_array)\n\nOne-dimensional array: [5 5 5 3 2]\nReshaped array:\n [[5]\n [5]\n [5]\n [3]\n [2]]\n\n\n\n\nBroadcasting\nCombining arrays of different shapes is possible in NumPy using a feature called broadcasting. Broadcasting allows NumPy to perform operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one.\n\n# Minimal broadcasting example: rank 2 (matrix) with rank 1 (vector)\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Broadcasting addition: vector is added to each row of the matrix\nresult = matrix + vector\nprint(\"Matrix:\\n\", matrix)\nprint(\"Vector:\", vector)\nprint(\"Result of broadcasting:\\n\", result)\n\nMatrix:\n [[1 2 3]\n [4 5 6]]\nVector: [10 20 30]\nResult of broadcasting:\n [[11 22 33]\n [14 25 36]]\n\n\nYou can reshape a 1D array to a column or row vector and use broadcasting to expand it into a large table. For example, to create a table where each row is the original 1D array, or each column is the original array:\n\none_dimensional_array = np.linspace(1, 5, num=5)  # create a 1D array with 5 elements\nprint(\"One-dimensional array:\", one_dimensional_array)\n# Expand one_dimensional_array to a table with 5 rows and 5 columns\nrow_vector = one_dimensional_array.reshape(1, -1)  # shape (1, 5)\ncolumn_vector = one_dimensional_array.reshape(-1, 1)  # shape (5, 1)\n\n# Broadcasting to create a table\ntable = column_vector + row_vector\nprint(\"BroadcastedTable:\\n\",table)\n\nOne-dimensional array: [1. 2. 3. 4. 5.]\nBroadcastedTable:\n [[ 2.  3.  4.  5.  6.]\n [ 3.  4.  5.  6.  7.]\n [ 4.  5.  6.  7.  8.]\n [ 5.  6.  7.  8.  9.]\n [ 6.  7.  8.  9. 10.]]",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "href": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "title": "Multi-dimensional arrays",
    "section": "Two-dimensional arrays as matrices: some linear algebra",
    "text": "Two-dimensional arrays as matrices: some linear algebra\nTwo-dimensional arrays are often used to represent matrices or images. In a matrix, each element can be accessed using two indices: - one for the row - one for the column.\nA matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns and is an essential concept in linear algebra.\nFor examplle, let’s consider the simple system of simultaneous equations:\n\\[ \\begin{align*}\n2x + 3y +z &= 5 \\\\\n4x - y &= 1 \\\\\n2y +z &= 3\n\\end{align*} \\]\nThis can be represented in matrix form as: \\[ \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nAnd if we call \\(A\\) the matrix of coefficients, \\(\\mathbf{x}\\) the vector of variables, and \\(b\\) the vector of constants, we can write this as: \\[ A \\mathbf{x} = \\mathbf{b} \\]\nwhere \\[A = \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\nx \\\\\ny\\\\\nz\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nA key result of linear algebra is that if \\(A\\) is invertible, we can solve for \\(\\mathbf{x}\\) by multiplying both sides of the equation by the inverse of \\(A\\): \\[ \\mathbf{x} = A^{-1} \\mathbf{b} \\]\nwhere \\(A^{-1}\\) is the inverse of matrix \\(A\\).\nNumPy has a dedicated linear algebra submodule called numpy.linalg that provides functions for performing various linear algebra operations, including matrix inversion, solving systems of equations, and computing eigenvalues and eigenvectors.\n\nA = np.array([[2, 3,1], [4, -1,0],[0,2,1]])\nb = np.array([[5], [1], [3]]) # we use double brackets to create a column vector\nprint(\"Matrix A:\\n\", A)\nprint(\"Vector b:\\n\", b)\n\nMatrix A:\n [[ 2  3  1]\n [ 4 -1  0]\n [ 0  2  1]]\nVector b:\n [[5]\n [1]\n [3]]\n\n\nThe linear algebra submodule has a function called solve which can be used to solve the above equation efficiently:\n\nx = np.linalg.solve(A, b)\n\nx\n\narray([[0.5],\n       [1. ],\n       [1. ]])\n\n\nBut we can use numpy to verify that this is correct. We can use the symbol @ to perform matrix multiplication in numpy.\n\nA @ x\n\narray([[5.],\n       [1.],\n       [3.]])\n\n\nWe can also directly calculate the inverse of a matrix using the inv function from the numpy.linalg and use it to solve the equation\n\nx = np.linalg.inv(A) @ b\n\nx\n\narray([[0.5],\n       [1. ],\n       [1. ]])\n\n\nAll the most common linear algebra operations are available in the numpy.linalg submodule:\n\ntranpose\n\n\nb.T\n\narray([[5, 1, 3]])\n\n\n\nscalar (dot) product (which takes two vectors and returns a scalar)\n\n\nnp.dot(b.T,b)\n\narray([[35]])\n\n\n\ncross product\n\n\nnp.cross(b.T, b.T) #takes row vectors and returns a row vector\n\narray([[0, 0, 0]])\n\n\nLinear algebra applications are beyond the scope of this course (so, there will be no assessment of these), but they are widely used in various fields such as physics, computer science, and engineering. For example, they are essential in computer graphics for transformations, in machine learning for optimization, and in physics for solving systems of equations. So it is important for you to know that all these can be implemented efficiently using numpy.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "href": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "title": "Multi-dimensional arrays",
    "section": "Matrices as images",
    "text": "Matrices as images\nA two-dimensional table of numbers can also be used to represent an image. Each number in the table corresponds to a pixel in the image, and the value of the number represents the color or intensity of that pixel.\nmatplotlib provides a convenient way to visualize 2D arrays as images. The matshow function can be used to display a 2D matrix as an image, where the values in the array are mapped to colors.\n\nimport matplotlib.pyplot as plt\nplt.matshow(A)\nplt.colorbar()\nprint(A)\n\n[[ 2  3  1]\n [ 4 -1  0]\n [ 0  2  1]]\n\n\n\n\n\n\n\n\n\nNotice that the indices of the y-axis increase as we go down. These are the indices of the rows in the matrix.\nFor a matrix of a given shape we can get the indices using the np.indices function, which returns a grid of indices for each dimension. This can be useful for creating masks or selecting specific regions of the matrix.\n\nrow_index, col_index = np.indices(A.shape)\nprint(\"Row indices:\\n\", row_index)\nprint(\"Column indices:\\n\", col_index)\n\nRow indices:\n [[0 0 0]\n [1 1 1]\n [2 2 2]]\nColumn indices:\n [[0 1 2]\n [0 1 2]\n [0 1 2]]\n\n\nAn alternative function is imshow, which is more general and can be used for both 2D arrays and images.\nHere we can set the origin of the axis:\n\nplt.imshow(A, origin='lower')  # origin='lower' to set the origin at the bottom left\n\n\n\n\n\n\n\n\n\nplt.imshow(A, origin='upper')  # origin=\"upper\" to set the origin at the top left\n\n\n\n\n\n\n\n\nThe main difference between matshow and imshow is that matshow is specifically designed for displaying matrices, while imshow is more general and can be used for both 2D arrays and images. matshow automatically adjusts the aspect ratio to make the matrix square, while imshow does not. Also the interpolation method used by matshow is different from that used by imshow, which can affect the appearance of the image.\nImages are represneted as 3d arays: every entry is a the intensity of a pixel (if the image is grayscale) or the intensity of a colour (e.g. red, green or blue) if the image is in colour.\n\nfrom skimage import data # importing images from a popular image library\n\nimage = data.camera() # a grayscale image\n\nplt.imshow(image, cmap='gray')  # display the image in grayscale\nplt.colorbar()\n\n\n\n\n\n\n\n\nLet’s take a colour image\n\ncolor_image = data.chelsea()\nplt.imshow(color_image)  # display the color image\n\n\n\n\n\n\n\n\nThis is no longer just a 2d array, it has a third dimension for the colour channels (red, green, blue). We can access the individual colour channels by slicing the array along the third dimension.\n\ncolor_image.shape\n\n(300, 451, 3)\n\n\nWe can slice the array to get the various channels (notice that we specify the colormap cmap argument to display the channels in the appropriate colour):\n\nfig,ax = plt.subplots(1, 3, figsize=(15, 5))  # create a figure with 3 subplots\nax[0].imshow(color_image[:, :, 0], cmap='Reds')  # display the red channel\nax[0].set_title('Red Channel')\nax[1].imshow(color_image[:, :, 1], cmap='Greens')  # display the green channel\nax[1].set_title('Green Channel')\nax[2].imshow(color_image[:, :, 2], cmap='Blues')  # display the blue channel\nax[2].set_title('Blue Channel')\n\nText(0.5, 1.0, 'Blue Channel')\n\n\n\n\n\n\n\n\n\nIf we want to subsample regions of an image, we can simply slice the array further in its rows and columns.\n\nplt.imshow(color_image[100:250, 100:, 1], cmap='Greens')  # display the green channel\n\n\n\n\n\n\n\n\nWe can also use boolean indexing to filter the image based on conditions.\nFor example, we can binarise it by applying a threshold\n\ngreen = color_image[:,:,1]\n\nplt.imshow(green&gt;100, cmap='gray')  # display a binary image where pixels with green channel value &gt; 100 are white\n\n\n\n\n\n\n\n\nWe can even perform logical operations using numpy\n\nAND with &\nOR with |\nNOT with ~ or np.logical_not\n\n\ngreen = color_image[:,:,1]\nred = color_image[:,:,0]\nplt.imshow( (green&gt;120) & (red&gt;120) , cmap='gray')\n\n\n\n\n\n\n\n\n\nplt.imshow(np.logical_not(green&gt;100), cmap='gray')",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#pair-programming",
    "href": "10/lecture_multidimensionalArrays.html#pair-programming",
    "title": "Multi-dimensional arrays",
    "section": "Pair programming",
    "text": "Pair programming\nThe following exercise will allow you explore multi-dimensional arrays by working in pairs. One person will write the code, while the other will explain what the code does. You can switch roles after each exercise.\nThere are two parts so, you can switch roles after each part.\n\nPart1\nPart2",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/exercises_part2.html",
    "href": "10/exercises_part2.html",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#pair-programming-part-2",
    "href": "10/exercises_part2.html#pair-programming-part-2",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#masking-a-galaxy",
    "href": "10/exercises_part2.html#masking-a-galaxy",
    "title": "Using a mask",
    "section": "Masking a galaxy",
    "text": "Masking a galaxy\nOne application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"ngc253_small.png\"\nim = np.array(Image.open(im_filename))\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\nprint(im.shape)\n\n(907, 1000, 3)\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im, origin=\"lower\")\n\n\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2.html#creating-an-elliptical-mask",
    "title": "Using a mask",
    "section": "Creating an elliptical mask",
    "text": "Creating an elliptical mask\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\ndef inside_ellipse(x, y, centre=(0,0), a=2, b=1, alpha=0):\n    \n    x0,y0 = centre\n    \n    # Convert alpha in degrees to radians for use with cos/sin function\n    alpha_rad = np.radians(alpha)\n    \n    term1 = ((x-x0)*np.cos(alpha_rad) + (y-y0)*np.sin(alpha_rad))**2 / a**2\n    term2 = ((x-x0)*np.sin(alpha_rad) - (y-y0)*np.cos(alpha_rad))**2 / b**2\n    \n    total = term1 + term2\n\n    return total&lt;1\n\n\nEquations for an ellipse\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\nx1 = 0\ny1 = 0\nposition_is_in_ellipse1 = inside_ellipse(x1, y1, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x1}, {y1}) inside the ellipse? {position_is_in_ellipse1}\")\n\nx2 = 0\ny2 = 4\nposition_is_in_ellipse2 = inside_ellipse(x2, y2, centre=(0, 0), a=2, b=1, alpha=0)\nprint(f\"Is position ({x2}, {y2}) inside the ellipse? {position_is_in_ellipse2}\")\n\nIs position (0, 0) inside the ellipse? True\nIs position (0, 4) inside the ellipse? False\n\n\n\n\n\nExercise B\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n# ADD CODE HERE\n\n\n# ADD CODE HERE\n\n\n# UNCOMMENT THIS CODE TO PLOT YOUR MASKED IMAGE\n\n#import matplotlib.pyplot as plt\n#\n#fig, ax = plt.subplots(figsize=(8,8))\n#ax.imshow(im_masked.astype(int),origin=\"lower\")\n\nTake time to discuss this but if you are both really stuck, there is a hint notebook available which shows how you would apply a mask which includes a rectangle to an image.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#calculating-the-magnitude",
    "href": "10/exercises_part2.html#calculating-the-magnitude",
    "title": "Using a mask",
    "section": "Calculating the magnitude",
    "text": "Calculating the magnitude\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\nExercise C\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html\n\n# ADD CODE HERE",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/hint2_apply_mask.html",
    "href": "10/hint2_apply_mask.html",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "",
    "text": "Example: Applying a mask containing a rectangle to an image\nI have downloaded an online image of a house for this example (from Vector Stock). This image contains four different rooms and I want to use a rectangular mask so that only the office room is displayed. As described previously, we can open this image using a the Image sub-module of a module called pillow (imported as PIL) which understands how to read image files. We can then convert this input into a numpy array object.\nfrom PIL import Image\nimport numpy as np\n\nim_filename = \"images/image-house-vector-stock.jpg\"\nim = np.array(Image.open(im_filename))\nim is a three dimensional numpy array object - includes height, width and colour channel (R, G, B).\nshape = im.shape\nprint(shape)\n\n(780, 1000, 3)\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im)\nThe imshow function knows how to interpret this 3D shape to show a colour image.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 2 - applying a rectangular mask"
    ]
  },
  {
    "objectID": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "href": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Create a rectanglar mask using a function",
    "text": "Create a rectanglar mask using a function\nI can define an function called inside_rectangle() to tell me whether a given (x, y) position is within a rectangle for a set of parameters. This will return True if the position is inside the rectangle and False otherwise.\nThe rectangle can be evaluated using the conditions:\n\\[|x - x_0| = w/2\\] and \\[|y - y_0| = h/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the rectangle - \\(w\\), \\(h\\) - are the full width and height of the rectangle - \\(| |\\) means the magnitude of the difference\n\ndef inside_rectangle(x,y,centre=(0,0),width=20,height=10):\n    \n    x0 = centre[0]\n    y0 = centre[1]\n    \n    distance_x = np.abs(x - x0) # Magnitude of distance\n    distance_y = np.abs(y - y0) # Magnitude of distance\n    \n    # Check if (x, y) position is within the rectangle\n    if distance_x &lt; width/2 and distance_y &lt; height/2:\n        return True\n    else:\n        return False\n\nFor this mask, I want to define the parameters as follows:\n\n# Input parameters\ncentre = (382,320)\nwidth = 280\nheight = 218\n\nThe inside_rectangle function allows you to pass the parameters for your position and your rectangle and can tell you whether the position is within your rectangle (returns a True value) or not (returns a False value). For example if we had a position of (50, 50) we could use the function as follows:\n\nx = 50\ny = 50\n\nposition_is_in_rectangle = inside_rectangle(x, y, centre=centre, width=width, height=height)\n\nif position_is_in_rectangle:\n    print(f\"Position ({x}, {y}) is within the rectangle\")\nelse:\n    print(f\"Not within rectangle\")\n\nNot within rectangle\n\n\nHere we used the output of inside_rectangle as our condition directly (Python sees this if True or if False and follows the logic accordingly).\nWe can use the inside_rectangle() function to define our mask - looping over every element and checking the x, y position with the inside_rectangle() function with the appropriate parameters:\n\nncol = shape[0]\nnrow = shape[1]\n\n# Create array of zeros based on shape of input image - height x width\nrect_mask = np.zeros(shape[0:2],dtype=int)\n\nfor y in range(ncol): # iterate over first dimension\n    for x in range(nrow): # iterate over second dimension\n        # Check whether x, y position is within defined rectangle\n        position_is_in_rectangle = inside_rectangle(x, y, centre=centre, width=width, height=height)\n        if position_is_in_rectangle:\n            rect_mask[y, x] = 1\n\nprint(f\"Shape of mask: {rect_mask.shape}\")\n\nShape of mask: (780, 1000)\n\n\nAs before, we don’t need an else block here because the array we have defined already contains zeros.\nExtended: See alternative numpy method mask in Hint 1 notebook for a more efficient way to create a square mask. Could you extend this method to reproduce a rectangular mask (without the need for the inside_rectangle function)?",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 2 - applying a rectangular mask"
    ]
  },
  {
    "objectID": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "href": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Apply mask to the image",
    "text": "Apply mask to the image\nNow we have created rect_mask, we need to apply this to my image. We can do this by multiplying im by rect_mask and this will combine element-wise. This means that each pixel in the image will be multiplied by the corresponding value within the mask. Multipying by 0 will result in the output pixel also being 0 but multiplying by 1 will retain the original value in that pixel.\nFor creating the im_masked output there a few ways you could do this - the upshot is that you want to create an array of the right shape: - Create an empty array of the right shape - Create a new variable called im_masked which is a copy of the im using the copy() function (method)\nBecause im is a three dimensional array (height x weight x colour channel), one way to apply the mask is to do this for each of the three colours (R, G, B channels) separately.\n\n## Create an empty array of the right shape\nim_masked = np.empty(shape)\n## OR make a copy and then apply mask\n#im_masked = im.copy()\n\n# Update the values within this array for each colour channel\nim_masked[:,:,0] = im[:,:,0]*rect_mask # shapes match (780, 1000) x (780, 1000)\nim_masked[:,:,1] = im[:,:,1]*rect_mask # shapes match (780, 1000) x (780, 1000)\nim_masked[:,:,2] = im[:,:,2]*rect_mask # shapes match (780, 1000) x (780, 1000)\n\n# # Another way to write this would be to add an extra dimension to our mask\n# # - This can be done using the np.newaxis constant to add an extra dimension\n# # - Numpy can then *broadcast* along this new dimension to combine correctly\n# im_masked = im*rect_mask[:,:,np.newaxis] # shapes (780, 1000, 3) x (780, 1000, 1)\n\nfig, ax = plt.subplots(figsize=(8,8))\nax.imshow(im_masked.astype(int))",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 2 - applying a rectangular mask"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html",
    "href": "11/lecture_beyond_the_notebook.html",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#our-file-system",
    "href": "11/lecture_beyond_the_notebook.html#our-file-system",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Pathway to the current directory",
    "text": "Pathway to the current directory\nFirst, let’s check where we are right now in the file system. To do so, we query the pathway to the working directory with the pwd command.\n\n! pwd\n\n/Users/ft14968/Repos/intro-coding-data-analysis/quarto/11\n\n\nThis shows where we currently are, and each of you should have a different path, with a different username.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Listing the content of the current directory",
    "text": "Listing the content of the current directory\nThe ls command lists the files and directories in the current directory. The current directory is represented by a . (dot).\n\n! ls \n\n\nexample.html\n\nexample.qmd\n\nexercises_numpy_riddles_solutions_files\n\nexercises_numpy_riddles_solutions.html\n\nexercises_numpy_riddles_solutions.qmd\n\nexercises_numpy_riddles.html\n\nexercises_numpy_riddles.qmd\n\nexercises_python_riddles_solutions.html\n\nexercises_python_riddles_solutions.qmd\n\nexercises_python_riddles.qmd\n\nlecture_beyond_the_notebook.qmd\n\nlecture_beyond_the_notebook.quarto_ipynb\n\nparabola.png\n\nsrc2",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "href": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "title": "Beyond the notebook",
    "section": "Creating a new directory",
    "text": "Creating a new directory\nThe mkdir command creates a new directory in the specified path. For example, to create a new directory in the current directory we can write\n\n! mkdir new_directory \n\nWe can check its existence with ls.\n\n! ls\n\n\nexample.html\n\nexample.qmd\n\nexercises_numpy_riddles_solutions_files\n\nexercises_numpy_riddles_solutions.html\n\nexercises_numpy_riddles_solutions.qmd\n\nexercises_numpy_riddles.html\n\nexercises_numpy_riddles.qmd\n\nexercises_python_riddles_solutions.html\n\nexercises_python_riddles_solutions.qmd\n\nexercises_python_riddles.qmd\n\nlecture_beyond_the_notebook.qmd\n\nlecture_beyond_the_notebook.quarto_ipynb\n\nnew_directory\n\nparabola.png\n\nsrc2\n\n\n\n\nEqually, we can go back to the jupyter interface and see the new directory in the graphical user interface.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#changing-directory",
    "href": "11/lecture_beyond_the_notebook.html#changing-directory",
    "title": "Beyond the notebook",
    "section": "Changing directory",
    "text": "Changing directory\nIt is easy to change the current directory with the cd command. For example, to go to the new_directory with\n\n! cd new_directory\n\nAnd we we can go back to the previous directory with the cd command again using ..\n\n! cd ..",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "href": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "title": "Beyond the notebook",
    "section": "Creating an empty file",
    "text": "Creating an empty file\nThe touch command creates a new file in the specified path. For example, to create a new file in the current directory we can write\n\n! touch new_directory/new_file.txt\n\nWe can check its existence with ls.\n\n! ls new_directory\n\nnew_file.txt\n\n\nWe can open this file in the graphical user interface and edit the contents\n[follows demonstration in Noteable with dummy text in the file new_file.txt]",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "href": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "title": "Beyond the notebook",
    "section": "Viewing file content",
    "text": "Viewing file content\nThe cat command prints the content of a file. For example, to view the content of new_file.txt we can write\n\n! cat new_directory/new_file.txt \n\nSeveral other commands exist to display parts of files, such as head, tail etc. Try them if you like!",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise",
    "href": "11/lecture_beyond_the_notebook.html#exercise",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a new jupyter notebook using the graphical user interface.\nFrom the notebook, use the commands above to create:\n\na new directory called src\na new file inside the directory called naive_script.py\nopen it with double click for the files tab in jupyter and write a minimal code\n\nprint(\"Hello, World!\")\n\nsave the file\nuse the cat command from the notebook to view the content of naive_script.py",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "href": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "title": "Beyond the notebook",
    "section": "Running scripts: from the notebook",
    "text": "Running scripts: from the notebook\nFor the entire duration of this course, you have been running python codes by typing them inside the notebook cells and executing the code cells.\nThe notebooks are complex files, that contain a lot of information beyond your code: the markdown, images, and a lot of extra data (called metadata).\nA much more essential way to store python code is to use scripts. These are files with the .py extension, like your naive_script.py file. Inside a script you can only have\n\npython code\npython comments to the code (i.e. lines prepended by the #)\n\nThis means that the scripts are simple, portable pure text files containing instructions in the python language.\nCan we execute such instructions? Yes, we run a script in various way. A simple way is to do it directly from a code cell in the notebook. For this we use a special jupyter command called run followed by the path to the script.\n[check that you are in the correct path and the script exist]\n\nrun src/naive_script.py\n\n\n---------------------------------------------------------------------------\nOSError                                   Traceback (most recent call last)\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:727, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    726     fpath = arg_lst[0]\n--&gt; 727     filename = file_finder(fpath)\n    728 except IndexError as e:\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/utils/path.py:90, in get_py_filename(name)\n     89         return py_name\n---&gt; 90 raise IOError(\"File `%r` not found.\" % name)\n\nOSError: File `'src/naive_script.py'` not found.\n\nThe above exception was the direct cause of the following exception:\n\nException                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 get_ipython().run_line_magic('run', 'src/naive_script.py')\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/interactiveshell.py:2481, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2479     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2480 with self.builtin_trap:\n-&gt; 2481     result = fn(*args, **kwargs)\n   2483 # The code below prevents the output from being displayed\n   2484 # when using magics with decorator @output_can_be_silenced\n   2485 # when the last Python token in the expression is a ';'.\n   2486 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:738, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    736     if os.name == 'nt' and re.match(r\"^'.*'$\",fpath):\n    737         warn('For Windows, use double quotes to wrap a filename: %run \"mypath\\\\myfile.py\"')\n--&gt; 738     raise Exception(msg) from e\n    739 except TypeError:\n    740     if fpath in sys.meta_path:\n\nException: File `'src/naive_script.py'` not found.\n\n\n\nAs you can see, we have executed the instructions of the script and its textual output has been printed in the notebook. No variables are created during the process.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#the-terminal",
    "title": "Beyond the notebook",
    "section": "The Terminal",
    "text": "The Terminal\nAll the commands that we have seen above can be used in a pure-text environment called the terminal. The terminal is a text-based interface to an operating system (local or remote).\nYou do not use the mouse to perform actions. Instead, you write commands. These commands belong to the scripting language called bash (see here for more information). It is different from python, they can interact together in the notebook.\nYou can launch a terminal directly from Noteable by clicking on the New button, then selecting Terminal.\n\n\n\nimage.png",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-1",
    "href": "11/lecture_beyond_the_notebook.html#exercise-1",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nWe try to navigate folders from the terminal and create a file\nOpen the terminal and\n\nchange the directory to src (using cd)\ncreate a new file inside the directory called parabola.py (use touch)\ngo back to the Noteable file tab, refresh the web-page and open the parabola.py file\nopen it and write a minimal code to plot a parabola. For example:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\na = 1.\nb =1.\nc = 2\nxlo = 0\nxhi = 10\nnpoints = 100\nx = np.linspace(xlo, xhi, npoints)\ny = a*x**2 + b*x + c\nplt.plot(x,y)\nplt.savefig(\"parabola.png\")\n\n\nsave the file and go back to the Terminal tab\nuse the cat command to check the content",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "title": "Beyond the notebook",
    "section": "Exercise: Running scripts from the Terminal",
    "text": "Exercise: Running scripts from the Terminal\nWe have seen that we can run the scripts from the notebook using the run command. In a very similar way, we can run scripts from the terminal, just by using the python command followed by the path to the script.\nDo the following:\n\nfirst run the parabola script from the notebook using run: you should see the plot appear in the notebook.\nthen go back to the Terminal and run the parabola.py script using the python command followed by the path to the script: e.g. python src/parabola.py. Where is the output?\n\n\nrun src/parabola.py\n\n\n---------------------------------------------------------------------------\nOSError                                   Traceback (most recent call last)\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:727, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    726     fpath = arg_lst[0]\n--&gt; 727     filename = file_finder(fpath)\n    728 except IndexError as e:\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/utils/path.py:90, in get_py_filename(name)\n     89         return py_name\n---&gt; 90 raise IOError(\"File `%r` not found.\" % name)\n\nOSError: File `'src/parabola.py'` not found.\n\nThe above exception was the direct cause of the following exception:\n\nException                                 Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 get_ipython().run_line_magic('run', 'src/parabola.py')\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/interactiveshell.py:2481, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2479     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2480 with self.builtin_trap:\n-&gt; 2481     result = fn(*args, **kwargs)\n   2483 # The code below prevents the output from being displayed\n   2484 # when using magics with decorator @output_can_be_silenced\n   2485 # when the last Python token in the expression is a ';'.\n   2486 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:738, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    736     if os.name == 'nt' and re.match(r\"^'.*'$\",fpath):\n    737         warn('For Windows, use double quotes to wrap a filename: %run \"mypath\\\\myfile.py\"')\n--&gt; 738     raise Exception(msg) from e\n    739 except TypeError:\n    740     if fpath in sys.meta_path:\n\nException: File `'src/parabola.py'` not found.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#reusing-code",
    "href": "11/lecture_beyond_the_notebook.html#reusing-code",
    "title": "Beyond the notebook",
    "section": "Reusing code",
    "text": "Reusing code\nThe most useful feature of the scripts is that they can store code for future usage in an organized manner. We do not need to have all of our code in a single notebook: we can split the relvant bits, put them into scripts and use them again and again in different projects.\nWhat allows us to do this is the special python keywork import, that we have already used many times.\nLet’s move our working directory to src and try importing our parabola.py script\n\ncd src\n\n[Errno 2] No such file or directory: 'src'\n/Users/ft14968/Repos/intro-coding-data-analysis/quarto/11\n\n\nIn python we can only import .py files, so we drop the .py extension when importing.\n\nimport parabola\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 import parabola\n\nModuleNotFoundError: No module named 'parabola'\n\n\n\nNow the variables defined in parabola.py are available in our current notebook.\n\nprint(parabola.xhi)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 print(parabola.xhi)\n\nNameError: name 'parabola' is not defined\n\n\n\nCongratulations! You have written your first python module!",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-2",
    "href": "11/lecture_beyond_the_notebook.html#exercise-2",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\nThe module above is not very useful. A better way to reuse code is to encapsulate it in a **custom .\n\nModify your parabola.py script to create a function plot_parabola that takes a, b, c, xlo, xhi as parameters.\nThen, import your parabola module in the present notebook using the following line:\nimport parabola as pb\nCan you find a way to access your function plot_parabola from pb ?\nImprove your function to customize the appearence of the plot (adding custom labels, colors, linestyles) and use the function with such changes. Important you will need to restart the notebook for these to take effect, because a module is loaded only once.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "title": "Beyond the notebook",
    "section": "More exercises on the terminal",
    "text": "More exercises on the terminal\n\nMost commands in bash allow you to acces their documentation with &lt;name_of_the_command&gt; --help. Can you find out what the command mv does?\n\n\n##YOUR CODE HERE\n\n\nFind a way to rename your parabola.py script to geometry.py\n\n\n##YOUR CODE HERE\n\nMost commands in bash support options, using the dash - sytax. For example, ls -l will list the files in a long format. Can you use ls --help to find out what the -l option does\n\nls --help\n\nls: unrecognized option `--help'\nusage: ls [-@ABCFGHILOPRSTUWXabcdefghiklmnopqrstuvwxy1%,] [--color=when] [-D format] [file ...]\n\n\n\nCan you find an additional option for ls -l to fils files in reverse time order?\n\n\n##YOUR CODE HERE",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#riddles",
    "href": "11/lecture_beyond_the_notebook.html#riddles",
    "title": "Beyond the notebook",
    "section": "Riddles",
    "text": "Riddles\nTo revise the material from the previous lectures, we can try to solve some riddles.\nYou can find the exercises here below\n\nPython Riddles\nNumpy Riddles",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/exercises_numpy_riddles.html",
    "href": "11/exercises_numpy_riddles.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\nimport numpy as np\n\nDiagonal Sum: - Riddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal. - Example: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n## YOUR CODE HERE\n\nUnique Elements Count: - Riddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array. - Example: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n## YOUR CODE HERE\n\nRandom sample ands cumulative sum: - Riddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n## YOUR CODE HERE\n\nRolling Window: - Riddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size. - For example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nHint: you can use list comprehension and convert the final list to an array.\n\n## YOUR CODE HERE\n\nProduct of elements: - Riddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean. - Example: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n## YOUR CODE HERE\n\nVectorised calculations and visualisation: - Riddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatter() from matplotlib according to their radial coordinate: - use the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$. - use the hexadecimal colour \"ffe701\" for points furtehr away.\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")\n\n## YOUR CODE HERE",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Consolidation - `numpy` riddles"
    ]
  },
  {
    "objectID": "11/exercises_numpy_riddles_solutions.html",
    "href": "11/exercises_numpy_riddles_solutions.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\nimport numpy as np\n\nDiagonal Sum: - Riddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal. - Example: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n## YOUR CODE HERE\n\ndef diagonal_sum(seq):\n    arr = np.asarray(seq)\n    return np.diagonal(arr).sum()\n\ndiagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n15\n\n\nUnique Elements Count: - Riddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array. - Example: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n## YOUR CODE HERE\ndef unique_count(sequence):\n    return np.unique(sequence).size\n\nunique_count([1, 2, 3, 2, 4, 1, 5]) \n\n5\n\n\nRandom sample ands cumulative sum: - Riddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n## YOUR CODE HERE\n\nn_trials = 20\nrng = np.random.default_rng(1234)\nprint(\"The amount we have after every coin tossing is\", rng.choice([-1,1],n_trials).cumsum())\n\nThe amount we have after every coin tossing is [ 1  2  3  2  1  2  1  0 -1 -2 -1 -2 -1 -2 -1 -2 -1  0  1  0]\n\n\nRolling Window: - Riddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size. - For example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nHint: you can use list comprehension and convert the final list to an array.\n\n## YOUR CODE HERE\n\ndef rolling_window(seq,window):\n    arr = np.asarray(seq)\n    num_rows  = len(seq)- window + 1\n    return np.array([arr[i:i+window] for i in range(num_rows)])\n    \n\nrolling_window([1, 2, 3, 4, 5], 3)\n\narray([[1, 2, 3],\n       [2, 3, 4],\n       [3, 4, 5]])\n\n\nProduct of elements: - Riddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean. - Example: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n## YOUR CODE HERE\n\n\ndef geometric_mean(seq):\n    return np.sqrt(np.prod(seq))\n\n\ngeometric_mean([1, 2, 3, 4, 5])\n\n10.954451150103322\n\n\nVectorised calculations and visualisation: - Riddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatplotter() from matplotlibacoording to their radial coordinate: - use the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$. - use the hexadecimal colour \"ffe701\" for points furtehr away.\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")\n\n## YOUR CODE HERE\nnpoints = 100_000\ntheta = np.random.uniform(0, 2*np.pi, npoints)\nr = np.sqrt(np.random.uniform(0, 1, npoints))\nx = r * np.cos(theta)\ny = r * np.sin(theta)\n\ninside = r&lt;0.5\n\nimport matplotlib.pyplot as plt\n\nplt.plot(x[inside],y[inside],',',color=\"#76d6ff\")\nplt.plot(x[~inside],y[~inside],',',color=\"#ffe701\")\nplt.axis(\"equal\")\n\n(-1.0996463517906905,\n 1.0992516399542742,\n -1.0994327729527829,\n 1.098998268565109)",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Solutions - NumPy Riddles"
    ]
  },
  {
    "objectID": "11/exercises_python_riddles_solutions.html",
    "href": "11/exercises_python_riddles_solutions.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\nSum of Digits - Riddle: Write a function sum_digits(n) that takes an integer n and returns the sum of its digits. - Test it with the following test cases: sum_digits(145)--&gt;10 and sum_digits(102)--&gt;3\nHint: remember that you can convert an integer to a string with str(n) and a character c to integer with int(c).\n\ndef sum_digits(n):\n    return sum(int(c) for c in str(n))\n\nassert sum_digits(102)==3\nassert sum_digits(145)==10\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str.\n\n#YOUR CODE HERE\ndef is_palindrome(s):\n    if type(s) == str:\n        return s == s[::-1]\n    else:\n        print(\"Error: Input is not a string.\")\n        return\n\nassert is_palindrome(\"racecar\")==True\nassert is_palindrome(\"hello\")==False\n\nis_palindrome(3)\n\nError: Input is not a string.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Solutions - Python Riddles"
    ]
  },
  {
    "objectID": "11/example.html",
    "href": "11/example.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\n! mkdir src2\n\n\n! touch src2/naive_script.py\n\n\n! cat src2/naive_script.py\n\n\nrun src2/naive_script.py\n\n\npath = ! pwd\n\n\npath\n\n['/Users/ft14968/Repos/intro-coding-data-analysis/quarto/11']\n\n\n\nrun src2/parabola.py\n\n\n---------------------------------------------------------------------------\nOSError                                   Traceback (most recent call last)\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:727, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    726     fpath = arg_lst[0]\n--&gt; 727     filename = file_finder(fpath)\n    728 except IndexError as e:\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/utils/path.py:90, in get_py_filename(name)\n     89         return py_name\n---&gt; 90 raise IOError(\"File `%r` not found.\" % name)\n\nOSError: File `'src2/parabola.py'` not found.\n\nThe above exception was the direct cause of the following exception:\n\nException                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 get_ipython().run_line_magic('run', 'src2/parabola.py')\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/interactiveshell.py:2481, in InteractiveShell.run_line_magic(self, magic_name, line, _stack_depth)\n   2479     kwargs['local_ns'] = self.get_local_scope(stack_depth)\n   2480 with self.builtin_trap:\n-&gt; 2481     result = fn(*args, **kwargs)\n   2483 # The code below prevents the output from being displayed\n   2484 # when using magics with decorator @output_can_be_silenced\n   2485 # when the last Python token in the expression is a ';'.\n   2486 if getattr(fn, magic.MAGIC_OUTPUT_CAN_BE_SILENCED, False):\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/IPython/core/magics/execution.py:738, in ExecutionMagics.run(self, parameter_s, runner, file_finder)\n    736     if os.name == 'nt' and re.match(r\"^'.*'$\",fpath):\n    737         warn('For Windows, use double quotes to wrap a filename: %run \"mypath\\\\myfile.py\"')\n--&gt; 738     raise Exception(msg) from e\n    739 except TypeError:\n    740     if fpath in sys.meta_path:\n\nException: File `'src2/parabola.py'` not found.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "example.html"
    ]
  },
  {
    "objectID": "11/exercises_python_riddles.html",
    "href": "11/exercises_python_riddles.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\nSum of Digits - Riddle: Write a function sum_digits(n) that takes an integer n and returns the sum of its digits. - Test it with the following test cases: sum_digits(145)--&gt;10 and sum_digits(102)--&gt;3\nHint: remember that you can convert an integer to a string with str(n) and a character c to integer with int(c).\n\n# YOUR CODE HERE\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str.\n\n#YOUR CODE HERE",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Consolidation - `Python` riddles"
    ]
  },
  {
    "objectID": "10/exercises_part1.html",
    "href": "10/exercises_part1.html",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#pair-programming-part-1",
    "href": "10/exercises_part1.html#pair-programming-part-1",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#how-a-mask-could-be-used",
    "href": "10/exercises_part1.html#how-a-mask-could-be-used",
    "title": "Creating a mask containing a circle",
    "section": "How a mask could be used",
    "text": "How a mask could be used\nIn this workbook, we want you to create a mask. By this we mean a square (or rectangular) grid of zeros (0s) and ones (1s) with values of 1 in the positions you want to keep and values of 0 in the positions you don’t. This mask could then be applied to another image for example:\n \nWithin the mask the edge would look something like this:\n\nwhere the thin green line represents the edge of where the real circle would be.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#circle-within-a-square",
    "href": "10/exercises_part1.html#circle-within-a-square",
    "title": "Creating a mask containing a circle",
    "section": "Circle within a square",
    "text": "Circle within a square\nThe mask we want you to create should represent a circle (defined within the grid). The equation governing the edge of a circle is:\n\\[ (x-x_0)^2 + (y-y_0)^2 = r^2 \\]\nwhere\n\n\\(x\\), \\(y\\) are the x, y positions within the grid\n\\(x_0\\), \\(y_0\\) are the centre of the circle\n\\(r\\) is the radius\n\nFor example, for a circle with radius of 2 with a centre point of (4, 3), if we looked at position (5, 4), then this would be inside that circle since:\n\\[\\sqrt{((5 - 4)^2 + (4 - 3)^2)}\\] \\[ = \\sqrt{1^2 + 1^2} = \\sqrt{1 + 1} = \\sqrt{2} = 1.41\\]\nwhich is less than the radius of 2.\n\n\nExercise A\nCreate a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n# ADD CODE HERE\n\n\n### UNCOMMENT THIS CODE TO PLOT YOUR MASK WHEN COMPLETED\n#\n#import matplotlib.pyplot as plt\n#\n#fig, ax = plt.subplots(figsize=(6, 3.2))\n#\n#ax.set_title('Circular Mask')\n#ax.imshow(circular_mask,cmap=\"bone\",origin=\"lower\") # Setting colourmap (cmap) and the position of 0,0 (origin) on the plot\n\nTake time to discuss this but if you are really stuck, there is a hint notebook available which shows how you would create a mask for a square rather than a circle as an example of how you could approach this.\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\nMore complex:\n\nWhat are some other ways a mask could created using the features of numpy?\n\n\nLook other numpy (np) functions e.g.\n\nmeshgrid() - link (or ogrid() - link)\nwhere() - link functions.\n\nLook at the more complex ways that numpy.array objects can be indexed - indexing multi-dimensional arrays\nConsider how values can be assigned to whole sections of an array directly.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1_solutions.html",
    "href": "10/exercises_part1_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n# ADD CODE HERE\nimport numpy as np\n\nn  = 100\ncircular_mask = np.zeros((n,n))\nx0, y0 = 40,50\nradius = 10\nrows, cols = np.indices(circular_mask.shape)\n\ncircular_mask = ((rows-y0)**2+(cols-x0)**2)&lt;=radius**2\n\n\n### UNCOMMENT THIS CODE TO PLOT YOUR MASK WHEN COMPLETED\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Circular Mask')\nax.imshow(circular_mask,cmap=\"bone\",origin=\"lower\") # Setting colourmap (cmap) and the position of 0,0 (origin) on the plot\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\n\n# 10 by 20 rectangle from x0,y0\nLx = 10\nLy= 20\nmask = (rows-y0&gt;0) & (rows-y0&lt;Ly)  & (cols-x0&gt;0) & (cols-x0&lt;Lx)\nplt.imshow(mask,cmap=\"bone\",origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 1"
    ]
  },
  {
    "objectID": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "href": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n# ADD CODE HERE\nimport numpy as np\n\nn  = 100\ncircular_mask = np.zeros((n,n))\nx0, y0 = 40,50\nradius = 10\nrows, cols = np.indices(circular_mask.shape)\n\ncircular_mask = ((rows-y0)**2+(cols-x0)**2)&lt;=radius**2\n\n\n### UNCOMMENT THIS CODE TO PLOT YOUR MASK WHEN COMPLETED\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Circular Mask')\nax.imshow(circular_mask,cmap=\"bone\",origin=\"lower\") # Setting colourmap (cmap) and the position of 0,0 (origin) on the plot\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\n\n# 10 by 20 rectangle from x0,y0\nLx = 10\nLy= 20\nmask = (rows-y0&gt;0) & (rows-y0&lt;Ly)  & (cols-x0&gt;0) & (cols-x0&lt;Lx)\nplt.imshow(mask,cmap=\"bone\",origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Solutions - Part 1"
    ]
  },
  {
    "objectID": "10/hint1_mask.html",
    "href": "10/hint1_mask.html",
    "title": "Hint 1 - creating a square mask",
    "section": "",
    "text": "Example: Creating a 100 x 100 grid containing a square where the centre of that square is at (80, 40) and the width is 30.\nTo check whether an (x, y) position is within the square we want to define, we want to evaluate if these two conditions are both satisfied: \\[|x - x_0| = w/2\\] and \\[|y - y_0| = w/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the square - \\(w\\) - is both the full width and height of the square - \\(| |\\) means the magnitude of the difference\nThis code will show one way to create a mask which contains a square. This will take the most direct approach and evaluate every index in the 2D array one at a time.\n\nimport numpy as np\n\nshape = (100, 100)\n\nStart by creating an array of zeros for our overall grid:\n\nsquare_mask = np.zeros(shape)\nprint(square_mask)\n\n[[0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n ...\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]\n [0. 0. 0. ... 0. 0. 0.]]\n\n\nNext we can define the parameters we need for the square:\n\ncentre = (80, 40) # Centre (x, y)\nwidth = 30 # Width of square\n\nSo, to check whether a given position is within our mask (the square we are defining), we need to find a way to use our equations above and write them in code.\nWe’ve created a grid of size of 100 x 100 so, as an example, let’s use the position (50, 50) for our grid:\n\nx = 50\ny = 50\n\nx0 = centre[0] # Define central x position for the square\ny0 = centre[1] # Define central y position for the square\n\n# Edge of square\n# |x - x0| = width/2\n# |y - y0| = width/2\n\ndistance_x = np.abs(x - x0) # Magnitude of distance - x-x0\ndistance_y = np.abs(y - y0) # Magnitude of distance - y-y0\n\n# Use our conditions to check whether this (y, x) position is inside the square\nif distance_x &lt; width/2 and distance_y &lt; width/2:\n    print(\"Position is inside the mask\")\n    square_mask[y, x] = 1 # Using our index values, set to value within our array to 1 if this is inside the square\nelse:\n    print(\"Position is not inside the mask\")\n\nPosition is not inside the mask\n\n\nNow we can build this up to look at every element in the 2D array we have created and check whether this is inside the square (we will leave the value as 0) or outside the square (we will set the value to 1). To do this we can loop through every column and every row and check the result of our conditions:\n\nx0 = centre[0]\ny0 = centre[1]\n\nncol = shape[0]\nnrow = shape[1]\n\nfor y in range(nrow): # iterate over first dimension\n    for x in range(ncol): # iterate over second dimension\n        \n        distance_x = np.abs(x - x0) # Magnitude of distance\n        distance_y = np.abs(y - y0) # Magnitude of distance\n        \n        # Check whether each position is inside the square\n        if distance_x &lt; width/2 and distance_y &lt; width/2:\n            square_mask[y, x] = 1 # Set to 1 if inside the square\n\nWe don’t need an else block here because the array we have defined already contains zeros. This means if our conditin doesn’t match we don’t need to update the values within the array.\nWe could check where our mask has been set to 1 using the np.where function. For a two-dimensional array like square_mask, this will return two arrays containing the positions of the match - one for the first dimension and one for the second dimension.\nEach pair of values (one in the first array and one the second) represents a 2D position in our array:\n\n# Where have we created our mask in our overall grid\nnp.where(square_mask == 1)\n\n(array([26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n        26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27,\n        27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n        27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n        28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n        28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n        29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30,\n        30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n        30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31,\n        31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,\n        31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n        32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33,\n        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33,\n        33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34,\n        34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n        34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n        35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n        35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n        36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37,\n        37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n        37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n        38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n        38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,\n        39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40,\n        40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n        40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41,\n        41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,\n        41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,\n        42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,\n        43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n        43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44,\n        44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n        44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n        45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,\n        45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,\n        46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 47, 47, 47,\n        47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n        47, 47, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48,\n        48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n        48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n        49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50,\n        50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n        50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51,\n        51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,\n        51, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n        52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n        52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53,\n        53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54,\n        54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n        54, 54, 54, 54, 54, 54, 54, 54]),\n array([66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\n        83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\n        88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,\n        76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,\n        93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n        81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68,\n        69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\n        86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73,\n        74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\n        91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,\n        79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66,\n        67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n        84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71,\n        72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,\n        89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\n        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\n        82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69,\n        70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\n        87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74,\n        75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,\n        92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67,\n        68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\n        85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72,\n        73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n        90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,\n        78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,\n        66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\n        83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\n        88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,\n        76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92,\n        93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n        81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68,\n        69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,\n        86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73,\n        74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\n        91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,\n        79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66,\n        67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n        84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71,\n        72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,\n        89, 90, 91, 92, 93, 94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\n        77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\n        82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 66, 67, 68, 69,\n        70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\n        87, 88, 89, 90, 91, 92, 93, 94]))\n\n\nWe can look at this mask using matplotlib and a plotting option called imshow (documentation; example from image gallery):\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask')\nax.imshow(square_mask,cmap=\"bone\",origin=\"lower\")\n\n\n\n\n\n\n\n\nIn this plot, the white represents the values in the mask (values of 1) and the black represents the values outside the mask (values of 0).\n\n\nExtended: Leveraging numpy functionality\nAn alternative and more efficient way to do this would be to leverage the properties of numpy arrays and the available numpy functions and indexing.\nWe can start in the same way and create our array of zeros of the right shape\n\nsquare_mask_2 = np.zeros(shape)\n\nWe can represent the pixel position for our x and y dimensions using numbers for 0 to 99 (for x) and 0 to 99 (for y) since our shape is 100 x 100.\nWe can then create a pair of 2D grids, X and Y, to match to the shape of our mask using a function called np.meshgrid(). This stretches our x and y coordinate values to create our 2D numpy arrays.\n\n# Create arrays matching to our size along our x and y axes\nx = np.arange(shape[1])\ny = np.arange(shape[0])\n\nX, Y = np.meshgrid(x, y)\n\nprint(f\"X array: {X.shape}\")\nprint(X)\nprint(f\"Y array: {Y.shape}\")\nprint(Y)\n\nX array: (100, 100)\n[[ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]\n ...\n [ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]\n [ 0  1  2 ... 97 98 99]]\nY array: (100, 100)\n[[ 0  0  0 ...  0  0  0]\n [ 1  1  1 ...  1  1  1]\n [ 2  2  2 ...  2  2  2]\n ...\n [97 97 97 ... 97 97 97]\n [98 98 98 ... 98 98 98]\n [99 99 99 ... 99 99 99]]\n\n\nWe can find the positions where our conditions are met within our grid using the np.where() function. From here we can filter our mask using integer array indexing and change these values from 0 to 1 within our mask.\n\n# We can calculate the x and y distances for each value in our 2D grids\ndistance_x = np.abs(X - x0) # Magnitude of distance\ndistance_y = np.abs(Y - y0) # Magnitude of distance\n\n# We can use the numpy where function to find the positions where our conditions are matched\n# - to include multiple conditions we have included an & (known as a bitwise operator)\nindices = np.where((distance_x &lt; width/2) & (distance_y &lt; width/2))\n\n# And using these indices change the values to 1\nsquare_mask_2[indices] = 1\n\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(figsize=(6, 3.2))\n\nax.set_title('Square Mask (alternative method)')\nax.imshow(square_mask_2,cmap=\"bone\",origin=\"lower\")",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Hint 1 - creating a square mask"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This website contains comprehensive materials for learning coding and data analysis with Python, focusing on NumPy and Matplotlib.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#welcome-to-the-course",
    "href": "index.html#welcome-to-the-course",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This website contains comprehensive materials for learning coding and data analysis with Python, focusing on NumPy and Matplotlib.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#course-weeks",
    "href": "index.html#course-weeks",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Course Weeks",
    "text": "Course Weeks\n\nWeek 07: Introduction to NumPy\nLearn the fundamentals of NumPy, Python’s powerful numerical computing library.\n\nLecture: Introduction to NumPy\nExercises\nSolutions\n\n\n\nWeek 08: Working with NumPy\nDive deeper into NumPy’s capabilities and advanced features.\n\nLecture: Working with NumPy\nExercises\nSolutions\n\n\n\nWeek 09: Introduction to Matplotlib\nLearn data visualization with Matplotlib.\n\nLecture: Introduction to Matplotlib\nExercises: Plotting Data from Files\nSolutions\nFun with Matplotlib Decorations\n\n\n\nWeek 10: Multidimensional Arrays\nMaster multidimensional array operations and advanced NumPy techniques.\n\nLecture: Multidimensional Arrays\nExercises Part 1 | Solutions\nExercises Part 2 | Solutions\n\n\n\nWeek 11: Beyond the Notebook\nAdvanced topics and practical applications.\n\nLecture: Beyond the Notebook\nNumPy Riddles | Solutions\nPython Riddles | Solutions\nExample Notebook",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Getting Started",
    "text": "Getting Started\nNavigate through the course using the sidebar or the navigation menu above. Each Week builds upon the previous one, so it’s recommended to work through them in order.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Features",
    "text": "Features\n\nInteractive Jupyter notebooks\nStep-by-step exercises with solutions\nComprehensive coverage of NumPy and Matplotlib\nReal-world examples and applications",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "href": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "title": "Beyond the Notebook",
    "section": "File System Navigation",
    "text": "File System Navigation\nNotebooks exist in directories - we can navigate using bash commands\nKey commands (use ! prefix in notebooks):\n# Current directory location\n! pwd\n\n# List files and directories\n! ls\n\n# Create new directory\n! mkdir new_folder\n\n# Change directory\n! cd new_folder\n! cd ..  # Go back to parent directory"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#working-with-files",
    "href": "slides/11_beyond_notebook_slides.html#working-with-files",
    "title": "Beyond the Notebook",
    "section": "Working with Files",
    "text": "Working with Files\nCreating and viewing files:\n# Create empty file\n! touch filename.txt\n\n# View file contents\n! cat filename.txt\n\n# View first/last lines\n! head filename.txt\n! tail filename.txt\nFile system navigation: - . = current directory - .. = parent directory - Paths can be absolute (/full/path) or relative (folder/file)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "href": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "title": "Beyond the Notebook",
    "section": "Python Scripts vs Notebooks",
    "text": "Python Scripts vs Notebooks\nNotebooks (.ipynb): - Rich multimedia content - Markdown, images, metadata - Interactive development - Complex file format\nScripts (.py): - Pure Python code only - Comments with # - Simple text files - Portable and lightweight"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#running-scripts",
    "href": "slides/11_beyond_notebook_slides.html#running-scripts",
    "title": "Beyond the Notebook",
    "section": "Running Scripts",
    "text": "Running Scripts\nFrom notebook:\n# Using the 'run' magic command\nrun path/to/script.py\nFrom terminal:\n# Using python command\npython path/to/script.py\nExample script (hello.py):\nprint(\"Hello, World!\")\nx = 42\nprint(f\"The answer is {x}\")"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#the-terminal",
    "href": "slides/11_beyond_notebook_slides.html#the-terminal",
    "title": "Beyond the Notebook",
    "section": "The Terminal",
    "text": "The Terminal\nText-based interface to the operating system\nAccessing terminal: - In Noteable: New → Terminal - Pure command-line environment - No mouse interaction - Uses bash scripting language\nBasic terminal workflow: 1. Navigate to directory (cd) 2. Create/edit files (touch, text editor) 3. Run Python scripts (python script.py)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "href": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "title": "Beyond the Notebook",
    "section": "Creating Python Modules",
    "text": "Creating Python Modules\nScripts can be imported as modules:\nStep 1: Create math_utils.py:\ndef add_numbers(a, b):\n    return a + b\n\ndef square(x):\n    return x ** 2\n\nPI = 3.14159\nStep 2: Import and use:\nimport math_utils as mu\n\nresult = mu.add_numbers(5, 3)\narea = mu.PI * mu.square(radius)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "href": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "title": "Beyond the Notebook",
    "section": "Practical Example: Plotting Module",
    "text": "Practical Example: Plotting Module\nCreate plotting.py:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_parabola(a, b, c, xlo=0, xhi=10, npoints=100):\n    x = np.linspace(xlo, xhi, npoints)\n    y = a * x**2 + b * x + c\n    \n    plt.figure()\n    plt.plot(x, y, 'b-', linewidth=2)\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title(f'Parabola: y = {a}x² + {b}x + {c}')\n    plt.grid(True)\n    plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "href": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "title": "Beyond the Notebook",
    "section": "Using Custom Modules",
    "text": "Using Custom Modules\nImport your module:\nimport plotting as plt_mod\n\n# Use your custom function\nplt_mod.plot_parabola(a=1, b=-2, c=1)\nBenefits of modules: - Reusability: Use same code across projects - Organization: Separate concerns - Maintainability: Update code in one place - Collaboration: Share functionality"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "href": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "title": "Beyond the Notebook",
    "section": "Bash Command Options",
    "text": "Bash Command Options\nCommands often have options using - syntax:\n# List files in long format\nls -l\n\n# List files in reverse time order\nls -lt\n\n# Get help for any command\ncommand_name --help\nCommon file operations:\n# Move/rename files\nmv old_name.py new_name.py\n\n# Copy files\ncp source.py destination.py\n\n# Remove files (careful!)\nrm filename.py"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "href": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "title": "Beyond the Notebook",
    "section": "Script vs. Notebook Output",
    "text": "Script vs. Notebook Output\nNotebook execution: - Output appears inline - Variables remain in memory - Interactive environment\nScript execution: - Output goes to terminal/file - No persistent variables - One-time execution - For plots: use plt.savefig() instead of plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#best-practices",
    "href": "slides/11_beyond_notebook_slides.html#best-practices",
    "title": "Beyond the Notebook",
    "section": "Best Practices",
    "text": "Best Practices\nWhen to use scripts: - Reusable functions - Production code - Automated tasks - Sharing with others\nWhen to use notebooks: - Exploratory analysis - Documentation with results - Teaching/presentations - Prototyping\nModule organization: - Group related functions - Clear, descriptive names - Add docstrings to functions"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "href": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "title": "Beyond the Notebook",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nFile system navigation with bash commands\nScripts are portable, reusable Python code\nTerminal provides direct system access\nModules enable code organization and reuse\nChoose the right tool: notebooks for exploration, scripts for production\nPractice using both environments effectively\n\nNext steps: Start organizing your code into reusable modules!"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "href": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "title": "Plotting with matplotlib",
    "section": "Introduction to matplotlib",
    "text": "Introduction to matplotlib\nmatplotlib - Powerful Python library for creating visualizations\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nKey concepts: - Figure: The canvas - Axes: The x-y plotting area - Object-oriented approach (recommended)\n\nfig, ax = plt.subplots()  # Create figure and axes"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "href": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "title": "Plotting with matplotlib",
    "section": "Two Plotting Approaches",
    "text": "Two Plotting Approaches\nPyplot (MATLAB-style):\nplt.plot(x, y)  # Direct plotting\nObject-oriented (Recommended):\n\nfig, ax = plt.subplots()\nax.plot(x, y)  # Plot using axes object\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 2\n      1 fig, ax = plt.subplots()\n----&gt; 2 ax.plot(x, y)  # Plot using axes object\n\nNameError: name 'x' is not defined\n\n\n\n\nWhy object-oriented? - More explicit control - Better for complex plots - Modern best practice"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "href": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Basic Plot Types",
    "text": "Basic Plot Types\n\n# Sample data\nrng = np.random.default_rng(seed=124)\nx = np.arange(1, 20, 2)\ny1 = x**2\ny2 = x**2 + rng.normal(size=len(x))*50\n\nfig, ax = plt.subplots()\nax.plot(x, y1, label=\"Line plot\")        # Line plot\nax.scatter(x, y2, label=\"Scatter plot\")  # Scatter plot\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "href": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "title": "Plotting with matplotlib",
    "section": "Customizing Appearance",
    "text": "Customizing Appearance\n\nfig, ax = plt.subplots(figsize=(8, 4))\n\n# Styling options\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\", linewidth=2)\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n# Labels and limits\nax.set_xlabel(\"X values\")\nax.set_ylabel(\"Y values\")\nax.set_xlim(0, 20)\nax.set_title(\"Customized Plot\")\n\nText(0.5, 1.0, 'Customized Plot')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "href": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "title": "Plotting with matplotlib",
    "section": "Common Style Options",
    "text": "Common Style Options\nColors: Named colors, hex codes, RGB - color=\"red\", color=\"#FF0000\", color=(1,0,0)\nLine styles: - linestyle=\"-\" (solid), \"--\" (dashed), \":\" (dotted)\nMarkers: - marker=\"o\" (circle), \"+\" (plus), \"^\" (triangle)\nTransparency: - alpha=0.7 (70% opaque)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "href": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "title": "Plotting with matplotlib",
    "section": "Legends and Annotations",
    "text": "Legends and Annotations\n\nfig, ax = plt.subplots()\n\nax.plot(x, y1, label=\"Fitted line\", color=\"blue\", linestyle=\"--\")\nax.scatter(x, y2, label=\"Measurements\", color=\"red\", marker='o')\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\") \nax.legend()  # Uses the label parameters\nax.set_title(\"Plot with Legend\")\n\nText(0.5, 1.0, 'Plot with Legend')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histograms",
    "href": "slides/09_intro_matplotlib_slides.html#histograms",
    "title": "Plotting with matplotlib",
    "section": "Histograms",
    "text": "Histograms\n\n# Generate random data\nrng = np.random.default_rng(seed=68)\ndata1 = rng.normal(0, 1, 5000)\ndata2 = rng.normal(1, 1.5, 1000)\n\nfig, ax = plt.subplots()\nbins = np.arange(-4, 6, 0.3)\n\nax.hist(data1, bins=bins, alpha=0.7, color=\"skyblue\", \n        density=True, label=\"Dataset 1\")\nax.hist(data2, bins=bins, alpha=0.7, color=\"orange\", \n        density=True, label=\"Dataset 2\")\n\nax.set_xlabel(\"Value\")\nax.set_ylabel(\"Density\")\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "href": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "title": "Plotting with matplotlib",
    "section": "Histogram Options",
    "text": "Histogram Options\nKey parameters: - bins: Number or explicit bin edges - alpha: Transparency (0-1) - density: Normalize to show probability density - histtype: ‘bar’, ‘step’, ‘stepfilled’\n\nfig, ax = plt.subplots()\nax.hist(data1, bins=30, alpha=0.6, histtype='step', \n        color='purple', linewidth=2)\n\n(array([  1.,   0.,   1.,   5.,   6.,  24.,  38.,  56., 132., 135., 204.,\n        272., 376., 442., 452., 515., 502., 494., 393., 305., 229., 160.,\n        107.,  76.,  28.,  32.,   9.,   3.,   2.,   1.]),\n array([-4.01393721, -3.75715456, -3.50037191, -3.24358926, -2.9868066 ,\n        -2.73002395, -2.4732413 , -2.21645865, -1.95967599, -1.70289334,\n        -1.44611069, -1.18932804, -0.93254538, -0.67576273, -0.41898008,\n        -0.16219743,  0.09458523,  0.35136788,  0.60815053,  0.86493318,\n         1.12171584,  1.37849849,  1.63528114,  1.89206379,  2.14884645,\n         2.4056291 ,  2.66241175,  2.9191944 ,  3.17597706,  3.43275971,\n         3.68954236]),\n [&lt;matplotlib.patches.Polygon at 0x12ffb8e90&gt;])"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "href": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "title": "Plotting with matplotlib",
    "section": "Multiple Plots on Same Axes",
    "text": "Multiple Plots on Same Axes\n\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# Multiple data series\nx_vals = np.linspace(0, 2*np.pi, 100)\ny1 = np.sin(x_vals)\ny2 = np.cos(x_vals)\ny3 = np.sin(2*x_vals)\n\nax.plot(x_vals, y1, label=\"sin(x)\")\nax.plot(x_vals, y2, label=\"cos(x)\", linestyle='--')\nax.scatter(x_vals[::10], y3[::10], label=\"sin(2x)\", marker='o')\n\nax.legend()\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\n\nText(0, 0.5, 'y')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "href": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a Figure",
    "text": "Anatomy of a Figure\n\nMatplotlib anatomy shows the components: Figure, Axes, Labels, Legend, Ticks, etc.Key components: - Figure: Overall container - Axes: Plot area with data - Axis labels: x/y descriptions\n- Ticks: Scale markers - Legend: Data series identification"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "href": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "title": "Plotting with matplotlib",
    "section": "Figure Size and Layout",
    "text": "Figure Size and Layout\n\n# Control figure size\nfig, ax = plt.subplots(figsize=(12, 6))\n\n# Multiple subplots (brief example)\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\nax1.plot([1, 2, 3], [1, 4, 2])\nax2.scatter([1, 2, 3], [2, 1, 3])\nax1.set_title(\"Plot 1\")\nax2.set_title(\"Plot 2\")\n\nText(0.5, 1.0, 'Plot 2')"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#best-practices",
    "href": "slides/09_intro_matplotlib_slides.html#best-practices",
    "title": "Plotting with matplotlib",
    "section": "Best Practices",
    "text": "Best Practices\n\nAlways label your axes\nUse legends for multiple data series\nChoose appropriate plot types for your data\nControl figure size for readability\nUse colors wisely - consider colorblind accessibility\nKeep it simple - don’t over-decorate\n\n\n# Good example\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(x, y1, label=\"Data\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Amplitude (V)\")\nax.set_title(\"Signal vs Time\")\nax.legend()\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[11], line 3\n      1 # Good example\n      2 fig, ax = plt.subplots(figsize=(8, 5))\n----&gt; 3 ax.plot(x, y1, label=\"Data\")\n      4 ax.set_xlabel(\"Time (s)\")\n      5 ax.set_ylabel(\"Amplitude (V)\")\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/matplotlib/axes/_axes.py:1724, in Axes.plot(self, scalex, scaley, data, *args, **kwargs)\n   1481 \"\"\"\n   1482 Plot y versus x as lines and/or markers.\n   1483 \n   (...)   1721 (``'green'``) or hex strings (``'#008000'``).\n   1722 \"\"\"\n   1723 kwargs = cbook.normalize_kwargs(kwargs, mlines.Line2D)\n-&gt; 1724 lines = [*self._get_lines(self, *args, data=data, **kwargs)]\n   1725 for line in lines:\n   1726     self.add_line(line)\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/matplotlib/axes/_base.py:303, in _process_plot_var_args.__call__(self, axes, data, *args, **kwargs)\n    301     this += args[0],\n    302     args = args[1:]\n--&gt; 303 yield from self._plot_args(\n    304     axes, this, kwargs, ambiguous_fmt_datakey=ambiguous_fmt_datakey)\n\nFile ~/.pyenv/versions/3.11.1/lib/python3.11/site-packages/matplotlib/axes/_base.py:499, in _process_plot_var_args._plot_args(self, axes, tup, kwargs, return_kwargs, ambiguous_fmt_datakey)\n    496     axes.yaxis.update_units(y)\n    498 if x.shape[0] != y.shape[0]:\n--&gt; 499     raise ValueError(f\"x and y must have same first dimension, but \"\n    500                      f\"have shapes {x.shape} and {y.shape}\")\n    501 if x.ndim &gt; 2 or y.ndim &gt; 2:\n    502     raise ValueError(f\"x and y can be no greater than 2D, but have \"\n    503                      f\"shapes {x.shape} and {y.shape}\")\n\nValueError: x and y must have same first dimension, but have shapes (10,) and (100,)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "href": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "title": "Plotting with matplotlib",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nmatplotlib is the standard Python plotting library\nObject-oriented approach with fig, ax is recommended\nCustomization options for colors, styles, markers\nMultiple plot types: line, scatter, histogram\nAlways annotate with labels, legends, titles\nPractice with different plot types and styling options"
  },
  {
    "objectID": "07/exercises_numpy.html",
    "href": "07/exercises_numpy.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape.\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment.\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results.\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180]) 1. Convert these angles to radians (hint: multiply by π/180, use np.pi) 2. Calculate the sine and cosine of each angle 3. Verify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos()) 4. Print all results\n\n# Your code here\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "href": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge 1: Temperature Conversion",
    "text": "Challenge 1: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "href": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "title": "numpy Exercises",
    "section": "Challenge 2: Kinetic energy",
    "text": "Challenge 2: Kinetic energy\nTask Given arrays of mass (kg) and velocity (m/s) for several objects:\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n\nCalculate the kinetic energy \\(K\\) for each object using the formula:\n\n\\[K =  \\dfrac{1}{2}m v^2\\]\n\nCalculate the total kinetic energy of the system (sum of all objects)\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature.\n\n\n# Your code here",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html",
    "href": "07/lecture_intro_numpy.html",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n1.0\n[2. 3. 5.]\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\nfloat64\n(6,)\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n[ 4.  4.  8. 12. 20. 32.]\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\nArray operation is 1 times faster for 100,000 numbers\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "href": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n1.0\n[2. 3. 5.]\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\nfloat64\n(6,)\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n[4.0, 4.0, 8.0, 12.0, 20.0, 32.0]\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n[ 4.  4.  8. 12. 20. 32.]\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\nArray operation is 1 times faster for 100,000 numbers\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#working-with-numpy",
    "href": "07/lecture_intro_numpy.html#working-with-numpy",
    "title": "The numpy module",
    "section": "Working with numpy",
    "text": "Working with numpy\nTo use the numpy module we always need to start by using an import statement. In this case we import the numpy module and use the shorthand np:\nWe’ve seen that we can apply operators directly to a numpy.array:\n\n\narray([ 6.5,  6.5,  8. ,  9.5, 12.5, 17. ])\n\n\nSimilarly you can use additional functions provided by the numpy module to do something to each element in the array. For example you can apply a square root:\n\n\n[1.         1.         1.41421356 1.73205081 2.23606798 2.82842712]\n\n\nOr perform a reductive operation such as calculating the mean of all the elements:\n\n\n3.3333333333333335\n\n\nWe can also apply mathematical operations over the whole array. For instance we can look at the np.cos function which produces applies the cosine function element-wise:\nThe help states that this wants an array-like object and wants the input in radians. We can write this as:\n\n\n[ 0.54030231  0.54030231 -0.41614684 -0.9899925   0.28366219 -0.14550003]\n\n\nIf we look at arr1 we can see that this has not been updated by the application of these operations - when using this functionality a copy of the array is returned which you can choose to re-assign to the original variable name or create a new variable:\n\n\n[1. 1. 2. 3. 5. 8.]\n[ 6.5  6.5  8.   9.5 12.5 17. ]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Element-wise operations on 1D arrays",
    "text": "Element-wise operations on 1D arrays\nElement-wise operations in numpy allow you to perform arithmetic or mathematical functions on each corresponding element of arrays. For example, if you have two arrays of the same length, arr1 and arr2, you can add them directly: arr1 + arr2. This will produce a new array where each element is the sum of the elements at the same position in the original arrays. Similarly, you can use other operators (-, *, /) or numpy functions (np.sqrt(arr1), np.cos(arr1)) to apply operations to each element individually. The arrays must have compatible shapes for these operations.\n\n\n[ 7.5  7.5 10.  12.5 17.5 25. ]\n[-5.5 -5.5 -6.  -6.5 -7.5 -9. ]\n\n\n\n\nElement-wise multiplication: [  6.5   6.5  16.   28.5  62.5 136. ]\nElement-wise division: [0.15384615 0.15384615 0.25       0.31578947 0.4        0.47058824]\n\n\nWhen 1D arrays have different lengths, you need to be careful about the operations you perform. Element-wise operations: Operations such as arr1 + arr3 or arr1 * arr3 require arrays to have the same length or compatible shapes. If the lengths differ, numpy will raise a ValueError due to shape mismatch.\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[22], line 2\n      1 # This will raise a ValueError because arr1 and arr3 have different lengths\n----&gt; 2 result = arr1 + arr3\n\nNameError: name 'arr3' is not defined",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Basic operations on 1D arrays",
    "text": "Basic operations on 1D arrays\nSumming all elements in a 1D numpy array can be done with np.sum(arr1).\nFor cumulative summing, use np.cumsum(arr1), which returns an array where each element is the sum of all previous elements.\nSorting is performed with np.sort(arr1), which returns a sorted copy of the array.\nTo concatenate two arrays, use np.concatenate([arr1, arr2]). This joins the arrays end-to-end, creating a new array containing all elements from both arrays in order. Concatenation is useful for combining datasets or extending arrays.\nTo find unique elements, use np.unique(arr1), which returns an array of the distinct values in arr1. These operations are efficient and commonly used for data analysis.\n\n\nSum of arr1: 20.0\nCumulative sum of arr1: [ 1.  2.  4.  7. 12. 20.]\nSorted arr1: [1. 1. 2. 3. 5. 8.]\nCombined array: [ 1.   1.   2.   3.   5.   8.   6.5  6.5  8.   9.5 12.5 17. ]\nUnique elements in combined: [ 1.   2.   3.   5.   6.5  8.   9.5 12.5 17. ]",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html",
    "href": "09/fun_matplotlib_decoration.html",
    "title": "Add some decoration",
    "section": "",
    "text": "There are two options below of template plots to build upon: a tree and a snowman.\nAs a group, decorate an image (or multiple images) and when completed you can save this figure to file (uncomment the appropriate cell to do so). This can then be downloaded from Noteable and uploaded to the Padlet with your group name:\nhttps://uob.padlet.org/fturci/adding-decorations-zk4khqfwj17l2377",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "title": "Add some decoration",
    "section": "Decorate a tree",
    "text": "Decorate a tree\nThe code below creates the outline of a tree which you can add your decoration to:\n\n### Code to create the template ###\n# Modify this code if you wish but this creates your background template\n\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nplt.rcdefaults()         # Set axes labels to be default style\nfig, ax = plt.subplots()\nplt.xkcd()               # Set xkcd (sketch style) for everything else\n\n## Define parameters for the tree\ntree_x = [1.0, 2.0, 3.0]\ntree_y = [1.0, 5.0, 1.0]\ntree_colour = \"green\"\n\ntree = list(zip(tree_x,tree_y)) # create [x,y] pairs for Polygon function\n\n## Define parameters for the tree trunk\ntrunk_x = [1.8, 1.8, 2.2, 2.2]\ntrunk_y = [0.0, 1.0, 1.0, 0.0]\ntrunk_colour = \"brown\"\n\ntrunk = list(zip(trunk_x,trunk_y)) # create [x,y] pairs for Polygon function\n\n## Plot the both aspects of the tree (using Polygon patches)\n# Set zorder to make sure any other features are on top of this\nt1 = plt.Polygon(tree, color=tree_colour,zorder=-1)\nax.add_patch(t1)\n\nt2 = plt.Polygon(trunk, color=trunk_colour,zorder=-2)\nax.add_patch(t2)\n\n## Limit the plotting area\nax.set_xlim([0,4])\nax.set_ylim([0,5.5])\n\n#### ADD ADDITIONAL FEATURES BELOW ####\n\n\n\n\n\n\n\n\n\n## To save the figure to file - uncomment the code below\n#fig.savefig(\"my_decorated_tree.png\")",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "title": "Add some decoration",
    "section": "Decorate a snowman",
    "text": "Decorate a snowman\nAs an alternative, the code below creates the outline of a snowman which you can add features to:\n\n### Code to create the template ###\n# Modify this code if you wish but this creates your background template\n\nimport numpy as np \nimport matplotlib.pyplot as plt\n\nplt.rcdefaults()         # Set axes labels to be default style\nfig, ax = plt.subplots()\nplt.xkcd()               # Set xkcd (sketch style) for everything else\nax.set_aspect(\"equal\")   # Make x aspect = y aspect so circles are not squashed\n\nax.set_facecolor(\"xkcd:navy blue\") # Set colour of plotting area\n\n## Define details for the snowman\nsnowman_centre = [(2.0, 0.4), (2.0, 1.4), (2.0, 2.2)]\nsnowman_colour = \"white\"\nsnowman_radius = [0.6, 0.5, 0.4]\n\n## Plot the snowman (using Circle patches)\n# Set zorder to make sure any other features are on top of this\nt1 = plt.Circle(snowman_centre[0], snowman_radius[0], color=snowman_colour,zorder=-3)\nt2 = plt.Circle(snowman_centre[1], snowman_radius[1], color=snowman_colour,zorder=-2)\nt3 = plt.Circle(snowman_centre[2], snowman_radius[2], color=snowman_colour,zorder=-1)\n\nax.add_patch(t1)\nax.add_patch(t2)\nax.add_patch(t3)\n\n## Limit the plotting area\nax.set_xlim([0,4])\nax.set_ylim([0,4])\n\n#### ADD ADDITIONAL FEATURES BELOW ####\n\n\n\n\n\n\n\n\n\n## To save the figure to file - uncomment the code below\n#fig.savefig(\"my_decorated_snowman.png\")\n\n\n\nSome options in matplotlib\nHere are some examples of some matplotlib options and functionality that you could use:\n\n# Lines to set up the plot\nplt.rcdefaults()\nfig2, ax2 = plt.subplots()\nplt.xkcd()\n\n## You can add points using the `scatter(x, y)` function setting:\n## the colour (`color`), point size (`s`) and shape (`marker`)\nax2.scatter([2.0],[2.9],color=\"magenta\",marker=\"o\",s=30)\nax2.scatter([2.5, 1.5],[2.5, 2.5],color=\"red\",marker=\"*\",s=400)\n\n\n## Or you can add lines using the `plot(x, y)` function setting:\n## the colour (`color`), line width (`linewidth`) and line style (`linestyle`)\nax2.plot([1.2,2.8],[3.2,2.8],color=\"yellow\",linewidth=\"2\",linestyle=\"-\")\nax2.plot([1.2,2.8],[1.9,2.1],color=\"blue\",linewidth=\"10\",linestyle=\":\")\n\n\n## Or add a patch such as a rectangle (using `plt.Rectangle` definition)\n## or `plt.Polygon()` or `plt.Circle()` as defined in previous cells.\n# plt.Rectangle((x, y), width, height, angle, color=color)\nrectangle = plt.Rectangle((1.9,2.2), width=0.2, height=0.2, color=\"#660033\")\nax2.add_patch(rectangle)\n\n\n\n\n\n\n\n\n\n\nMore options\nColour options: - https://matplotlib.org/3.1.0/gallery/color/named_colors.html\nMarker and line style options: - https://matplotlib.org/stable/api/markers_api.html - https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html\nPatches (Rectangle, Circle, Polygon) - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Polygon.html - https://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Circle.html\nOr look in the matplotlib gallery to see if anything provides inspiration: - https://matplotlib.org/stable/gallery/index.html\n\nExtra Challenge: can you use random number generation to add detail to your picture?",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/exercises_plotting_data_from_file_solutions.html",
    "href": "09/exercises_plotting_data_from_file_solutions.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\ndata_filename = \"data/FIRST ORDER_k=0.0005.txt\"\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\nopen_file = open(data_filename)\ndata_from_file = open_file.read()\nprint(data_from_file[0:200])\n\nTime    A   B   \n0   1   0   \n100 0.950565    0.0494353   \n200 0.903573    0.0964268   \n300 0.858905    0.141095    \n400 0.816445    0.183555    \n500 0.776083    0.223917    \n600 0.737717    0.262283    \n700 0.701248    0.298752    \n800 0.666582    0.33341\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\nimport numpy as np\n\ndata_kinetic_k0005 = np.genfromtxt(\"data/FIRST ORDER_k=0.0005.txt\", names=True)\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\ndata_kinetic_k0005.dtype.names\n\n('Time', 'A', 'B')\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\ndata_kinetic_k0005['A']\n\narray([1.        , 0.950565  , 0.903573  , 0.858905  , 0.816445  ,\n       0.776083  , 0.737717  , 0.701248  , 0.666582  , 0.633629  ,\n       0.602305  , 0.57253   , 0.544227  , 0.517323  , 0.491749  ,\n       0.467439  , 0.444331  , 0.422365  , 0.401486  , 0.381638  ,\n       0.362772  , 0.344838  , 0.327791  , 0.311586  , 0.296183  ,\n       0.281541  , 0.267623  , 0.254393  , 0.241817  , 0.229863  ,\n       0.218499  , 0.207698  , 0.19743   , 0.18767   , 0.178393  ,\n       0.169574  , 0.161191  , 0.153222  , 0.145648  , 0.138447  ,\n       0.131603  , 0.125097  , 0.118913  , 0.113035  , 0.107447  ,\n       0.102135  , 0.097086  , 0.0922865 , 0.0877243 , 0.0833876 ,\n       0.0792653 , 0.0753468 , 0.071622  , 0.0680813 , 0.0647157 ,\n       0.0615165 , 0.0584754 , 0.0555846 , 0.0528368 , 0.0502248 ,\n       0.0477419 , 0.0453818 , 0.0431383 , 0.0410057 , 0.0389786 ,\n       0.0370517 , 0.03522   , 0.0334789 , 0.0318239 , 0.0302506 ,\n       0.0287552 , 0.0273337 , 0.0259824 , 0.024698  , 0.023477  ,\n       0.0223164 , 0.0212132 , 0.0201645 , 0.0191677 , 0.0182201 ,\n       0.0173194 , 0.0164632 , 0.0156493 , 0.0148757 , 0.0141403 ,\n       0.0134413 , 0.0127768 , 0.0121452 , 0.0115448 , 0.0109741 ,\n       0.0104316 , 0.00991587, 0.00942568, 0.00895972, 0.00851679,\n       0.00809576, 0.00769554, 0.00731511, 0.00695349, 0.00660974,\n       0.00628298])\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\ndata_kinetic_k0005 ['Time']\n\narray([    0.,   100.,   200.,   300.,   400.,   500.,   600.,   700.,\n         800.,   900.,  1000.,  1100.,  1200.,  1300.,  1400.,  1500.,\n        1600.,  1700.,  1800.,  1900.,  2000.,  2100.,  2200.,  2300.,\n        2400.,  2500.,  2600.,  2700.,  2800.,  2900.,  3000.,  3100.,\n        3200.,  3300.,  3400.,  3500.,  3600.,  3700.,  3800.,  3900.,\n        4000.,  4100.,  4200.,  4300.,  4400.,  4500.,  4600.,  4700.,\n        4800.,  4900.,  5000.,  5100.,  5200.,  5300.,  5400.,  5500.,\n        5600.,  5700.,  5800.,  5900.,  6000.,  6100.,  6200.,  6300.,\n        6400.,  6500.,  6600.,  6700.,  6800.,  6900.,  7000.,  7100.,\n        7200.,  7300.,  7400.,  7500.,  7600.,  7700.,  7800.,  7900.,\n        8000.,  8100.,  8200.,  8300.,  8400.,  8500.,  8600.,  8700.,\n        8800.,  8900.,  9000.,  9100.,  9200.,  9300.,  9400.,  9500.,\n        9600.,  9700.,  9800.,  9900., 10000.])\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n# Extract time and concentration of A from our array\ntime = data_kinetic_k0005['Time']\nconcentration_A = data_kinetic_k0005[\"A\"]\n\nWe could then use matplotlib to plot this:\n\nimport matplotlib.pyplot as plt\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time, concentration_A)\n\n# Add x and y labels for this data\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\n\nText(0, 0.5, 'Concentration')\n\n\n\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\nmask = concentration_A &lt;= 0.5\nconcentration_A_low = concentration_A[mask]\n# Make sure to match the time values (index) to our filtered data\ntime_low = time[mask]\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n# Create our Figure and Axes objects for plotting\nfig, ax = plt.subplots()\n\n# Plot our data - time vs concentration of A\nax.plot(time_low, concentration_A_low)\n\n# Note: Alternative syntax! we can set multiple properties at once\nax.set(xlabel = \"Time (s)\",  ylabel=\"Concentration\")\n\n\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\n### ADD CODE HERE (copy code from above and add to this)\n\nfig, ax = plt.subplots()\n\nax.plot(time, concentration_A, label=\"A\")\nax.plot(time, data_kinetic_k0005[\"B\"], label=\"B\")\n\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\nax.legend()\n\n\n\n\n\n\n\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\n\n\n### ADD CODE HERE\n\nsum_concentration = concentration_A + data_kinetic_k0005[\"B\"]\nprint(sum_concentration)\n\n[1.         1.0000003  0.9999998  1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.\n 1.         1.         1.         1.         1.         1.0000005\n 1.0000003  0.9999996  1.0000003  0.9999998  1.         1.0000003\n 0.9999997  1.0000005  1.0000004  0.9999996  0.9999998  0.9999998\n 0.9999999  0.9999998  1.0000003  0.9999997  0.9999996  0.9999997\n 1.         0.9999999  0.9999999  0.9999996  1.0000002  0.9999997\n 1.0000004  1.         1.         1.0000004  1.0000002  0.9999995\n 0.9999997  1.0000001  1.0000004  1.0000002  1.0000003  0.9999997\n 1.0000003  1.0000003  0.9999998  1.0000002  0.9999998  1.0000001\n 0.9999996  0.99999987 0.99999968 0.99999972 0.99999979 0.99999976\n 0.99999954 1.00000011 1.00000049 0.99999974 0.99999998]\n\n\n\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?\n\n\n### ADD CODE HERE (copy code from previous question and add to this)\n\nfig, ax = plt.subplots()\n\nax.plot(time, concentration_A, label=\"A\")\nax.plot(time, data_kinetic_k0005[\"B\"], label=\"B\")\n\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Concentration\")\nax.plot(time, sum_concentration, label=\"A+B\")\nax.legend()\n\n\n\n\n\n\n\n\n\nWe add the sum of concentrations (A+B) as a third line to the plot. This sum remains very close to 1 throughout the reaction, indicating that as “A” decays, it is converted into “B” without significant loss or gain of total concentration. This demonstrates conservation of mass in the reaction: all of “A” is accounted for as it becomes “B”.",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Solutions"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html",
    "title": "Exercises - Working with NumPy",
    "section": "",
    "text": "Create a 1D NumPy array of integers from 10 to 19. Access the element at index 3.\n\nimport numpy as np\narr = np.arange(10, 20)\narr[3]\n\n13",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Solutions"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "title": "Exercises - Working with NumPy",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\nimport math\nR = 10.0 #in metres\nomega = 2.0*2*math.pi/60. # in radians per second\nx0 = R # in metres\ny0 = 0 # in metres\ndt = 2.0 # in seconds\nduration = 20.0 #in seconds\nnum_iterations  = int(duration/dt)\nx, y = [], []\nt = 0\nfor _ in range(num_iterations):\n    x.append(R*math.cos(omega*t)+x0)\n    y.append(R*math.sin(omega*t)+y0)\n    t += dt \n\n# plotting, ignore the details for now sicne we will cover this in a later lecture\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\nplt.show()\n\n\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead.\n\n# solution\nimport numpy as np\nR = 10.0\n# numpy also contains all the useful mathematical constants\nomega = 2.0*2*np.pi/60.\ntheta0 = 0\ndt = 2.0\nduration = 20.0\n\n# using numpy arrays, the for loop is replaced by the creation of an array\nt = np.arange(0,duration,dt) \n# from the array t, we can generate any other array, for example  by multiplying by a scalar\ntheta = omega*t+theta0\n# now theta is another array, and we can apply a numpy function, such as np.cos\nx = R*np.cos(theta)\ny = R*np.sin(theta)\n\n# plotting, ignore the details for now\nimport matplotlib.pyplot as plt\nplt.scatter(x,y)\nplt.axis(\"equal\")\n\n(-10.77054980770496,\n 10.989073800366903,\n -6.669006096755103,\n 10.736372527513106)",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Solutions"
    ]
  }
]