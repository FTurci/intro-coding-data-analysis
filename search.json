[
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html",
    "href": "14/exercises_pandas_preprocessing_solutions.html",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "",
    "text": "In this notebook, you’ll practice essential data preprocessing skills with two real-world datasets:\nThrough these exercises, you’ll learn:"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-1-load-weather-data",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-1-load-weather-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 1: Load Weather Data",
    "text": "Exercise 1: Load Weather Data\nThe UK Met Office provides historical weather data for stations across the UK. Your task is to load data from Yeovilton station in Somerset, England. The data file is text-based but contains metadata lines at the top before the actual data begins.\nData Source: https://www.metoffice.gov.uk/pub/data/weather/uk/climate/stationdata/yeoviltondata.txt\nThe Met Office weather data contains monthly measurements from Yeovilton station:\n\nyyyy: Year (4 digits, e.g., 1964)\nmm: Month (1-12, where 1 = January, 12 = December)\ntmax: Maximum temperature for the month (°C)\ntmin: Minimum temperature for the month (°C)\naf: Air frost days - number of days when temperature fell below 0°C\nrain: Total monthly rainfall (millimeters)\nsun: Total monthly sunshine duration (hours)\n\nGoal: Load the weather data, skipping metadata, and display the first rows to verify.\nHints: - pd.read_csv(url, ...): Reads data from a URL or file path - the option skiprows=[0,1,2,3] can skip specific lines (in this case line 0,1,2,3) - The option sep='\\s+' uses whitespace as separator (regex for “one or more spaces/tabs”) - The option on_bad_lines='skip' skips malformed lines - .head() Display first 5 rows to confirm data loaded correctly - .shape Returns (rows, columns) showing DataFrame dimensions"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-2-clean-and-prepare-weather-data",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-2-clean-and-prepare-weather-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 2: Clean and Prepare Weather Data",
    "text": "Exercise 2: Clean and Prepare Weather Data\nRaw data requires transformation before analysis. The Met Office data uses separate year and month columns, has ‘—’ for missing values, and some numeric columns may be stored as strings.\nGoal: Create a clean DataFrame with datetime index, proper numeric types, and NaN for missing values. We will remove the NaN afterwards.\nExpected columns: yyyy (year), mm (month), tmax (max temp °C), tmin (min temp °C), af (air frost days), rain (mm), sun (hours)\nHints: - Use .dtypes to check tha data type - df.info(): Shows columns, data types, and non-null counts - pd.to_datetime({'year': df['yyyy'], 'month': df['mm'], 'day': 1}): Creates datetime from a dictionary with data from multiple columns - df.set_index('column', inplace=True): Sets a column as the DataFrame index - df.replace('---', np.nan): Replaces ‘—’ strings with NaN - pd.to_numeric(series, errors='coerce'): Converts to numeric, replacing failures with NaN - df.sort_index(inplace=True): Sorts by index to ensure chronological order"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-3-handle-missing-values-in-weather-data",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-3-handle-missing-values-in-weather-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 3: Handle Missing Values in Weather Data",
    "text": "Exercise 3: Handle Missing Values in Weather Data\nHistorical weather records often have gaps due to equipment failures or missing measurements. Your approach should depend on the nature of each measurement.\nGoal: Analyze missing value patterns and apply appropriate filling strategies. Check that no missing values remain.\nData characteristics: - Temperature: Changes gradually (good for interpolation) - Rainfall: Variable; 0mm vs missing are different - Sunshine/frost: Could be 0 (none) or missing (not recorded)\nHints: - df.isnull().sum(): Counts missing (NaN) values per column - .interpolate(method='linear'): Estimates missing values from surrounding values (good for gradual changes) - .fillna(0): Replaces NaN with 0 (use carefully—only when 0 is plausible or to mark a period where data is missing) - .fillna(method='ffill'): Forward fill—propagates last valid value forward - .fillna(method='bfill'): Backward fill—propagates next valid value backward\nReflect: Why is interpolation better for temperature than rainfall?"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-4-extract-date-components-and-create-weather-features",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-4-extract-date-components-and-create-weather-features",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 4: Extract Date Components and Create Weather Features",
    "text": "Exercise 4: Extract Date Components and Create Weather Features\nFeature engineering creates new variables to reveal patterns. Extract date components (month, season) and create derived measurements (temperature range, extremes).\nGoal: Add columns for\n\nyear\nmonth name\nseason\ntemperature range\nmean temp\nhot months (the maximum temp &gt; 25)\n\nHints: - df.index.year, df.index.month, df.index.quarter: Extract year, month (1-12), or quarter (1-4) - df.index.month_name(): Returns full month name (‘January’, etc.) - Custom function + .apply(): Create season mapper: def get_season(month): ... then df['season'] = df['month'].apply(get_season)"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-5-analyze-weather-patterns-with-groupby",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-5-analyze-weather-patterns-with-groupby",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 5: Analyze Weather Patterns with GroupBy",
    "text": "Exercise 5: Analyze Weather Patterns with GroupBy\nThe groupby() operation splits data into groups, applies functions (like mean), then combines results.\nYou can group by month, season, year, or decade to analyze climate patterns.\nGoal: Calculate the typical (mean) monthly temperature, rainfall, and sunshine for each month and season.\nHints: - df.groupby('column')['measurement1'].mean(): Groups and calculates mean for one column - df.groupby('column')[['col1', 'col2']].mean(): Groups and calculates means for multiple columns\nMore advanced question: Can you define decades and analyze trends over decades?\n\n\n\n\n\n\n\n\n\n\n\n\nTo analyse over decades, we need a new column for the 1960s, 1970s, etc etc. We can create this by integer division of the year by 10, then multiplying back by 10. For example, for year 1964:(1964 // 10) * 10 = 1960."
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-6-load-and-explore-wine-quality-data",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-6-load-and-explore-wine-quality-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 6: Load and Explore Wine Quality Data",
    "text": "Exercise 6: Load and Explore Wine Quality Data\nShift from time series to cross-sectional data. This UCI dataset contains physicochemical measurements of Portuguese red wines with quality ratings from experts.\nDataset: 11 chemical properties + 1 quality score (0-10).\nFeatures (chemical properties, units in parentheses): - fixed acidity (g/L tartaric acid) - volatile acidity (g/L acetic acid) - citric acid (g/L) - residual sugar (g/L) - chlorides (g/L sodium chloride) - free sulfur dioxide (mg/L) - total sulfur dioxide (mg/L) - density (g/cm³) - pH (0-14 scale) - sulphates (g/L potassium sulphate) - alcohol (% vol)\nTarget: - quality (score 0-10, median expert ratings)\nEach row = different wine sample.\nImportant: File uses semicolons as delimiter, not commas.\nData Source: https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv\nGoal: Load data correctly and look at its shape and summary statistics.\nHints: - pd.read_csv(url, sep=';'): Specify semicolon delimiter - .head(), .tail(): Show first/last rows - .shape: Returns (n_rows, n_columns) - .info(): Summary of columns, types, non-null counts - .describe(): Statistics (mean, std, min, max, quartiles) for numeric columns - .isnull().sum(): Count missing values per column"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-7-create-wine-quality-categories-and-clean-data",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-7-create-wine-quality-categories-and-clean-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 7: Create Wine Quality Categories and Clean Data",
    "text": "Exercise 7: Create Wine Quality Categories and Clean Data\nConvert continuous variables into categorical groupings for easier pattern recognition. This is called binning or discretization.\nGoal: We will create three categorical columns: - quality_cat: ‘Poor’ (0-4), ‘Average’ (5-6), ‘Good’ (7-10) - sugar_level: which is ‘Dry’ (&lt;9g/L), ‘Medium-Dry’ (9-18g/L), ‘Sweet’ (&gt;18g/L)\nWe then construct a table showing counts of wines in each quality category by sugar level. This is called a contingency table. and can be produced with pd.crosstab().\nHints: - pd.cut(series, bins=[...], labels=[...]): Bins continuous data into categories - bins=[0, 4, 6, 10] creates bins: 0-4, 4-6, 6-10 - .value_counts(): Shows how many items in each category - pd.crosstab(df['cat1'], df['cat2']): Contingency table showing counts for category combinations"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-8-create-derived-features",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-8-create-derived-features",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 8: Create Derived Features",
    "text": "Exercise 8: Create Derived Features\nCombine existing variables to create more informative features.\nGoal: Engineer new features by combining chemical measurements: 1. Total Acidity: Sum fixed + volatile acidity for total acidity 2. Acidity ratio: fixed divided by volatile acidity 3. Balance ratios: Create sweetness-to-total-acidity ratio to measure wine balance 5. Standardized scores: Calculate z-scores for alcohol to normalize its scale. This is defined for a value in a popluation of given mean and standard deviation as (value - mean) / std deviation.\nThen analyze which derived features correlate most strongly with wine quality.\nHints: - The df[selected_cols].corr() method can help identify strong relationships between selected columns - The .describe() method allows you to check derived features have reasonable values"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-9-wine-discovery-through-filtering",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-9-wine-discovery-through-filtering",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 9: Wine Discovery Through Filtering",
    "text": "Exercise 9: Wine Discovery Through Filtering\nLet’s use filtering to discover interesting wines in the dataset! Think of this as being a wine explorer—you’ll use boolean conditions to find wines that match specific criteria.\nGoal: Use pandas filtering to discover\n\nHidden gems: Good wines that don’t rely on high alcohol (less than 11%)\nFresh & balanced: Wines with low volatile acidity (&lt; 0.4) and good citric acid (&gt;0.3)\n\nPrint the top 5 results for each query, sorted by quality descending. In particular, print out the following columns: citric acid, total sulfur dioxide, sulphates,alcohol, acidity ratio, quality.\nHints: - df[df['column'] &gt; value] filters rows where condition is true - Combine conditions: df[(condition1) & (condition2)] (AND), df[(condition1) | (condition2)] (OR) - .sort_values('column', ascending=False) sorts by a column - .head(n) shows top n results"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing_solutions.html#exercise-10-export-and-document-your-analysis",
    "href": "14/exercises_pandas_preprocessing_solutions.html#exercise-10-export-and-document-your-analysis",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 10: Export and Document Your Analysis",
    "text": "Exercise 10: Export and Document Your Analysis\n(this can only work on Noteable)\nPreserve your work by exporting cleaned data and documenting your process. Specifically, export your data in at least two different formats.\nHints: - .to_csv('file.csv'): Exports to CSV. Use index=False to exclude index (wine) or index=True to include it (weather) - .to_excel('file.xlsx'): Exports to Excel (requires openpyxl) - .to_json('file.json', orient='index'): Exports to JSON (orient='records' or orient='index') - pd.read_csv('file.csv'): Read back to verify export - pd.DataFrame(dict): Create documentation tables from dictionaries"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html",
    "href": "14/exercises_pandas_preprocessing-solutions.html",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "",
    "text": "In this notebook, you’ll practice essential data preprocessing skills with two real-world datasets:\nThrough these exercises, you’ll learn:"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-1-load-weather-data",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-1-load-weather-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 1: Load Weather Data",
    "text": "Exercise 1: Load Weather Data\nThe UK Met Office provides historical weather data for stations across the UK. Your task is to load data from Yeovilton station in Somerset, England. The data file is text-based but contains metadata lines at the top before the actual data begins.\nData Source: https://www.metoffice.gov.uk/pub/data/weather/uk/climate/stationdata/yeoviltondata.txt\nThe Met Office weather data contains monthly measurements from Yeovilton station:\n\nyyyy: Year (4 digits, e.g., 1964)\nmm: Month (1-12, where 1 = January, 12 = December)\ntmax: Maximum temperature for the month (°C)\ntmin: Minimum temperature for the month (°C)\naf: Air frost days - number of days when temperature fell below 0°C\nrain: Total monthly rainfall (millimeters)\nsun: Total monthly sunshine duration (hours)\n\nGoal: Load the weather data, skipping metadata, and display the first rows to verify.\nHints:\n\npd.read_csv(url, ...): Reads data from a URL or file path\nthe option skiprows=[0,1,2,3] can skip specific lines (in this case line 0,1,2,3)\nThe option sep='\\s+' uses whitespace as separator (regex for “one or more spaces/tabs”)\nThe option on_bad_lines='skip' skips malformed lines\n.head() Display first 5 rows to confirm data loaded correctly\n.shape Returns (rows, columns) showing DataFrame dimensions"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-2-clean-and-prepare-weather-data",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-2-clean-and-prepare-weather-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 2: Clean and Prepare Weather Data",
    "text": "Exercise 2: Clean and Prepare Weather Data\nRaw data requires transformation before analysis. The Met Office data uses separate year and month columns, has ‘—’ for missing values, and some numeric columns may be stored as strings.\nGoal: Create a clean DataFrame with datetime index, proper numeric types, and NaN for missing values. We will remove the NaN afterwards.\nExpected columns: yyyy (year), mm (month), tmax (max temp °C), tmin (min temp °C), af (air frost days), rain (mm), sun (hours)\nHints:\n\nUse .dtypes to check tha data type\ndf.info(): Shows columns, data types, and non-null counts\npd.to_datetime({'year': df['yyyy'], 'month': df['mm'], 'day': 1}): Creates datetime from a dictionary with data from multiple columns\ndf.set_index('column', inplace=True): Sets a column as the DataFrame index\ndf.replace('---', np.nan): Replaces ‘—’ strings with NaN\npd.to_numeric(series, errors='coerce'): Converts to numeric, replacing failures with NaN\ndf.sort_index(inplace=True): Sorts by index to ensure chronological order"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-3-handle-missing-values-in-weather-data",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-3-handle-missing-values-in-weather-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 3: Handle Missing Values in Weather Data",
    "text": "Exercise 3: Handle Missing Values in Weather Data\nHistorical weather records often have gaps due to equipment failures or missing measurements. Your approach should depend on the nature of each measurement.\nGoal: Analyze missing value patterns and apply appropriate filling strategies. Check that no missing values remain.\nData characteristics:\n\nTemperature: Changes gradually (good for interpolation)\nRainfall: Variable; 0mm vs missing are different\nSunshine/frost: Could be 0 (none) or missing (not recorded)\n\nHints:\n\ndf.isnull().sum(): Counts missing (NaN) values per column\n.interpolate(method='linear'): Estimates missing values from surrounding values (good for gradual changes)\n.fillna(0): Replaces NaN with 0 (use carefully—only when 0 is plausible or to mark a period where data is missing)\n.fillna(method='ffill'): Forward fill—propagates last valid value forward\n.fillna(method='bfill'): Backward fill—propagates next valid value backward\n\nReflect: Why is interpolation better for temperature than rainfall?"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-4-extract-date-components-and-create-weather-features",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-4-extract-date-components-and-create-weather-features",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 4: Extract Date Components and Create Weather Features",
    "text": "Exercise 4: Extract Date Components and Create Weather Features\nFeature engineering creates new variables to reveal patterns. Extract date components (month, season) and create derived measurements (temperature range, extremes).\nGoal: Add columns for\n\nyear\nmonth name\nseason\ntemperature range\nmean temp\nhot months (the maximum temp &gt; 25)\n\nHints:\n\ndf.index.year, df.index.month, df.index.quarter: Extract year, month (1-12), or quarter (1-4)\ndf.index.month_name(): Returns full month name (‘January’, etc.)\nCustom function + .apply(): Create season mapper: def get_season(month): ... then df['season'] = df['month'].apply(get_season)"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-5-analyze-weather-patterns-with-groupby",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-5-analyze-weather-patterns-with-groupby",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 5: Analyze Weather Patterns with GroupBy",
    "text": "Exercise 5: Analyze Weather Patterns with GroupBy\nThe groupby() operation splits data into groups, applies functions (like mean), then combines results.\nYou can group by month, season, year, or decade to analyze climate patterns.\nGoal: Calculate the typical (mean) monthly temperature, rainfall, and sunshine for each month and season.\nHints:\n\ndf.groupby('column')['measurement1'].mean(): Groups and calculates mean for one column\ndf.groupby('column')[['col1', 'col2']].mean(): Groups and calculates means for multiple columns\n\nMore advanced question: Can you define decades and analyze trends over decades?\n\n\n\n\n\n\n\n\n\n\n\n\nTo analyse over decades, we need a new column for the 1960s, 1970s, etc etc. We can create this by integer division of the year by 10, then multiplying back by 10. For example, for year 1964:(1964 // 10) * 10 = 1960."
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-6-load-and-explore-wine-quality-data",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-6-load-and-explore-wine-quality-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 6: Load and Explore Wine Quality Data",
    "text": "Exercise 6: Load and Explore Wine Quality Data\nShift from time series to cross-sectional data. This UCI dataset contains physicochemical measurements of Portuguese red wines with quality ratings from experts.\nDataset: 11 chemical properties + 1 quality score (0-10).\nFeatures (chemical properties, units in parentheses): - fixed acidity (g/L tartaric acid) - volatile acidity (g/L acetic acid) - citric acid (g/L) - residual sugar (g/L) - chlorides (g/L sodium chloride) - free sulfur dioxide (mg/L) - total sulfur dioxide (mg/L) - density (g/cm³) - pH (0-14 scale) - sulphates (g/L potassium sulphate) - alcohol (% vol)\nTarget: - quality (score 0-10, median expert ratings)\nEach row = different wine sample.\nImportant: File uses semicolons as delimiter, not commas.\nData Source: https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv\nGoal: Load data correctly and look at its shape and summary statistics.\nHints: - pd.read_csv(url, sep=';'): Specify semicolon delimiter - .head(), .tail(): Show first/last rows - .shape: Returns (n_rows, n_columns) - .info(): Summary of columns, types, non-null counts - .describe(): Statistics (mean, std, min, max, quartiles) for numeric columns - .isnull().sum(): Count missing values per column"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-7-create-wine-quality-categories-and-clean-data",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-7-create-wine-quality-categories-and-clean-data",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 7: Create Wine Quality Categories and Clean Data",
    "text": "Exercise 7: Create Wine Quality Categories and Clean Data\nConvert continuous variables into categorical groupings for easier pattern recognition. This is called binning or discretization.\nGoal: We will create three categorical columns: - quality_cat: ‘Poor’ (0-4), ‘Average’ (5-6), ‘Good’ (7-10) - sugar_level: which is ‘Dry’ (&lt;9g/L), ‘Medium-Dry’ (9-18g/L), ‘Sweet’ (&gt;18g/L)\nWe then construct a table showing counts of wines in each quality category by sugar level. This is called a contingency table. and can be produced with pd.crosstab().\nHints: - pd.cut(series, bins=[...], labels=[...]): Bins continuous data into categories - bins=[0, 4, 6, 10] creates bins: 0-4, 4-6, 6-10 - .value_counts(): Shows how many items in each category - pd.crosstab(df['cat1'], df['cat2']): Contingency table showing counts for category combinations"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-8-create-derived-features",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-8-create-derived-features",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 8: Create Derived Features",
    "text": "Exercise 8: Create Derived Features\nCombine existing variables to create more informative features.\nGoal: Engineer new features by combining chemical measurements: 1. Total Acidity: Sum fixed + volatile acidity for total acidity 2. Acidity ratio: fixed divided by volatile acidity 3. Balance ratios: Create sweetness-to-total-acidity ratio to measure wine balance 5. Standardized scores: Calculate z-scores for alcohol to normalize its scale. This is defined for a value in a popluation of given mean and standard deviation as (value - mean) / std deviation.\nThen analyze which derived features correlate most strongly with wine quality.\nHints: - The df[selected_cols].corr() method can help identify strong relationships between selected columns - The .describe() method allows you to check derived features have reasonable values"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-9-wine-discovery-through-filtering",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-9-wine-discovery-through-filtering",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 9: Wine Discovery Through Filtering",
    "text": "Exercise 9: Wine Discovery Through Filtering\nLet’s use filtering to discover interesting wines in the dataset! Think of this as being a wine explorer—you’ll use boolean conditions to find wines that match specific criteria.\nGoal: Use pandas filtering to discover\n\nHidden gems: Good wines that don’t rely on high alcohol (less than 11%)\nFresh & balanced: Wines with low volatile acidity (&lt; 0.4) and good citric acid (&gt;0.3)\n\nPrint the top 5 results for each query, sorted by quality descending. In particular, print out the following columns: citric acid, total sulfur dioxide, sulphates,alcohol, acidity ratio, quality.\nHints: - df[df['column'] &gt; value] filters rows where condition is true - Combine conditions: df[(condition1) & (condition2)] (AND), df[(condition1) | (condition2)] (OR) - .sort_values('column', ascending=False) sorts by a column - .head(n) shows top n results"
  },
  {
    "objectID": "14/exercises_pandas_preprocessing-solutions.html#exercise-10-export-and-document-your-analysis",
    "href": "14/exercises_pandas_preprocessing-solutions.html#exercise-10-export-and-document-your-analysis",
    "title": "Two Practical Data Preprocessing Tasks",
    "section": "Exercise 10: Export and Document Your Analysis",
    "text": "Exercise 10: Export and Document Your Analysis\n(this can only work on Noteable)\nPreserve your work by exporting cleaned data and documenting your process. Specifically, export your data in at least two different formats.\nHints: - .to_csv('file.csv'): Exports to CSV. Use index=False to exclude index (wine) or index=True to include it (weather) - .to_excel('file.xlsx'): Exports to Excel (requires openpyxl) - .to_json('file.json', orient='index'): Exports to JSON (orient='records' or orient='index') - pd.read_csv('file.csv'): Read back to verify export - pd.DataFrame(dict): Create documentation tables from dictionaries"
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html",
    "href": "14/lecture_pandas_preprocessing.html",
    "title": "Pandas Pre-processing",
    "section": "",
    "text": "We now have a deeper look at the operations we can perform as we ingest data using the Pandas library in Python.\nPandas is a powerful tool for data manipulation and analysis, and it provides a variety of functions to clean, transform, and prepare data for analysis.\nThese start at the very beginning, when we read the data into a DataFrame, and continue through various stages of preprocessing.\nWe are going to explore these concepts through a walked-through approach. We will use historical weather data that is freely available online and manipulate it to ease its interpretation.",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-1-loading-the-data",
    "href": "14/lecture_pandas_preprocessing.html#step-1-loading-the-data",
    "title": "Pandas Pre-processing",
    "section": "Step 1: Loading the Data",
    "text": "Step 1: Loading the Data\nWe’ll start by loading weather data from Cardiff Bute Park. This dataset contains monthly weather observations spanning several decades.\nNote. Panda’s function read_csv() can read both from a local file and from a public URl, as in this case.",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-2-initial-data-exploration",
    "href": "14/lecture_pandas_preprocessing.html#step-2-initial-data-exploration",
    "title": "Pandas Pre-processing",
    "section": "Step 2: Initial Data Exploration",
    "text": "Step 2: Initial Data Exploration\nBefore we start cleaning, let’s understand what we’re working with.\nTo do so, we first check the amount of data that we have by inspecting the shape of the data frame and the names of the various columns.\n\n\n\n\n\n\nIt is clear that we read useful data but also less useful one:\nUseful data - We have weather measurements (Tmax, Tmin, Tmean for temperature; Rain for precipitation; Sun for sunshine hours; AF for air frost days)\nLess useful data - The Unnamed: 0 column appears to be a redundant index - The status column is mostly empty and indicates data status - There’s redundancy between Year/Month and Date columns\n\nNote. We can check the details of the various datatypes and amount of valid data using the dataframe method info().\n\n\n\n\n\n\n\nIt is clear that some columns are full of data and some almost empty. We will need to clean this up.\nWe can get quick statistics of the data distribution by calculating some main statistics.\nThe .describe() method computes summary statistics such as count, mean, standard deviation, minimum, maximum, and quartile values for all numerical columns in the dataframe.\n\n\n\n\n\n\n\nNote. The output of the describe() method is itself a dataframe. Try and explore it!\n\n\n\n\n\n\n\n\nUnderstanding the Columns\nLet’s understand what each column represents:\n\nUnnamed: 0: Index column (we’ll handle this)\nYear: Year of observation\nMonth: Month number (1-12)\nTmax: Maximum temperature (°C)\nTmin: Minimum temperature (°C)\nAF: Air Frost days (days with temperature below 0°C)\nRain: Rainfall (mm)\nSun: Sunshine hours\nstatus: Data status indicator\nDate: Date string\nTmean: Mean temperature (°C)",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-3-data-type-conversions",
    "href": "14/lecture_pandas_preprocessing.html#step-3-data-type-conversions",
    "title": "Pandas Pre-processing",
    "section": "Step 3: Data Type Conversions",
    "text": "Step 3: Data Type Conversions\nPandas has inferred the data types, but let’s check if they’re appropriate for our analysis.\n\n\n\n\n\n\n\nConverting Date Column to Datetime\nThe Date column is currently stored as text (object). This is not ideal, as it does not leverage the advanced capabilities of pandas when dealing with time data.\nFor example, pandas datetime variables allow to easily filter data by date ranges, resample to different time frequencies (e.g., yearly averages), or create time-based visualizations with proper axis labels.\nIndeed, we can convert it to a proper datetime type which will preserve the temporal order of the data points.\nTo perform the conversion, we use the pandas function  pd.to_datetime. Notice that this is not a dataframe method.\n\n\n\n\n\n\nNow we can perform boolean tests using dates!",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-4-handling-the-index",
    "href": "14/lecture_pandas_preprocessing.html#step-4-handling-the-index",
    "title": "Pandas Pre-processing",
    "section": "Step 4: Handling the Index",
    "text": "Step 4: Handling the Index\nNotice the Unnamed: 0 column? This is an artifact from the CSV file and bears little to no information.\nThe index column is important as it simplifies slicing and plotting. Since we are dealing with a time series, a natural choice for the index column is to use the date itself.\nWe can do this by setting the index of the column with set_index",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-5-detecting-missing-values",
    "href": "14/lecture_pandas_preprocessing.html#step-5-detecting-missing-values",
    "title": "Pandas Pre-processing",
    "section": "Step 5: Detecting Missing Values",
    "text": "Step 5: Detecting Missing Values\nReal-world data often has missing values. Let’s investigate.\nMissing data in pandas is encoded as NaN (Not a Number). We can check for missing values using the isnull() method combined with sum() to get a count of missing values per column.\n\n\n\n\n\n\nWe need a strategy to handle these missing values. It is useful to see what the rows with missing data look like. We can do this by filtering the dataframe using the isnull() method.\nFor example, we can check what the rows with a missing Sun value look like.\n\n\n\n\n\n\nIt looks like entire rows are missing, which suggests that the data for those months was not recorded. We will need to carefully handle these missing values.",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-6-handling-missing-values",
    "href": "14/lecture_pandas_preprocessing.html#step-6-handling-missing-values",
    "title": "Pandas Pre-processing",
    "section": "Step 6: Handling Missing Values",
    "text": "Step 6: Handling Missing Values\nWe have three main strategies for missing data: 1. Drop rows/columns with missing values 2. Fill with specific values (mean, median, forward fill, etc.) 3. Interpolate based on surrounding values\nLet’s handle each column appropriately.\n\nHandling the Status Column\nAs we have seen earlier, the status column is mostly empty and doesn’t seem critical for our analysis. Let’s drop it. uding the drop() method.\n\n\n\n\n\n\nHere the axis=1 argument specifies that we want to drop a column (not a row), avoiding potential ambiguities. Now the dataframe looks as follows:\n\n\n\n\n\n\n\n\nHandling Missing Sun Data\nFor the Sun (sunshine hours) column, interpolation could make sense as sunshine hours vary smoothly over time.\nInterpolation means to estimate missing values based on existing data points. In simple temrs, we can think of it as “filling in the gaps” by looking at the values before and after the missing data.\nFor example, imagine you have measurements of sunshine hours for most months but some months are missing. By interpolating, we can estimate the sunshine hours for those missing months based on the values from the surrounding months.\n\n\n\nInterpolation example\n\n\nVisually, in the case of linear interpolation, this looks like connecting the dots with straight lines and reading the value where the missing point should be:\nWe have various interpolation strategies that are available out of the box that go beyond simple linear interpolation. These include polynomial interpolation, spline interpolation, and others (which we will not explore in this workshop but you are invited to have a look yourself). Clearly, more complex methods require more computational resources, may use more parameters, and may be more prone to produce unexpected results. The may, however, be more accurate in some situations (if duly motivated).\nWe can specify the method using the method argument in the interpolate() method.\n\n\n\n\n\n\n\n\nFinal Check for Missing Values\nWe operated our interpolation only on the Sun column. Let’s check if there are any remaining missing values in the dataframe.\n\n\n\n\n\n\nThis is visible in plots as gaps or breaks in the lines. We can use matpltolib to visualize the data and check for continuity. Remember that the .index attribute is now our datetime index, i.e. our natural independent variable.\n\n\n\n\n\n\nIf we want to apply a method to all columns (including Tmean), we can simply call the interpolate() method without specifying a column.\n\n\n\n\n\n\nReplot the data to confirm that there are no gaps (but also shows the limitations of local interpolation).",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-7-extracting-date-components",
    "href": "14/lecture_pandas_preprocessing.html#step-7-extracting-date-components",
    "title": "Pandas Pre-processing",
    "section": "Step 7: Extracting Date Components",
    "text": "Step 7: Extracting Date Components\nPandas is very powerful when dealing with datetime data. It is capable of transforming datetime data into various useful components.\nFor example, our date time is in YYYY-MM-DD format. This means that we have the year, month, and day all in one column.\nWe can use this to extract useful individual components year, month name, season, etc.\nAny daytime columns has many attributibes, such as .year, .month, .day, .dayofweek, etc.\n\n\n\n\n\n\nWe can operate on them to perform insightful analyses.\n\n\n\n\n\n\nWe can for example extract the month name from the datetime index and create a new column Month_Name to store it. We can do the same for the quarter of the year.\n\n\n\n\n\n\n\nCreating a Season Column\nUsing the month we can even create a new categorical column, labelling the data by season.\nThis leverages the power of data to apply any arbitrary function to the data frame using the apply() method.\nIn this case we crate a very simple custom function that maps month numbers to season names.\nWe then pass the name of the custom function to the apply() method of a specific column (in this case the Month column).\n\nNote. This is an example of Python treating functions as first-class objects, i.e., we can pass them as arguments to other functions/methods. It is a simple instance of a broader programming paradigm called functional programming.",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-8-creating-more-derived-features",
    "href": "14/lecture_pandas_preprocessing.html#step-8-creating-more-derived-features",
    "title": "Pandas Pre-processing",
    "section": "Step 8: Creating More Derived Features",
    "text": "Step 8: Creating More Derived Features\nWe can continue operating on teh data to create more derived features using simple arithmetic operations.\n\n\n\n\n\n\nThese additional features allow us to aggregate the data and perform an initial analysis.\nA useful tool for this is the groupby() method, which allows us to group the data by specific columns and compute aggregate statistics for each group.\nFor example, we may want to see which month is more often classified as rainy on average.\nWe can group the data by month and compute the mean rainfall for each month.\nTo do this we use the following syntax:\ndataframe_name.groupby(‘grouping_column_name’)[‘column_to_aggregate’].aggregation_function()",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "14/lecture_pandas_preprocessing.html#step-9-exporting-cleaned-data",
    "href": "14/lecture_pandas_preprocessing.html#step-9-exporting-cleaned-data",
    "title": "Pandas Pre-processing",
    "section": "Step 9: Exporting Cleaned Data",
    "text": "Step 9: Exporting Cleaned Data\nFinally, let’s export our cleaned and enriched dataset for future use.\nPandas can export in many different formats. One of the most common is a pure text formal called CSV (comma-separated values).\nWe can use the to_csv() method of the dataframe to export the data to a CSV file.\n\n\n\n\n\n\n\n\n\n\n\n\nIt is also possible to write (and, indicentally, read) other formats such as Excel files, JSON files, SQL databases, and more. They sometimes require additional libraries to be installed.",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Pre-processing"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html",
    "href": "13/exercises_pandas_basics_solutions.html",
    "title": "Pandas Basics: Exercises",
    "section": "",
    "text": "This notebook contains exercises on basic pandas data structures including DataFrames and Series. Each exercise is followed by its solution.\nWe’ll use real datasets from online sources to make the exercises more interesting and practical."
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#setup",
    "href": "13/exercises_pandas_basics_solutions.html#setup",
    "title": "Pandas Basics: Exercises",
    "section": "Setup",
    "text": "Setup\nFirst, let’s import the necessary libraries:"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-1-creating-dataframes-from-dictionaries",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-1-creating-dataframes-from-dictionaries",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 1: Creating DataFrames from dictionaries",
    "text": "Exercise 1: Creating DataFrames from dictionaries\nCreate a pandas DataFrame called elements_df containing information about chemical elements with the following data:\n\nElement names “Hydrogen”, “Helium”, “Lithium”, “Beryllium”, “Boron”\nSymbols: “H”, “He”, “Li”, “Be”, “B”\nAtomic numbers: 1, 2, 3, 4, 5\nAtomic masses: 1.008, 4.003, 6.941, 9.012, 10.81\n\nThe column names should be: “name”, “symbol”, “atomic_number”, “atomic_mass”\n\nSolution 1"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-2-setting-and-using-indices",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-2-setting-and-using-indices",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 2: Setting and using indices",
    "text": "Exercise 2: Setting and using indices\nUsing the elements_df DataFrame from Exercise 1:\n\nSet the “symbol” column as the index\nAccess the row for “Li” using .loc[]\nExtract just the atomic mass for “He”\n\n\nSolution 2"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-3-working-with-real-data---tips-dataset",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-3-working-with-real-data---tips-dataset",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 3: Working with real data - Tips Dataset",
    "text": "Exercise 3: Working with real data - Tips Dataset\nLet’s load a real dataset from an online source. We’ll use the famous “tips” dataset which contains information about restaurant tips.\n\n\n\n\n\n\nUsing the tips_df DataFrame:\n\nDisplay the column names\nDisplay the shape of the DataFrame (number of rows and columns)\nExtract the “total_bill” column\nFind the data type (dtype) of the “day” column\nDisplay the last 8 rows of the DataFrame\n\n\nSolution 3"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-4-statistical-operations",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-4-statistical-operations",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 4: Statistical operations",
    "text": "Exercise 4: Statistical operations\nUsing the tips_df DataFrame:\n\nCalculate the mean of the “total_bill” column\nFind the maximum tip amount\nFind the minimum tip amount\nCalculate the standard deviation of the “tip” column\nFind the index (row position) of the maximum total bill\nUse .describe() to get summary statistics for all numeric columns\n\n\nSolution 4"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-5-arithmetic-operations",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-5-arithmetic-operations",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 5: Arithmetic operations",
    "text": "Exercise 5: Arithmetic operations\nUsing the tips_df DataFrame:\n\nCreate a new column called “tip_percentage” that calculates the tip as a percentage of the total bill (multiply by 100 to get percentage)\nCreate a new column called “total_cost” that adds the total_bill and tip together\nCalculate the mean tip percentage\n\n\nSolution 5"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-6-filtering-data-single-conditions",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-6-filtering-data-single-conditions",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 6: Filtering data (single conditions)",
    "text": "Exercise 6: Filtering data (single conditions)\nUsing the tips_df DataFrame:\n\nFilter to show only rows where the total_bill is greater than 30\nFilter to show only rows where the day is “Sun”\nFilter to show only rows where the tip percentage (from Exercise 5) is greater than 20%\nHow many rows have a total bill greater than 40? (Hint: use .shape or len())\n\n\nSolution 6"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-7-filtering-with-multiple-conditions",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-7-filtering-with-multiple-conditions",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 7: Filtering with multiple conditions",
    "text": "Exercise 7: Filtering with multiple conditions\nUsing the tips_df DataFrame:\n\nFilter to show rows where total_bill is greater than 20 and the day is “Sat”\nFilter to show rows where tip is greater than 5 and size (party size) is greater than or equal to 4\nFilter to show rows where the day is “Sat” or the day is “Sun”\nFilter to show rows where total_bill is between 15 and 25 (inclusive)\n\n\nSolution 7"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-8-working-with-another-dataset---iris",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-8-working-with-another-dataset---iris",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 8: Working with another dataset - Iris",
    "text": "Exercise 8: Working with another dataset - Iris\nLet’s work with the classic Iris dataset, which contains measurements of iris flowers.\n\n\n\n\n\n\nUsing the iris_df DataFrame:\n\nSet the index to be a range from 1 to the number of rows (so it starts at 1 instead of 0)\nFind how many unique species are in the dataset (Hint: use .unique() or .nunique())\nCalculate the mean sepal_length for all flowers\nFilter to show only the “setosa” species\nFor the “setosa” species, what is the maximum petal_length?\nCreate a new column called “sepal_area” that multiplies sepal_length by sepal_width\nWhich species has the largest average sepal_area? (This requires filtering by each species)\n\n\nSolution 8"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-9-series-operations",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-9-series-operations",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 9: Series operations",
    "text": "Exercise 9: Series operations\nCreate two pandas Series and perform operations on them:\n\nCreate a Series called temps_celsius with the following data:\n\nIndex: [“London”, “Paris”, “Berlin”, “Madrid”, “Rome”]\nValues: [15, 18, 14, 22, 24]\n\nCreate a Series called temps_fahrenheit that converts the Celsius temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nCreate a new Series called humidity with the same cities as index and values: [75, 65, 70, 55, 60]\nCalculate the average temperature across all cities (in Celsius)\nFind which city has the highest temperature\n\n\nSolution 9"
  },
  {
    "objectID": "13/exercises_pandas_basics_solutions.html#exercise-10-challenge---planets-dataset",
    "href": "13/exercises_pandas_basics_solutions.html#exercise-10-challenge---planets-dataset",
    "title": "Pandas Basics: Exercises",
    "section": "Exercise 10: Challenge - Planets Dataset",
    "text": "Exercise 10: Challenge - Planets Dataset\nLet’s work with a dataset about planets in our solar system.\n\n\n\n\n\n\nThis dataset contains information about discovered exoplanets (planets outside our solar system).\nChallenge tasks:\n\nHow many planets were discovered in the year 2010?\nWhat is the most common discovery method?\nCalculate the average orbital period for all planets (note: there may be missing values)\nFilter to show planets discovered by the “Transit” method with an orbital period less than 10 days\nCreate a new column called “discovery_decade” that shows which decade each planet was discovered (e.g., 2000s, 2010s)\n\nHint: You can use integer division: (year // 10) * 10 to get the decade\n\nWhat percentage of all planets were discovered using the “Radial Velocity” method?\n\n\nSolution 10"
  },
  {
    "objectID": "13/exercises_pandas_basics.html",
    "href": "13/exercises_pandas_basics.html",
    "title": "Pandas Basics",
    "section": "",
    "text": "First, let’s import the necessary libraries:",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#setup",
    "href": "13/exercises_pandas_basics.html#setup",
    "title": "Pandas Basics",
    "section": "",
    "text": "First, let’s import the necessary libraries:",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-1-creating-dataframes-from-dictionaries",
    "href": "13/exercises_pandas_basics.html#exercise-1-creating-dataframes-from-dictionaries",
    "title": "Pandas Basics",
    "section": "Exercise 1: Creating DataFrames from dictionaries",
    "text": "Exercise 1: Creating DataFrames from dictionaries\nCreate a pandas DataFrame called elements_df containing information about chemical elements with the following data:\n\nElement names “Hydrogen”, “Helium”, “Lithium”, “Beryllium”, “Boron”\nSymbols “H”, “He”, “Li”, “Be”, “B”\nAtomic numbers 1, 2, 3, 4, 5\nAtomic masses 1.008, 4.003, 6.941, 9.012, 10.81\n\nThe column names should be: “name”, “symbol”, “atomic_number”, “atomic_mass”",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-2-setting-and-using-indices",
    "href": "13/exercises_pandas_basics.html#exercise-2-setting-and-using-indices",
    "title": "Pandas Basics",
    "section": "Exercise 2: Setting and using indices",
    "text": "Exercise 2: Setting and using indices\nUsing the elements_df DataFrame from Exercise 1:\n\nSet the “symbol” column as the index\nAccess the row for “Li” using .loc[]\nExtract just the atomic mass for “He”",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-3-working-with-real-data---tips-dataset",
    "href": "13/exercises_pandas_basics.html#exercise-3-working-with-real-data---tips-dataset",
    "title": "Pandas Basics",
    "section": "Exercise 3: Working with real data - Tips Dataset",
    "text": "Exercise 3: Working with real data - Tips Dataset\nLet’s load a real dataset from an online source. We’ll use the famous “tips” dataset which contains information about restaurant tips.\n\n\n\n\n\n\nUsing the tips_df DataFrame:\n\nDisplay the column names\nDisplay the shape of the DataFrame (number of rows and columns)\nExtract the “total_bill” column\nFind the data type (dtype) of the “day” column\nDisplay the last 8 rows of the DataFrame",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-4-statistical-operations",
    "href": "13/exercises_pandas_basics.html#exercise-4-statistical-operations",
    "title": "Pandas Basics",
    "section": "Exercise 4: Statistical operations",
    "text": "Exercise 4: Statistical operations\nUsing the tips_df DataFrame:\n\nCalculate the mean of the “total_bill” column\nFind the maximum tip amount\nFind the minimum tip amount\nCalculate the standard deviation of the “tip” column\nFind the index (row position) of the maximum total bill\nUse .describe() to get summary statistics for all numeric columns",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-5-arithmetic-operations",
    "href": "13/exercises_pandas_basics.html#exercise-5-arithmetic-operations",
    "title": "Pandas Basics",
    "section": "Exercise 5: Arithmetic operations",
    "text": "Exercise 5: Arithmetic operations\nUsing the tips_df DataFrame:\n\nCreate a new column called “tip_percentage” that calculates the tip as a percentage of the total bill (multiply by 100 to get percentage)\nCreate a new column called “total_cost” that adds the total_bill and tip together\nCalculate the mean tip percentage",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-6-filtering-data-single-conditions",
    "href": "13/exercises_pandas_basics.html#exercise-6-filtering-data-single-conditions",
    "title": "Pandas Basics",
    "section": "Exercise 6: Filtering data (single conditions)",
    "text": "Exercise 6: Filtering data (single conditions)\nUsing the tips_df DataFrame:\n\nFilter to show only rows where the total_bill is greater than 30\nFilter to show only rows where the day is “Sun”\nFilter to show only rows where the tip percentage (from Exercise 5) is greater than 20%\nHow many rows have a total bill greater than 40? (Hint: use .shape or len())",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-7-filtering-with-multiple-conditions",
    "href": "13/exercises_pandas_basics.html#exercise-7-filtering-with-multiple-conditions",
    "title": "Pandas Basics",
    "section": "Exercise 7: Filtering with multiple conditions",
    "text": "Exercise 7: Filtering with multiple conditions\nUsing the tips_df DataFrame:\n\nFilter to show rows where total_bill is greater than 20 and the day is “Sat”\nFilter to show rows where tip is greater than 5 and size (party size) is greater than or equal to 4\nFilter to show rows where the day is “Sat” or the day is “Sun”\nFilter to show rows where total_bill is between 15 and 25 (inclusive)",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-8-working-with-another-dataset---iris",
    "href": "13/exercises_pandas_basics.html#exercise-8-working-with-another-dataset---iris",
    "title": "Pandas Basics",
    "section": "Exercise 8: Working with another dataset - Iris",
    "text": "Exercise 8: Working with another dataset - Iris\nLet’s work with the classic Iris dataset, which contains measurements of iris flowers.\n\n\n\n\n\n\nUsing the iris_df DataFrame:\n\nSet the index to be a range from 1 to the number of rows (so it starts at 1 instead of 0)\nFind how many unique species are in the dataset (Hint: use .unique() or .nunique())\nCalculate the mean sepal_length for all flowers\nFilter to show only the “setosa” species\nFor the “setosa” species, what is the maximum petal_length?\nCreate a new column called “sepal_area” that multiplies sepal_length by sepal_width\nWhich species has the largest average sepal_area? (This requires filtering by each species)",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-9-series-operations",
    "href": "13/exercises_pandas_basics.html#exercise-9-series-operations",
    "title": "Pandas Basics",
    "section": "Exercise 9: Series operations",
    "text": "Exercise 9: Series operations\nCreate two pandas Series and perform operations on them:\n\nCreate a Series called temps_celsius with the following data:\n\nIndex: [“London”, “Paris”, “Berlin”, “Madrid”, “Rome”]\nValues: [15, 18, 14, 22, 24]\n\nCreate a Series called temps_fahrenheit that converts the Celsius temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nCreate a new Series called humidity with the same cities as index and values: [75, 65, 70, 55, 60]\nCalculate the average temperature across all cities (in Celsius)\nFind which city has the highest temperature",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "13/exercises_pandas_basics.html#exercise-10-challenge---planets-dataset",
    "href": "13/exercises_pandas_basics.html#exercise-10-challenge---planets-dataset",
    "title": "Pandas Basics",
    "section": "Exercise 10: Challenge - Planets Dataset",
    "text": "Exercise 10: Challenge - Planets Dataset\nLet’s work with a dataset about planets in our solar system.\n\n\n\n\n\n\nThis dataset contains information about discovered exoplanets (planets outside our solar system).\nChallenge tasks:\n\nHow many planets were discovered in the year 2010?\nWhat is the most common discovery method?\nCalculate the average orbital period for all planets (note: there may be missing values)\nFilter to show planets discovered by the “Transit” method with an orbital period less than 10 days\nCreate a new column called “discovery_decade” that shows which decade each planet was discovered (e.g., 2000s, 2010s)\n\nHint: You can use integer division: (year // 10) * 10 to get the decade\n\nWhat percentage of all planets were discovered using the “Radial Velocity” method?",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas Basics"
    ]
  },
  {
    "objectID": "15/lecture_pandas_plotting.html",
    "href": "15/lecture_pandas_plotting.html",
    "title": "Plotting with pandas",
    "section": "",
    "text": "Pandas provides built-in plotting capabilities that make it easy to visualize data stored in DataFrames and Series. It leverages the matplotlib library under the hood, allowing users to create a variety of plots with minimal code.\nThe framework for plotting is data-centric, meaning that plots are generated directly from the data structures in pandas. This allows for quick and efficient visualization of data without needing to manually extract and format data for plotting.\nCompared to what you have already seen in matplotlib, pandas plotting is often more straightforward and requires less boilerplate code. It means, however, that fine tuning is sometimes less flexible than using matplotlib directly.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Plotting with `pandas`"
    ]
  },
  {
    "objectID": "15/lecture_pandas_plotting.html#plotting-with-series",
    "href": "15/lecture_pandas_plotting.html#plotting-with-series",
    "title": "Plotting with pandas",
    "section": "Plotting with Series",
    "text": "Plotting with Series\nThe basic pandas object is the Series. Series have a .plot() method that can be used to create various types of plots.\n\n\n\n\n\n\nWe notice a few features:\n\nthe plot() method is called directly on the pandas object (in this case, a Series).\nwithout any additional arguments, it defaults to a line plot and it uses:\n\nthe index of the Series for the x-axis,\nthe values of the Series for the y-axis.\n\nlabels are inferred automatically for the axes (in this case the categorical names of the x-axis)\n\nThe .plot() method has various parameters. The most important one is kind, which specifies the type of plot to create. Some common plot types include: - 'line': Line plot (default) - 'bar': Vertical bar plot - 'barh': Horizontal bar plot - 'hist': Histogram - 'box': Box plot - 'scatter': Scatter plot (requires x and y parameters) - 'pie': Pie chart\nOther parameters allow customization of the plot, such as titles, labels, colors, and more.\nLet’s see some examples:\n\n\n\n\n\n\n\n\n\n\n\n\nA box plot is diffeeent is it allows one to view the distribution of the data in a simplified form: it shows the median, quartiles, and potential outliers of the data i a single plot.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Plotting with `pandas`"
    ]
  },
  {
    "objectID": "15/lecture_pandas_plotting.html#plotting-with-dataframes",
    "href": "15/lecture_pandas_plotting.html#plotting-with-dataframes",
    "title": "Plotting with pandas",
    "section": "Plotting with DataFrames",
    "text": "Plotting with DataFrames\nAs we have seen earlier, when working with pandas we typically use Dataframes (i.e. collections of Series). DataFrames also have a .plot() method that can be used to create various types of plots.\nWhen plotting a DataFrame, the default behavior is to plot each column as a separate line (or bar, etc.) on the same axes. The index of the DataFrame is used for the x-axis.\n\n\n\n\n\n\nNotice that we obly had to specify the variable on the x-axis and pandas inferred the res, consructing a legend automatically.\nYou can have more control and specify which columns to plot on the x and y axes using the x and y parameters.\n\n\n\n\n\n\nSuppose we also wanted the data points to be marked with circles, we could use the style parameter:\n\n\n\n\n\n\nAdditional parameters can be used to tune the figure property, e.g. the figure size:",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Plotting with `pandas`"
    ]
  },
  {
    "objectID": "15/lecture_pandas_plotting.html#subplots",
    "href": "15/lecture_pandas_plotting.html#subplots",
    "title": "Plotting with pandas",
    "section": "Subplots",
    "text": "Subplots\nIn matplotlib, one can create multiple axes in a single figure using subplots. Pandas also supports this functionality through the subplots parameter in the .plot() method.\nWhen subplots=True is specified, each column of the DataFrame is plotted in its own subplot.\n\n\n\n\n\n\nWe can specify the structure of the subplot grid using the layout parameter, which takes a tuple indicating the number of rows and columns.\n\n\n\n\n\n\nBut what if we want to refine the individual subplots? For example, we may be unhappy with the labels of the various plots here. We need to store the results of the plotting operation and then modify each axis individually.\nThe result of the .plot() method when subplots=True is an array of matplotlib Axes objects, which can be further customized.\n\n\n\n\n\n\nIt is clear that in this sense, it may be useful to think of good column names when planning to plot data from a DataFrame.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Plotting with `pandas`"
    ]
  },
  {
    "objectID": "15/lecture_pandas_plotting.html#working-with-time-series-data",
    "href": "15/lecture_pandas_plotting.html#working-with-time-series-data",
    "title": "Plotting with pandas",
    "section": "Working with time series data",
    "text": "Working with time series data\n\nWorld population over time\nAs mentioned in the previous chapter, pandas has an exceptional support for time series data. This extends to plotting as well.\nWhen plotting time series data, pandas automatically handles the date formatting on the x-axis, making it easy to visualize trends over time.\nWe are going to see this by using datsets from Our World in Data, an excellent resource for open data on a variety of topics. These are provided as downloadable CSV files that can be easily loaded into pandas DataFrames.\nFor EXAMPLE, let us take the world population data.\n\n\n\n\n\n\nThe dataset contains population estimates for various countries over time (from 10000 BCE to today!). , By default it is simply indexed by row number, so all countries are jumbled together.\nA simple operation we could do would be to filter the data for a specific country, say India, and then plot its population over time.\n\n\n\n\n\n\nWe can also select multiple countries to compare their population growth over time.\nNotice however that we do not have distinct columns for each country, so we cannot use the DataFrame plotting capabilities directly.\nA somewhat cumbersome way is to loop over the countries and plot each one individually on the same axes. for this, we need to store the axes object returned by the first plot call, and then pass it to the subsequent calls.)\n\n\n\n\n\n\nThe plot above is rich: it provides a lot of information, it is tuned to plot only a specific time range and subset of data, it adapts the y-axis to a logarithmic scale to better visualize growth rates, and it includes labels and a legend for clarity.\nHowever, it is a bit complex, withe explicit loops and multiple plot calls.\nThere is a simpler way to achieve the same result by reshaping the DataFrame using the pivot method. This creates a new DataFrame where each country becomes a separate column, making it easier to plot multiple countries at once.\n\n\n\n\n\n\nNow, plotting is straightforward, as we can directly use the DataFrame’s .plot() method to visualize the population of multiple countries over time.\n\n\n\n\n\n\nNotice, however, that we get some broken lines in the data. This is because the pivoting is producing NaN values for years where a country does not have data. By default, pandas does not plot these points, resulting in breaks in the lines.\nThe easy fix is to fill the NaN values, for example via interpolation (which we mentioned previously). This can be done one the fly.\n\n\n\n\n\n\nNotice the structure of the pivoted dataframe\n\n\n\n\n\n\nThe index is now the year, and each column corresponds to a country. This structure is ideal for plotting time series data for multiple entities.\nHowever, at this stage, we are not truly leveraging the datetime capabilties of pandas since the index is still just integers representing years, as it can be easily verified\n\n\n\n\n\n\n\n\nTemperature anomalies - monthly data\nLet us consider a more complex data set where data are provided on a monthly basis.\n\n\n\n\n\n\nHere the data is organised in a very different way: each row corresponds to a specific month and year for a country, and the date information is split across two columns (year and month).\nWhat if we want to plot the time series directly? This seems a bit complicated. Here pandas can come to the rescue.\nWhat we want to do is to create a new dataframe that has a proper datetime index. We can do this by combining the year and month columns into a single datetime column using the pd.to_datetime() function.\nThe startegy is as follows:\n\nWe aim to construct a time stamp in the format YYYY-MM-DD (year-month-day).\nwe extract the year and month columns from the DataFrame, casting them to strings. we assume the day to be the first of each month ('01').\nWe concatenate these strings with hyphens to form a complete date string.\nWe then convert this string to a datetime object using pd.to_datetime().\n\n\n\n\n\n\n\nWe can now set this new datetime column as the index of the DataFrame.\n\n\n\n\n\n\nPlotting should be trivial, shouldn’t it?\n\n\n\n\n\n\nWhat happened? The data is still sorted in the original order (alphabetically by month) we artificially connects the points produce the appearance of multiple jagged lines.\nThe solution is the simply sort the index before plotting.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Plotting with `pandas`"
    ]
  },
  {
    "objectID": "15/lecture_pandas_plotting.html#smoothing-the-data",
    "href": "15/lecture_pandas_plotting.html#smoothing-the-data",
    "title": "Plotting with pandas",
    "section": "Smoothing the data",
    "text": "Smoothing the data\nThe signal from the temperature anomalies is quite noisy. One way to better visualize trends in such data is to apply a smoothing technique, such as a rolling mean.\nA rolling mean (or moving average) computes the average of a specified number of data points (the window) as it moves along the time series. This helps to smooth out short-term fluctuations and highlight longer-term trends.\nPandas focuses our attention on the overall workflow, so operations like smoothing are already built-in and easy to apply.\nThe idea in pandas is that moving averages are a particular case of the more general concept of rolling windows. A rolling window allows us to perform operations on a sliding window of data points.\nFor this, any dataframe or series has a .rolling() method that creates a rolling window object. We can then apply various aggregation functions to this object, such as mean(), sum(), etc.\nLet’see how this works with out temperature anomalies data.\nWe can invoke the .rolling() method on the DataFrame, specifying the window size (e.g., 12 for a 12-month rolling mean). This produces a Rolling object, which, per se, does not contain any data yet.\n\n\n\n\n\n\nTo actually perform a calculation we need to instruct the rolling object to compute something over the selected window. For example, we can call the mean() method to compute the rolling mean. We do this via chaining: we call .mean() directly after .rolling().\nWe do it only on the numerical data we care about (i.e. the temperature anomalies), excluding the non-numerical columns like the Entity (which is the month)\n(Try and change the selection to include the Entity column and see what happens!)\n\n\n\n\n\n\nPlotting can also be chained directly to the rolling mean calculation!\n\n\n\n\n\n\nWe can now produce a richer plot by combining several ideas we have seen in this lecture:\n\nwe can plot the original noisy data on a fustom figure with specific size and labels\nwe can overlay the smoothed data (rolling mean) on top of the original data for comparison at different levels of smoothing",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Plotting with `pandas`"
    ]
  },
  {
    "objectID": "15/lecture_pandas_plotting.html#saving-the-results",
    "href": "15/lecture_pandas_plotting.html#saving-the-results",
    "title": "Plotting with pandas",
    "section": "Saving the results",
    "text": "Saving the results\nFinally, once we are happy with our plots, we may want to save them to files for later use or sharing. Pandas plotting returns a matplotlib Axes object, which can be used to save the figure using matplotlib’s savefig() function.\nThere are a couple of ways.\nA first way is to use solely the axis object returned by the plot call. From the axis, we can get the figure using the .figure attribute, and then call .savefig() on it. In this case, we only use pandas.\n\n\n\n\n\n\nAlternatively, we can import matplotlib.pyplot and use its savefig() function directly, passing the figure obtained from the axis object. This approach combines both pandas and matplotlib.\n\n\n\n\n\n\nThis is a hint to a more general principle: since pandas plotting is built on top of matplotlib, any plot created with pandas can be further customized and manipulated using matplotlib functions and methods. This allows for greater flexibility and control over the final appearance of the plots.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Plotting with `pandas`"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html",
    "href": "15/exercises_pandas_plotting.html",
    "title": "Deforestation Data",
    "section": "",
    "text": "We use the Our World in Data deforestation dataset.\nIt contains data on forest area and deforestation data for various countries over time.\nIts link is\nhttps://ourworldindata.org/grapher/annual-deforestation.csv?v=1&csvType=full&useColumnShortNames=false",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-1-loading-and-pivoting-the-data",
    "href": "15/exercises_pandas_plotting.html#exercise-1-loading-and-pivoting-the-data",
    "title": "Deforestation Data",
    "section": "Exercise 1: Loading and pivoting the data",
    "text": "Exercise 1: Loading and pivoting the data\nRead in the dataset using pandas.\nThen, pivot the data so that you have years as the index, countries as the columns, and deforestation as the values.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-2-plotting-deforestation-for-regions",
    "href": "15/exercises_pandas_plotting.html#exercise-2-plotting-deforestation-for-regions",
    "title": "Deforestation Data",
    "section": "Exercise 2 : Plotting deforestation for regions",
    "text": "Exercise 2 : Plotting deforestation for regions\nThe datasets contains rates in ha/year (hectares per year) for many different countries, as well as the various regions including the world as a whole.\nFind the names of such regions in the dataset and create a plot with multiple lines, one for each region, showing deforestation over time. Include also the world as a whole.\nPlot requirements:\n\nThe plot should have appropriate labels and a legend.\nThe lines should also have markers.\nThe lines should be distinguishable by color and line style.\nThe line for the World should be thicker than the others.\nThe deforestation values should be shown in millions of hectares per year (i.e., divide the values by 1,000,000).\n\nNotes. - If you look carefully at the original dataset, you will notice that you have a Code column that contains codes for countries and regions. - You can provide a list of styles to the style argument of the plot method to have different line styles for each line. - If ax is an axis returned by a plot object, you can access its last plotted line as ax.lines[-1] and sets its properties with methods such as set_linewidth() or set_color().",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-3-share-of-deforestation-by-continent-in-2020",
    "href": "15/exercises_pandas_plotting.html#exercise-3-share-of-deforestation-by-continent-in-2020",
    "title": "Deforestation Data",
    "section": "Exercise 3 : Share of deforestation by continent in 2020",
    "text": "Exercise 3 : Share of deforestation by continent in 2020\nPick now year 2020 and create a pie chart showing the share of deforestation for that year between the various continents (i.e., Africa, Asia, Europe, North America, Oceania, South America). The share is the fraction of the total deforestation in the world that is due to each continent.\nNotes.\n\nYou can improve the rendering of the pie chart by adding formatted percentage labels with the autopct to plot using the pie kind.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-4-stacked-area-plot-of-regional-deforestation",
    "href": "15/exercises_pandas_plotting.html#exercise-4-stacked-area-plot-of-regional-deforestation",
    "title": "Deforestation Data",
    "section": "Exercise 4: Stacked area plot of regional deforestation",
    "text": "Exercise 4: Stacked area plot of regional deforestation\nCreate a stacked area plot showing how deforestation is distributed across continents over time (1990-2020).\nRequirements: - Use only the continental regions (Africa, Asia, Europe, North America, Oceania, South America) - Show values in millions of hectares per year - Only include positive values (deforestation, not reforestation) - Add appropriate title and labels\nHint: Use kind='area' and set stacked=True.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-5-bar-plot-of-top-10-countries-with-highest-deforestation-in-2010",
    "href": "15/exercises_pandas_plotting.html#exercise-5-bar-plot-of-top-10-countries-with-highest-deforestation-in-2010",
    "title": "Deforestation Data",
    "section": "Exercise 5: Bar plot of top 10 countries with highest deforestation in 2010",
    "text": "Exercise 5: Bar plot of top 10 countries with highest deforestation in 2010\nUsing the data for 2010, create a bar plot showing the top 10 countries with the highest deforestation rates in absolute terms.\nPlot them so that they are sorted (ascending or descending, as you prefer).\nYou need to exclude regions and only consider countries.\nNote. - Boolean operators can be used to filter dataframes. For example, if we want to filter a dataframe to include only rows where the column A doe not contain the value foo, we can do:\nfiltered_df = df[~(df['A'] == 'foo')]\nwhere the ~ operator negates the boolean condition. - You can use barh as the kind of plot to create horizontal bar plots.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-6-merging-datasets-and-normalisation-by-area",
    "href": "15/exercises_pandas_plotting.html#exercise-6-merging-datasets-and-normalisation-by-area",
    "title": "Deforestation Data",
    "section": "Exercise 6: Merging datasets and normalisation by area",
    "text": "Exercise 6: Merging datasets and normalisation by area\nThe comparison above is in part unfair because countries have different sizes (and hence extent of forested surfaces).\nAs a first approximation, we can normalise deforestation rates by the total area of each country.\nTo retrieve the total area data for countries, you’ll need to load a CSV file containing country areas. We can use the Our World in Data dataset on land area.\nHere’s the link to the dataset:\nhttps://ourworldindata.org/grapher/land-area-km.csv\nWe can read this second dataset into a separate dataframe.\nA powerful feature of pandas is the ability to merge dataframes based on common columns.\nThis is done using the pd.merge function as follows:\nmerged_df = pd.merge(df1, df2, on=list_of_common_columns)\nUsing merging, combine the deforestation data for 2010 with the land area data.\nThen, create a new column in the merged dataframe that contains the deforestation rate per square kilometer for each country.\nFinally, create a bar plot showing the top 10 countries with the highest deforestation rates per square kilometer in 2010.\nNotes.\n\nWhen merging, provide a list of common columns to the on argument. In this case, the common columns are likely to be Entity, Year and Code.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-7-bringing-vegetable-oil-data-in",
    "href": "15/exercises_pandas_plotting.html#exercise-7-bringing-vegetable-oil-data-in",
    "title": "Deforestation Data",
    "section": "Exercise 7: Bringing vegetable oil data in",
    "text": "Exercise 7: Bringing vegetable oil data in\nWe can further extend our analysis by bringing in data on vegetable oil production, which is a significant driver of deforestation in some regions.\nFirst, we load the vegetable oil production dataset from Our World in Data, which contains production data for various types of oils (palm oil, soybean oil, sunflower oil, etc.).\n\n\n\n\n\n\nSince deforestation is driven by various oil crops (not just palm oil), sum all vegetable oil production types to get a total for each country and year and store it as a new column. This provides a more comprehensive view of agricultural oil pressure.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-8-pivot-by-country-the-vegetable-oil-data",
    "href": "15/exercises_pandas_plotting.html#exercise-8-pivot-by-country-the-vegetable-oil-data",
    "title": "Deforestation Data",
    "section": "Exercise 8: Pivot by country the vegetable oil data",
    "text": "Exercise 8: Pivot by country the vegetable oil data\nTo get a by country view of vegetable oil production, pivot the vegetable oil dataset so that you have years as the index, countries as the columns, and total vegetable oil production as the values.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-9-select-countries-for-comparison",
    "href": "15/exercises_pandas_plotting.html#exercise-9-select-countries-for-comparison",
    "title": "Deforestation Data",
    "section": "Exercise 9: Select countries for comparison",
    "text": "Exercise 9: Select countries for comparison\nFilter to include only countries that appear in both the top 10 deforestation list (from 2010, Exercise 5) AND have oil production data.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-10-plot-vegetable-oil-production-over-time-for-selected-countries",
    "href": "15/exercises_pandas_plotting.html#exercise-10-plot-vegetable-oil-production-over-time-for-selected-countries",
    "title": "Deforestation Data",
    "section": "Exercise 10: Plot vegetable oil production over time for selected countries",
    "text": "Exercise 10: Plot vegetable oil production over time for selected countries\nWe normalize all oil production values relative to 1990 (baseline = 100) to make it easier to compare growth rates across countries of different sizes.\nProduce two plots:\n\nfirst the normalised vegetable oil production over time for the selected countries\nthen a smoothened version of the same plot (using a rolling mean with a window of 10 years).",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#exercise-11-comparing-deforestation-and-oil-production-over-time",
    "href": "15/exercises_pandas_plotting.html#exercise-11-comparing-deforestation-and-oil-production-over-time",
    "title": "Deforestation Data",
    "section": "Exercise 11: Comparing deforestation and oil production over time",
    "text": "Exercise 11: Comparing deforestation and oil production over time\nFor each of the following countries (Brazil, the Democratic Republic of Congo, India and Indonesia) plot a figure with the two lines:\n\nthe normalised vegetable oil production over time (use the smoothed version from Exercise 10)\nthe deforestation rate over time (also normalised to 1990)\n\nBoth lines should be on the same plot with the same y-axis scale (since both use 1990 = 100 as baseline).\nNote: You may observe inverse correlations in some countries - this is expected and scientifically meaningful (see interpretation below).\nHints.\n\nYou may need to drop NaN values with the dropna() method to get continuous lines\nYou need first to normalise your deforestation data\nYou may want to create a new dataframe using pd.DataFrame and a suitable dictionary",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "15/exercises_pandas_plotting.html#interpretation-of-results",
    "href": "15/exercises_pandas_plotting.html#interpretation-of-results",
    "title": "Deforestation Data",
    "section": "Interpretation of Results",
    "text": "Interpretation of Results\nYou should observe different trends depending on the countries of consideration that can reflect different modes of production, deforestation and shifts in policies:\n\nSome countries show correlations between deforestation rates and vegetable oil production: this is typically when vegetable oil production requires direct area increases and deforestation is diffuse (small-scale clearing of land)\nOther countries can show inverse correlation: this can have various causes, for example time-lags between extensive deforestation and usage of the land, as well as different means of expanding vegetable oil production (conversion of already cleared land, e.g. pasture, into crops)\n\nThis exercise demonstrates that macroscale data analysis can be rather complex and requires multiple layers of information and datasets to be properly interpreted. In this specific case, we would need more information on the modes of production, land use changes, policies and economic drivers to make sense of the observed trends.",
    "crumbs": [
      "Home",
      "15 Plotting with `pandas`",
      "Deforestation Data"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html",
    "href": "01/week_01_intro_to_data_types_advanced.html",
    "title": "Advanced: Copying and References",
    "section": "",
    "text": "Welcome to the Week 1 Advanced Python Notebook. This notebook is designed for students who already have substantial experience with Python and feel confident working with both the Beginner and Intermediate material.\nYour task today is to carefully read through the content and complete the exercises at the end. These exercises are more challenging and are intended to deepen your understanding of how Python handles data behind the scenes.\nIn this notebook, you will explore the critical differences between immutable and mutable data types in Python. Specifically, you will learn how Python handles copying and references, which can be critical knowledge when it comes to debugging complex code.\nWork through the examples carefully, and take your time with the exercises. They are designed to stretch your understanding and prepare you for advanced applications of Python.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#immutable-vs-mutable",
    "href": "01/week_01_intro_to_data_types_advanced.html#immutable-vs-mutable",
    "title": "Advanced: Copying and References",
    "section": "Immutable vs Mutable",
    "text": "Immutable vs Mutable\nIn Python, all data types can be described as either “immutable” or “mutable”.\nTo understand the difference between “immutable” and “mutable” types, it may be useful to introduce the notion of a reference. You can think of a reference as an address which tells us where some data lives physically on a machine. When we talk about variables, we really are talking about reference’s (which we have named) that point us to some data in memory.\nWhen you reassign the value of a variable in your code, there are actually two possible things that could be happening. The reference could be changed (i.e. the variable now represents a different place in memory), or the data itself could be changed (i.e. the variable is still “looking” at the same location in memory, but the data that is stored there has changed).\nWhat is important to know here is that when you change the value of a variable which has an “immutable” data type you are changing a reference whereas when you are changing “mutable” variables you are changing the data itself. Examples of mutable data types in Python include the list, dictionary and the set. On the other hand, examples of immutable data types are given by the int, float, decimal, bool and the tuple. In general, the more complicated data types discussed so far are “mutable”.\nThe distinction between a data type being “mutable” or “immutable” may seem dull and/or trivial but, in practice, can result in some very unexpected behaviour, especially when multiple variables are using the same reference (i.e. “looking” at the same place in memory)!\nFor example, in the below code we may expect a and b to have different values:\n\n\n\n\n\n\nAnd they do! However, if we change a from being 7 to a list containing 7, perhaps surprisingly, changing the value of a also changes the value b!\n\n\n\n\n\n\nIn both the examples above, we start by assigning a and b as references to the same location in memory.\nIn the first example, when we assign a=10, we are telling Python that a must change where it is “looking” in the computers memory. This does not have any effect on the value of b.\nIn the second example, however, when we assign a[0]=10, we are telling Python that the data stored in the location which a is “looking” at at must be changed. As b is also “looking” at this location in memory, this does have an effect on the value of b. It has changed!\nIt is worth noting though that if an operation is performed then a copy might be made:\n\n\n\n\n\n\nIn this case, to ensure we are working with a copy of a and not just a reference to the same variable, we can use the list constructor (see below).\n\nNote: In this case a is a list so we use the list constructor. For other datatypes similar constructors exist and would be used in this situation (e.g. set, dict, etc…).\n\n\n\n\n\n\n\n\nWarning: Errors of this type can often cause extremely anti-intuitive behaviour, including unexpected interactions between functions.\nFor example, in the below a function is called on a variable b, yet a seemingly unrelated variable a was affected by calling the function. This is because a and b were both references to the same object in memory, as oppose to being distinct copies of the object.\nIf you are not familiar with functions, do not worry; these will be covered in depth later in the course and, for now, move past this example.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#the-id-function",
    "href": "01/week_01_intro_to_data_types_advanced.html#the-id-function",
    "title": "Advanced: Copying and References",
    "section": "The id() Function",
    "text": "The id() Function\nNow that we understand the difference between mutable and immutable types, let’s take a look at the Python id() function, which can help us visualise what is happening with references and memory locations.\nThe id() function returns the unique identifier (memory address) of an object. This identifier tells us exactly where some data lives physically on a machine - essentially showing us the reference that a variable is pointing to.\n\n\n\n\n\n\nWith immutable data types, when you reassign a variable, you are changing the reference (the variable now points to a different location in memory). Let’s see this with our integer example:\n\n\n\n\n\n\nWith mutable data types, when you modify the data, you are changing the data itself (the reference stays the same - the variable is still “looking” at the same location in memory). Let’s reproduce our list example:",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#the-is-operator",
    "href": "01/week_01_intro_to_data_types_advanced.html#the-is-operator",
    "title": "Advanced: Copying and References",
    "section": "The is Operator",
    "text": "The is Operator\nThe is operator and == operator are often confused with one another but they are not same. The is checks if both the variables point to the same object in memory whereas the == sign checks if the values of the two variables are equal.\nIf the is operator returns True then the equality is definitely True, but the opposite may or may not be the case. For an example see the below.\n\nWarning: Avoid using the is operator for “immutable” types such as strings and numbers; the result is unpredictable and in most cases the == is more appropriate for purpose.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_advanced.html#exercises",
    "href": "01/week_01_intro_to_data_types_advanced.html#exercises",
    "title": "Advanced: Copying and References",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Predict the output of the following code. What will be printed and why?\nlist_a = [1, 2, 3]\nlist_b = list_a\nlist_a.append(4)\nprint(list_b)\nRun the code in the box below to verify your answer.\n\n\n\n\n\n\nQuestion 2: Consider these two similar-looking pieces of code. Predict what each will output and explain the difference:\nCode A:\na = [1, 2, 3]\nb = a\na = [4, 5, 6]\nprint(b)\nCode B:\na = [1, 2, 3]\nb = a\na[0] = 4\na[1] = 5\na[2] = 6\nprint(b)\nRun the code above to verify your answers.\n\n\n\n\n\n\nQuestion 3: In the below we have a list of 3 values, x=1, y=2 and z=3. We want to work out the value of:\n\n\\(x + y + z + x^2 + y^2 + z^2\\) \\(= 1 + 2 + 3 + 1 + 4 + 9\\) \\(= 20\\)\n\nThe below code should give us \\(20\\) as an answer… but it doesn’t - something has gone wrong! Can you see what is wrong in the below code? How would you fix it?\n\n\n\n\n\n\nQuestion 4: You have a list of lists representing a grid. You want to create a backup copy before making changes, but the following approach doesn’t work correctly. Explain what has gone wrong here.\n\n\n\n\n\n\nQuestion 5: The following code creates a 3x3 grid filled with zeros, but when you try to modify one cell, unexpected behavior occurs. Identify the problem and provide a solution:",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Advanced: Copying and References"
    ]
  },
  {
    "objectID": "01/exercises_intro.html",
    "href": "01/exercises_intro.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nIntro to Data Types - Exercises\nThe following exercises serve as self-assessment of your prior knowledge.\nExplore them to discover, recall or deepen your knowledge of basic Python structures and constructs.\n\nBeginner\nIntermediate\nAdvanced\n\nThere is no requirement to succeed at all of them. Come back to these over time to check the progression of your understanding."
  },
  {
    "objectID": "01/week_01_slides.html#todays-lecture",
    "href": "01/week_01_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 1: Introduction and Data Types\n\nCourse Structure\nSetting up Noteable\nIntroduction to Coding\nData Types\nPractical"
  },
  {
    "objectID": "01/week_01_slides.html#course-structure",
    "href": "01/week_01_slides.html#course-structure",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Course Structure",
    "text": "Course Structure\n\nThis course will run for 20 weeks\nWe will cover:\n\nData types, conditionals and loops\nBuilding functions\nNumpy arrays and linear algebra in python\nPandas dataframes\nPlotting and visualisation\n\nClasses:\n\n1 lecture per week (Thursday)\n1 small-group tutorial per two weeks (date should be on calendar)"
  },
  {
    "objectID": "01/week_01_slides.html#lectures",
    "href": "01/week_01_slides.html#lectures",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Lectures",
    "text": "Lectures\n\nThe weekly lecture will consist of\n\n≈ 30-40 minutes presentation time covering:\nKey concepts\nAdministrative points (e.g. homework submission etc)\nCode Demonstrations#\n\n≈ 1-1.5 hours practical\nDesigned to provide hands on experience\nOpportunity to ask for help from\n\nLecturer\nPhD helpers\nEach other!"
  },
  {
    "objectID": "01/week_01_slides.html#assignments",
    "href": "01/week_01_slides.html#assignments",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Assignments",
    "text": "Assignments\n\nFormative:\n\nWeekly (optional) assignments available on quarto\n\nSummative:\n\nThis module is 100% coursework\n4 pieces of coursework\nAssignment 1 (15%)\nAssignment 2 (30%)\nAssignment 3 (15%)\nAssignment 4 (40%)\n\nAssignments 1-3 will be exercises\nAssignment 4 will be different\n\nProject report analysing a dataset"
  },
  {
    "objectID": "01/week_01_slides.html#online-material",
    "href": "01/week_01_slides.html#online-material",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Online Material",
    "text": "Online Material\n\nThe course material is available online via:\n\nQuarto – online searchable version\nNoteable – interactive interface we shall work in during class"
  },
  {
    "objectID": "01/week_01_slides.html#accessing-noteable",
    "href": "01/week_01_slides.html#accessing-noteable",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Accessing Noteable",
    "text": "Accessing Noteable\n\nOpen Blackboard\nGo to Introduction to Coding and Data Analysis for Scientists 2025\nClick Unit Information and Resources\nOpen Noteable\n\nMake sure Jupyter Classic (Legacy) is selected.\nClick Start\n\nClick +GitRepo\nPaste into Git Repository URL: git@github.com:TomMaullin/SCIF10002-2025.git\nPress clone"
  },
  {
    "objectID": "01/week_01_slides.html#introduction-to-coding",
    "href": "01/week_01_slides.html#introduction-to-coding",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Introduction to Coding",
    "text": "Introduction to Coding\n\nIn this module, we shall be learning to code in Python\nPython is a programming language\n\n\n\nIn the same way humans communicate using different languages, there are many languages we can use to communicate with a computer\nPython is particularly useful for:\n\nAnalysing data\nMaking plots and visualisations\nRunning simulations\nMachine learning and AI"
  },
  {
    "objectID": "01/week_01_slides.html#learning-to-code",
    "href": "01/week_01_slides.html#learning-to-code",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Learning to Code",
    "text": "Learning to Code\n\nIn fact, learning to code is a lot like learning a language\nWhen learning French, you might:\n\nLearn many phrases\nPractice writing sentences\nSpeak to people who know the language\n\nYou can’t learn a language by listening to other people describe it…\nHands-on experience and regular practice are crucial!"
  },
  {
    "objectID": "01/week_01_slides.html#getting-started",
    "href": "01/week_01_slides.html#getting-started",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Getting Started",
    "text": "Getting Started\n\nSo… what actually is coding?\nYou can think of writing code as like writing a recipe…\n\nYou might start by specifying some ingredients…\nThen list some instructions…\nTo get a desired output\n\nCoding is pretty similar"
  },
  {
    "objectID": "01/week_01_slides.html#getting-started-1",
    "href": "01/week_01_slides.html#getting-started-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Getting Started",
    "text": "Getting Started\n\nYou might start by specifying some inputs…\nThen list some instructions…\nTo get a desired output\n\n\n\n\n\n\n\nHere we are producing some output that might be difficult to compute or evaluate by hand."
  },
  {
    "objectID": "01/week_01_slides.html#assigning-variables",
    "href": "01/week_01_slides.html#assigning-variables",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Assigning Variables",
    "text": "Assigning Variables\n\n\n\n\n\n\n\nIn this code, x and y are variables\nThese are named pieces of data which we can use for future computations\nThe = symbol is the assignment operator.\n\nUnlike in maths, this is an instruction\nE.g. x=7 means “Save the integer 7 under the variable name x”"
  },
  {
    "objectID": "01/week_01_slides.html#data-types",
    "href": "01/week_01_slides.html#data-types",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Data Types",
    "text": "Data Types\n\n\n\n\n\n\n\nWhen writing the recipe, some foods were of the “same type”\n\nE.g. we had 2 eggs\n\nIn the same way, in coding we have different types of data\nToday, we shall look at some of these\nUnderstanding data types is important, as we want to use different data types for different tasks"
  },
  {
    "objectID": "01/week_01_slides.html#numeric-data-types",
    "href": "01/week_01_slides.html#numeric-data-types",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Numeric Data Types",
    "text": "Numeric Data Types\n\n\n\n\n\n\n\nThe most ubiquitous data types are numeric\n\nIntegers: Whole numbers/Integers\nℤ = {…, -3, -2, -1, 0, 1, 2, 3,… }\n\nFloats: Decimal numbers\n\nℝ = Real numbers\nWe can convert between float’s and integers using the float and int functions.\n\nWhat do you think might happen if we convert y to an integer?\n\nWarning: A computer cannot actually describe arbitrarily small and large numbers – it approximates instead"
  },
  {
    "objectID": "01/week_01_slides.html#strings",
    "href": "01/week_01_slides.html#strings",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Strings",
    "text": "Strings\n\nA string is a sequence of characters. Strings can contain:\n\nLetters\nNumbers (treated as characters)\nPunctuation\nSpaces\nCombinations of the above\nNothing at all\n\n\n\n\n\n\n\n\n\nIn practice, there are many things we may want to do with text in Python\n\nSplit it into sentences\nSearch through it\nReplace words\n\n\nAfter todays practical you will be able to perform some of these operations!"
  },
  {
    "objectID": "01/week_01_slides.html#booleans",
    "href": "01/week_01_slides.html#booleans",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Booleans",
    "text": "Booleans\n\nA Boolean is variable that can be either True or False\nBooleans represent logical statements.\nFor instance, we might think of:\n\ncat_is_black as representing the sentence “The cat is black”\ncat_has_four_legs as representing the sentence “The cat has four legs”\n\nWe can use logical operators to combine Boolean statements\n\ncat_is_black and cat_has_four_legs represents the sentence “The cat is black and has four legs”"
  },
  {
    "objectID": "01/week_01_slides.html#booleans-1",
    "href": "01/week_01_slides.html#booleans-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Booleans",
    "text": "Booleans"
  },
  {
    "objectID": "01/week_01_slides.html#collections",
    "href": "01/week_01_slides.html#collections",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Collections",
    "text": "Collections\n\nWe’ve now seen some simple examples of datatypes:\n\nNumeric, strings, and booleans.\n\nData types don’t always have to be this simple!\n\nSometimes we need data types that can hold more complex information.\n\nWe’ll see more examples throughout the course but for now we’ll provide just one\nA collection is any in-built data type that can group multiple objects together.\nThe most common collection is a list: an ordered group of items.\n\nLists let you store, organize, and work with many values at once."
  },
  {
    "objectID": "01/week_01_slides.html#practical",
    "href": "01/week_01_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe have students from a range of courses and backgrounds in this class\n\nChemistry\nPhysics\nData Science\n\nSome people in the room will have less experience than others\nFor the first few weeks, we shall try to account for the differences in ability where possible"
  },
  {
    "objectID": "01/week_01_slides.html#practical-1",
    "href": "01/week_01_slides.html#practical-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_01_home.ipynb\nFor the rest of today, you must work through a Python notebook\nYou have a choice of one of three options\n\nOption 1: Beginner - Basic Data Types\nOption 2: Intermediate - Collections\nOption 3: Advanced - Copying and References"
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html",
    "href": "01/week_01_intro_to_data_types_beginner.html",
    "title": "Beginner: Basic Data Types",
    "section": "",
    "text": "Welcome to the Week 1 Beginner Python Notebook. This notebook is designed for students who are just starting out with the Python programming language.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.\nIn this notebook, you will be introduced to the numeric, boolean, and string Python data types. Gaining experience with these data types is essential, as they form the foundation for everything else you will learn in Python.\nBe sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#what-are-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#what-are-data-types",
    "title": "Beginner: Basic Data Types",
    "section": "What are Data Types?",
    "text": "What are Data Types?\nWriting code is a lot like writing a recipe for cooking. When writing a recipe, you might first list some ingredients, then give a careful sequence of steps, with the end result being some tasty and (hopefully!) digestible baked goods. Coding works the same way; we start with some inputs (the ingredients), ask the computer to perform a series of steps and produce some easy-to-digest result (the outputs).\nIn the same way that ingredients can be referred to as objects in the real-world, we refer to the data we use in coding as objects too.\nFurthermore, when cooking we might refer to objects by types of food. For instance, we may want to use 2 apples and an orange in a recipe, as opposed to 3 generic “food-objects”. Similarly, when coding we refer to types of data, or data types.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#basic-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#basic-data-types",
    "title": "Beginner: Basic Data Types",
    "section": "Basic Data Types",
    "text": "Basic Data Types\nIn Python there are many different data types with some of the most commonly used built-in data types being:\n\ninteger and floating point scalars\nboolean values\nstrings\ntuples\nlists\nsets\ndictionaries\n\n\nNote: This list is by no means comprehensive. Other data types are also supported through common packages (e.g., numpy, scipy, ...) and it is even possible to make your own custom datatypes! For now we will just focus on the built-in datatypes. However, packages such as numpy and pandas will be explored in later notebooks.\n\nThe “type” of a variable can be found using the type() function in python. Try changing and running the below code to see how this function is used.\n\n\n\n\n\n\nIn the above code, a, b, …, g are variables. A variable is a named reference to a piece of data, created using the = (assignment) operator. The type of a variable describes the kind of data it stores. For example, a stores an integer (a whole number), so its type is int.\n\nNote: Python allows for scientific notation for floats (decimal numbers). For example, in the above code 1.1e-6 means 1.1 times 10 to the minus 6.\n\nValues of variables can also be displayed with the print() function. If given many arguments, the print statement will print all of them. Try this below:\n\n\n\n\n\n\nBy default, a Jupyter notebook will treat the last line of a code box as a print statement if it can.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#integers-and-floats",
    "href": "01/week_01_intro_to_data_types_beginner.html#integers-and-floats",
    "title": "Beginner: Basic Data Types",
    "section": "Integers and floats",
    "text": "Integers and floats\nWhen first getting to grips with python, you can think of integers as “whole numbers” and floats as “numbers including decimals”. Integers are represented with the int datatype and floats are represented with the float datatype. Basic mathematical operations are available for int types and float types. Try a few below:\n\nWarning: A common mistake made by new users of Python is to use ^ for exponentiation (e.g. \\(2^5\\)). In fact, in Python ^ represents the logical XOR operator and the ** operator represents exponentiation. By performing your own research online, see if you can work out what the XOR function is doing here.\n\n\n\n\n\n\n\nYou can combine operations using round brackets, ( and ), much in the same way you would in everyday math. For example:\n\n\n\n\n\n\nOften, you may hear it mentioned that Python allows for arbitrary precision integers. This means that Python can accurately manipulate very large numbers stored as ints. For example;\n\n\n\n\n\n\n\nWarning: Although ints can store arbitrary precision whole numbers in Python, floats cannot!! Failure to realize this can result in all sorts of strange errors. For example, consider the below;\n\n\n\n\n\n\n\n\nCheck your understanding: What’s the difference between / and //? Why might 3 * 0.1 not equal 0.3 exactly in Python?",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#strings",
    "href": "01/week_01_intro_to_data_types_beginner.html#strings",
    "title": "Beginner: Basic Data Types",
    "section": "Strings",
    "text": "Strings\nIn this section we are going to look more at strings.\nA string is a finite sequence of characters (e.g., letters, numbers, symbols and punctuation marks). In python, strings can be specified with either double of single quotes like so:\n\n\n\n\n\n\nAn important characteristic of each string is its length, which is the number of characters in it. The length can be any natural number (i.e., zero or any positive integer). In python we can see the length of a string by using the len() function. In fact, this function can be used to assess the length of many different variable types such as lists, tuples, sets and so on (more on those later).\n\n\n\n\n\n\n\nBrief interlude: In Python, you can add comments to your code using the # symbol. Comments are lines of text that are ignored when the code runs, but they play an important role in explaining what your code is doing. Writing clear and meaningful comments as you code is considered best practice. It helps others (and your future self) understand your logic and what you are trying to do. Below is a simple example that shows how to use comments in Python. Make sure you are comfortable with this, as commenting is a crucial habit for anyone working with code.\n\n\n\n\n\n\n\n\nCheck your understanding: What is the difference between print(2 + 3) and print(\"2\" + \"3\")? What happens if you try x = \"hello\" + 5? Using the below box, write some code to answer these questions.\n\n\n\n\n\n\n\n\nString manipulation\nPython has many useful tools for manipulating strings. One such function is the format function, which allows you to insert variables of different types into strings. Note that x in the below example does not need to be a string.\n\n\n\n\n\n\nAnother useful tool is the concatenation operater; +. Concatenation in programming is another way for saying “join together”. See the below for an example of how this is done.\n\n\n\n\n\n\nIn fact, the previous example could be done using concatenation instead of the format funtion. Note though that we must be careful and convert x from an integer to a string, using str(), in this case.\n\n\n\n\n\n\nOther useful functions for string manipulation include\n\nstrip; which, by default, removes any white space from the beginning and end of a string. However, you can also specify which characters you wish to remove.\nsplit; splits a string by specified character (known as a seperator), and returns a list. By default, the separator is a space and this function splits a sentence into individual words.\nreplace; this returns a string with some specified value replaced with another specified value.\nupper; this makes a string all uppercase.\nlower; this makes a string all lowercase.\n\nSeveral examples are given below. Please make sure you understand what each of these functions does before moving on to the next section. There are many other functions available and a good resource for learning about each individual function and trying them for yourself is the w3 schools python reference site.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#booleans",
    "href": "01/week_01_intro_to_data_types_beginner.html#booleans",
    "title": "Beginner: Basic Data Types",
    "section": "Booleans",
    "text": "Booleans\nA boolean in python is a variable that can be either True or False. For instance:\n\n\n\n\n\n\nBooleans arise in all sorts of situations. For example, consider the below code:\n\n\n\n\n\n\nYou should see it print True, which makes sense as 128 is indeed larger than 100. Try changing the numbers above; can you make this print False?\nIn this code, the expression 128 &gt; 100 is a boolean statement. We can make this clearer like so:\n\n\n\n\n\n\nThe above code is identical to the previous, but we have now saved the True/False value as my_boolean.\nSome common boolean operators include:\n\nnot: This negates the value of a variable (i.e. turns True to False and False to True).\nand: This is a logical and.\nor: This is a logical or.\nis: This checks whether two variables point to the same object in memory.\n==: This checks whether two variables are equal in value (Note: This shouldn’t be confused for the assigment operator; =).\n!=: This checks whether two variables are not equal in value.\n\nBoolean operators in Python are designed to be intuitive and as close to natural language as possible. The below code demonstrates how the boolean operations and, or, == and != and not are used. Try changing the values of a and b to ensure you understand how these operations work.\n\n\n\n\n\n\nOther common relational expressions which give True/False output include &lt;=, &gt;=, &lt; and &gt; for numeric datatypes (e.g. ints and floats) and in for collection datatypes (such as lists or tuples, which we shall look at next).",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#casting-between-data-types",
    "href": "01/week_01_intro_to_data_types_beginner.html#casting-between-data-types",
    "title": "Beginner: Basic Data Types",
    "section": "Casting Between Data Types",
    "text": "Casting Between Data Types\nIn Python the data type of a variable is dynamic. This means that you do not need to specify the data type beforehand and that it can easily be changed. For example, try moving the type statement before and after the sum in the below block and see how the output is changed. Why does the output change?\n\n\n\n\n\n\nSeveral inbuilt functions are available for converting between types. The most commonly used of these are the int, float and str functions. Try these out below. Caution: Note how converting z back to a float does not give the original value x. Why do you think this is?\n\n\n\n\n\n\nThe act of converting one data type to another is often referred to as casting. For instance, in the above code, we cast x from a float to a string and then from a string to an integer.\n\nCheck your Understanding: What happens if you try int(\"10.5\")? Why might you convert a number to a string using str()? Use the below code box to answer these questions.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_beginner.html#exercises",
    "href": "01/week_01_intro_to_data_types_beginner.html#exercises",
    "title": "Beginner: Basic Data Types",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Below are three variables x, y and z. By using the operators introduced in the Booleans section of this notebook, construct a boolean variable, my_boolean which is true if and only if \\(y\\) lies strictly between \\(x^2\\) and \\(z^3\\). That is, my_boolean should be true if and only if either \\(x^2&lt;y&lt;z^3\\) or \\(z^3&lt;y&lt;x^2\\).\n\n\n\n\n\n\nQuestion 2: In the below code, we have two boolean variables; is_raining and have_umbrella. We will assume that these represent the sentences “It is raining outside” and “I have my umbrella with me”, respectively.\n\n\n\n\n\n\nWe will assume that you are going to get wet if and only if it is raining outside and you do not have your umbrella. Using logical operators (e.g. and, or, not…), make a new boolean variable that tells you if you are going to get wet.\n\n\n\n\n\n\nQuestion 3: In this question, we are interested in three boolean variables A, B and C. By performing your own research online, write down (on paper) a “Truth Table” for the expression (A and B) or (not C). Your table should have the following columns:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\n\n\n\n\n\nTrue\nTrue\nFalse\n\n\n\n\n\nTrue\nFalse\nTrue\n\n\n\n\n\nTrue\nFalse\nFalse\n\n\n\n\n\nFalse\nTrue\nTrue\n\n\n\n\n\nFalse\nTrue\nFalse\n\n\n\n\n\nFalse\nFalse\nTrue\n\n\n\n\n\nFalse\nFalse\nFalse\n\n\n\n\n\n\nIn the following box, write some code which computes (A and B) or (not C). By changing the values of A, B and C check the correctness of your truth table.\n\n\n\n\n\n\nQuestion 4: Below are two variables representing the width and height of a rectangle. Write some code that computes the area, perimeter and length of the diagonal of the rectangle. Your code should print the results.\n\n\n\n\n\n\nQuestion 5: An object dropped from a height satisfies the SUVAT equations. In particular, it satisfies the following equation:\n\\[v^2 = u^2 + 2as\\]\nwhere - \\(v\\) is the final velocity, - \\(u\\) is the initial velocity, - \\(a\\) is the acceleration, equal to gravity in this case, - \\(s\\) is the distance.\nGiven the object is at rest initially and it’s final velocity is \\(10\\) meters per second, write code to compute the distance it has fallen.\n\n\n\n\n\n\nQuestion 6: Building on your answer to Question 5, by researching the SUVAT equations and writing code below, compute the time in seconds that the object spends in freefall.\n\n\n\n\n\n\nQuestion 7: Without running code, predict the result of these, then check your answers in Python:\n\n(True and False) or True\nnot (False or False)\nTrue or False and False\nFalse ^ True\n(True and not True) and (False or not False)\n\n\n\n\n\n\n\nQuestion 8: The below code takes two numbers, x and y and computes \\(z=\\frac{x+y}{y^2}\\). For instance, when we set \\(x=1\\) and \\(y=5\\) we get \\(z=0.24\\).\n\n\n\n\n\n\nSuppose you were change the inputs, x and y, to 2 and 5. Work out by hand what you would expect \\(z\\) to equal.\nThe below code is the same as the above but the values of x and y have been changed. This time, something has gone wrong! z does not give the expected value. Explain what has happened and how you would fix it.\n\n\n\n\n\n\nQuestion 9: Explain why the first code box below prints nothing but the second prints True.\n\n\n\n\n\n\n\n\n\n\n\n\nHint: Consider the below variable z. What is it’s datatype?\n\n\n\n\n\n\nGiven your answer to the above, you may expect the below code to also print True.\n\n\n\n\n\n\nHowever, it doesn’t! Why do you think this is?\nHint: Try printing (0.1 + 0.2) and 0.3 seperately. What do you notice?\nQuestion 10: In the code block below, you are given 12 strings:\n\none start_string\n\nten “helper” strings (string1 to string10)\n\none end_string\n\nYour task is to transform the start_string into the end_string using only:\n\nthe start_string\n\nthe helper strings (string1 … string10)\n\nthe .replace() function\n\nA complete solution can be given in 5 replacement steps. We’ve given you the first step to get you started.\nHint: You might not need all ten helper strings.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Beginner: Basic Data Types"
    ]
  },
  {
    "objectID": "08/slides_working_with_numpy.html#overview",
    "href": "08/slides_working_with_numpy.html#overview",
    "title": "Working with NumPy Arrays",
    "section": "Overview",
    "text": "Overview\n\nArray indexing and slicing\nBoolean indexing\nArray generation functions\nRandom data generation"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#basic-indexing",
    "href": "08/slides_working_with_numpy.html#basic-indexing",
    "title": "Working with NumPy Arrays",
    "section": "Basic Indexing",
    "text": "Basic Indexing\nAccess array elements using integer indices and slicing:\n\nSingle element: arr[1] gets element at position 1\nSlice range: arr[1:4] extracts elements 1 to 3 (end exclusive)\nStep size: arr[::2] takes every 2nd element\nReverse: arr[::-1] reverses the entire array"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#views-vs-copies",
    "href": "08/slides_working_with_numpy.html#views-vs-copies",
    "title": "Working with NumPy Arrays",
    "section": "Views vs Copies",
    "text": "Views vs Copies\nImportant memory concept:\n\nSlicing creates views that share the same underlying data\nModifying a view changes the original array\nUse .copy() to create independent arrays when needed\n\nThis behavior is efficient but can cause unexpected side effects!"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#boolean-indexing-filtering-with-conditions",
    "href": "08/slides_working_with_numpy.html#boolean-indexing-filtering-with-conditions",
    "title": "Working with NumPy Arrays",
    "section": "Boolean Indexing: Filtering with Conditions",
    "text": "Boolean Indexing: Filtering with Conditions\nBoolean indexing allows data filtering based on conditions:\n\nApply a condition to create a boolean mask (True/False array)\nUse the mask to select only elements that meet the condition\nThis is powerful for data analysis and filtering operations"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#np.where-function",
    "href": "08/slides_working_with_numpy.html#np.where-function",
    "title": "Working with NumPy Arrays",
    "section": "np.where Function",
    "text": "np.where Function\nAdvanced conditional operations:\n\nnp.where(condition) returns indices where condition is True\nnp.where(condition, x, y) creates new array: elements from x where True, from y where False\nPowerful for element-wise conditional logic without loops"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#filled-arrays",
    "href": "08/slides_working_with_numpy.html#filled-arrays",
    "title": "Working with NumPy Arrays",
    "section": "Filled Arrays",
    "text": "Filled Arrays\nInitialize arrays with specific values:\nUseful for creating placeholders before computations or initializing data structures.\n\n*_like() functions preserve shape and data type of existing arrays\nnp.empty() is fastest but contains arbitrary values"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#pseudo-random-numbers",
    "href": "08/slides_working_with_numpy.html#pseudo-random-numbers",
    "title": "Working with NumPy Arrays",
    "section": "Pseudo-Random Numbers",
    "text": "Pseudo-Random Numbers\nWhy computers need algorithms for randomness:\n\nComputers are deterministic machines (same input → same output)\nPseudo-random number generators (PRNGs) use mathematical algorithms\nSeed value determines the starting point of the sequence\nSame seed = same sequence (crucial for reproducible research!)"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#random-sampling",
    "href": "08/slides_working_with_numpy.html#random-sampling",
    "title": "Working with NumPy Arrays",
    "section": "Random Sampling",
    "text": "Random Sampling\nGenerate samples from different distributions:\n\nIntegers: Uniform distribution over a range\nFloats: Uniform distribution [0,1) or custom range\n\nNormal: Gaussian distribution with specified mean and standard deviation\nControl sample size with size parameter"
  },
  {
    "objectID": "08/slides_working_with_numpy.html#performance-tip",
    "href": "08/slides_working_with_numpy.html#performance-tip",
    "title": "Working with NumPy Arrays",
    "section": "Performance Tip",
    "text": "Performance Tip\nMemory vs. Speed tradeoff:\nGenerating random numbers one-by-one in loops is slow due to function call overhead. Pre-allocating larger arrays is much faster!\nRule of thumb: Start with 100,000 elements for most tasks."
  },
  {
    "objectID": "08/slides_working_with_numpy.html#summary",
    "href": "08/slides_working_with_numpy.html#summary",
    "title": "Working with NumPy Arrays",
    "section": "Summary",
    "text": "Summary\n\nIndexing: Integer, slicing, boolean\nViews vs Copies: Slicing creates views\nGeneration: arange, linspace, filled arrays\nRandom: Seed for reproducibility, pre-allocate for speed"
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html",
    "title": "Working with NumPy",
    "section": "",
    "text": "Create a 1D NumPy array arr of integers from 10 to 19. Access the element at index 3."
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy_solutions.html#exercise-9-problem-solving-with-numpy",
    "title": "Working with NumPy",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead."
  },
  {
    "objectID": "09/exercises_plotting_data_from_file_solutions.html",
    "href": "09/exercises_plotting_data_from_file_solutions.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\n\n\n\n\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\n\n\n\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\n\n\n\n\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\n\n\n\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\n\n\n\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\n\n\n\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n\n\n\n\n\nWe could then use matplotlib to plot this:\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\n\n\n\n\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\n\n\n\n\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\n\n\n\n\n\n\n\n\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?\n\n\n\n\n\n\n\n\nWe add the sum of concentrations (A+B) as a third line to the plot. This sum remains very close to 1 throughout the reaction, indicating that as “A” decays, it is converted into “B” without significant loss or gain of total concentration. This demonstrates conservation of mass in the reaction: all of “A” is accounted for as it becomes “B”."
  },
  {
    "objectID": "09/slides_intro_matplotlib.html",
    "href": "09/slides_intro_matplotlib.html",
    "title": "Introduction to Matplotlib",
    "section": "",
    "text": "Project 2 is being released this week (Wednesday 19 at 12h00)\nThe tasks require you to solve a scientific problem and complete a template Notebook.\nYou will have to write some code and some reflections on your code\nNo use of autograding: follow the instructions on Blackboard\n\nDownload from Blackboard\nUpload to Noteable for editing\nComplete the asssignment\nDownload and upload back to the submission point on Blackboard\n\nThe assignment will be marked by your tutors."
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#before-we-start",
    "href": "09/slides_intro_matplotlib.html#before-we-start",
    "title": "Introduction to Matplotlib",
    "section": "",
    "text": "Project 2 is being released this week (Wednesday 19 at 12h00)\nThe tasks require you to solve a scientific problem and complete a template Notebook.\nYou will have to write some code and some reflections on your code\nNo use of autograding: follow the instructions on Blackboard\n\nDownload from Blackboard\nUpload to Noteable for editing\nComplete the asssignment\nDownload and upload back to the submission point on Blackboard\n\nThe assignment will be marked by your tutors."
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#before-we-start-1",
    "href": "09/slides_intro_matplotlib.html#before-we-start-1",
    "title": "Introduction to Matplotlib",
    "section": "Before we start",
    "text": "Before we start\n\nProject 2 release\nTips:\n\nWrite clear code (comments, variable names, structure) Follow the advice provided during the tutorials.\nDo not overcomplicate (all tasks have relatively simplease solutions).\nDemonstrate understanding (using comments and in the mandatory Markdown explanation boxes)"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#today",
    "href": "09/slides_intro_matplotlib.html#today",
    "title": "Introduction to Matplotlib",
    "section": "Today",
    "text": "Today\n\nBasics of plotting in Python using matplotlib\nReading and plotting from file\nSome extra decorating tasks"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#what-is-matplotlib",
    "href": "09/slides_intro_matplotlib.html#what-is-matplotlib",
    "title": "Introduction to Matplotlib",
    "section": "What is Matplotlib?",
    "text": "What is Matplotlib?\nMatplotlib is a powerful and widely-used Python library for creating static, animated, and interactive visualizations.\nWhy do we need plotting? - Visualize patterns in data - Communicate results effectively - Explore relationships between variables - Present findings to others"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#getting-started",
    "href": "09/slides_intro_matplotlib.html#getting-started",
    "title": "Introduction to Matplotlib",
    "section": "Getting Started",
    "text": "Getting Started\nQuestion: How do we import matplotlib for plotting?\n\n\n\n\n\n\nThe most widespread convention is to use the shorthand plt to refer to the pyplot submodule.\nThis was created to replicate the functionality of MATLAB, which many early Python adopters were familiar with."
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#two-main-approaches",
    "href": "09/slides_intro_matplotlib.html#two-main-approaches",
    "title": "Introduction to Matplotlib",
    "section": "Two Main Approaches",
    "text": "Two Main Approaches\nProblem: There are different ways to create plots in matplotlib. Which should we choose?\n\nPyplot Interface\nplt.plot(x, y)\nplt.show()\n\nMATLAB-style syntax (if you know MATLAB)\nQuick and simple for basic plots\nOften seen in online examples"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#two-main-approaches-1",
    "href": "09/slides_intro_matplotlib.html#two-main-approaches-1",
    "title": "Introduction to Matplotlib",
    "section": "Two Main Approaches",
    "text": "Two Main Approaches\n\nObject-Oriented Approach\nfig, ax = plt.subplots()\nax.plot(x, y)\n\nMore modern and explicit\nfig and ax are Python objects: with the . you can explore all the things they can do and they can be passed to functions\nRecommended approach"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#understanding-figure-and-axes",
    "href": "09/slides_intro_matplotlib.html#understanding-figure-and-axes",
    "title": "Introduction to Matplotlib",
    "section": "Understanding Figure and Axes",
    "text": "Understanding Figure and Axes\nQuestion: What’s the difference between a Figure and Axes?\n\n\n\n\n\n\n\nFigure: The entire canvas - like a piece of paper\nAxes: The plotting area with x-y coordinates - where data goes"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#what-types-of-plots-can-we-create",
    "href": "09/slides_intro_matplotlib.html#what-types-of-plots-can-we-create",
    "title": "Introduction to Matplotlib",
    "section": "What Types of Plots Can We Create?",
    "text": "What Types of Plots Can We Create?\nProblem: We have different types of data - how do we choose the right visualization?\n\nContinuous Relationships\nax.plot(x, y)        # Line plot\nax.scatter(x, y)     # Scatter plot\nWhen to use: Time series, correlations\n\n\nDistributions\nax.hist(data)        # Histogram\nax.bar(categories, values)  # Bar plot\nWhen to use: Frequency distributions, comparisons"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#real-example-combining-visualizations",
    "href": "09/slides_intro_matplotlib.html#real-example-combining-visualizations",
    "title": "Introduction to Matplotlib",
    "section": "Real Example: Combining Visualizations",
    "text": "Real Example: Combining Visualizations\nScenario: We have measurements and a fitted model. How do we show both?"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#customising-plots",
    "href": "09/slides_intro_matplotlib.html#customising-plots",
    "title": "Introduction to Matplotlib",
    "section": "Customising plots",
    "text": "Customising plots\nProblem: Default plots often look bland. How do we make them professional?"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#examples",
    "href": "09/slides_intro_matplotlib.html#examples",
    "title": "Introduction to Matplotlib",
    "section": "Examples",
    "text": "Examples\nHave a look at matplotlib examples to see the raneg of things that are possible\nhttps://matplotlib.org/stable/gallery/index"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#anatomy-of-a-figure",
    "href": "09/slides_intro_matplotlib.html#anatomy-of-a-figure",
    "title": "Introduction to Matplotlib",
    "section": "Anatomy of a Figure",
    "text": "Anatomy of a Figure\n\nUnderstanding these components helps you customize any part of your plot"
  },
  {
    "objectID": "09/slides_intro_matplotlib.html#workshop-today",
    "href": "09/slides_intro_matplotlib.html#workshop-today",
    "title": "Introduction to Matplotlib",
    "section": "Workshop today",
    "text": "Workshop today\n\nIn the lecture, you will find some inline Exercises A and B demonstrating the rudimenst of plotting: we will go through this together to discover the essential syntax.\nYou will then be able to complete Exercise C where we read in some data and plot it.\nYou will finally be able to experiment with matplotlib in a separate sheet named fun_matplotlib_decoration.ipynb"
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html",
    "href": "09/lecture_intro_matplotlib.html",
    "title": "Plotting with matplotlib",
    "section": "",
    "text": "One way to plot a graph in Python is to use the matplotlib package.\nMatplotlib is a powerful and widely-used Python library for creating static, animated, and interactive visualizations. It provides a flexible framework for generating a wide variety of plots and charts, making it a popular choice for data analysis and scientific research. With matplotlib, you can customize every aspect of your figures, from colors and styles to labels and legends.\nWe start by importing the pyplot sub-module from matplotlib.\nThe most widespread convention is to use the shorthand plt to refer to this package with the as syntax and so we can import this in the following way:",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "href": "09/lecture_intro_matplotlib.html#figure-and-axes",
    "title": "Plotting with matplotlib",
    "section": "Figure and Axes",
    "text": "Figure and Axes\nThere are two main interfaces for plotting using matplotlib.\n\nThe first is to use Pyplot (plt) to create a plot directly e.g. using plt.plot(). This is the type of syntax you may see often when looking online. This way of interacting with and plotting data was created to replicate the functionality of an alternative, and common programming language called MATLAB, which a lot of early Python adopters were familiar with.\nThe second, more modern way to create plots is to use the object-oriented approach where the figure is created first and then explicitly referenced when creating a plot. One way to do this is by calling the subplots() function to create a Figure (the canvas) and an Axes (the x-y axes) object which can then be used for plotting.\n\nfig, ax = plt.subplots()\nWe can plot using the ax object directly using whichever type of graph we want to create e.g.  - for a simple line graph we can use the plot() function - for a scatter graph we can use the scatter() function. - for a 1D histogram we can the hist() function\nYou can also add multiple graphs to the same set of Axes to plot sets of data on top of each other:\n\n\n\n\n\n\n\n\n\n\n\n\nYou may notice that unlike other Python you have been writing, in Jupyter notebooks you should keep your plotting code together in one code cell as this will immediately be displayed when the code cell is run.\nTo create another plot in a new cell you can create new Figure and Axes objects using the same names fig, ax or name them something different if you’d prefer.\nMatplotlib sample plots - https://matplotlib.org/3.3.3/tutorials/introductory/sample_plots.html\n\nAside: subplots\nYou may ask why the function for creating a new plot is called subplots(). By default, this function allows you to create one plot on one figure, which is usually what you want for an initial plot. However, it is possible to use the subplots() function to create multiple plots on the same figure. One way to do this is by specifying the number of rows (nrows) and number of columns (ncols) you want when using the subplots() function. Note that this will pass back an array of Axes objects rather than just one which you can then use to plot.\nWe won’t explore this further, but for more details on how this is done have a look at the subplots demo.\n\n\n\nExercise A (Worked through as needed in class)\nFor this exercise, we have created some random sample data which we can plot. Here we have created several numpy arrays each 100 elements long (based on num_points).\n\n\n\n\n\n\n\nCreate a scatter plot of x_range versus random_sample1.\n\n\nStart by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the scatter method to plot your data using your Axes object\n\n\n\n\n\n\n\n\nCreate a line plot of x_range versus random_sample2\n\n\nAs before, start by creating your Figure and Axes objects (fig, ax) using the subplots function\nUse the plot method to plot your data using your Axes object",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "href": "09/lecture_intro_matplotlib.html#annotating-and-adding-features",
    "title": "Plotting with matplotlib",
    "section": "Annotating and adding features",
    "text": "Annotating and adding features\nAs well as plotting you can, and should, add additional information to your plot as appropriate. For instance, you can:\n\nchange the style, colour etc. of your initial plot (e.g. see examples within matplotlib decoration)\nadd additional features such as axis labels, legend etc.\n\nThe code below demonstrates how we could customise the plot above using these inputs:\n\n1. Using more of the available plotting options\n\n\n\n\n\n\nWe can include more inputs for both our subplots function and our plotting functions such as plot() and scatter():\n\nFor the subplots() initial step we specified the figure size, figsize, as an input. This is set using a tuple of (width, height) in inches.\nFor the plot function we set:\n\nthe colour to be a named colour called “slategrey” using the color input\nthe style of the line to be dashed, using “–” and the linestyle input\n\nFor the scatter function we set:\n\nthe colour to be a named colour called “indianred” using the color input\nthe marker shape to a cross shape, using “+” and the marker input\nsize to be 60 (area of the marker) using the s input\n\n\nFor in-built options see: - Colours - https://matplotlib.org/stable/gallery/color/named_colors.html - Line style - https://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html - Markers - https://matplotlib.org/api/markers_api.html\n\n\n2. Setting properties on the plot\n\n\n\n\n\n\nHere we set additional parameters for the plot - the x and y labels and an x limit. We have done this by calling the relevant functions (e.g. set_xlabel, set_ylim) on our ax variable.\nFor some examples of different Axes functions of this type see: - Axes - labels and limits - https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend - Axes - tick labels - https://matplotlib.org/stable/api/axes_api.html#ticks-and-tick-labels\n\n\n3. Additional labelling - legend\n\n\n\n\n\n\nA legend can be created using the .legend() function (method) and this will use the label value supplied when creating each plot. If ax.legend() is not included then, even if a label variable is specified, no legend will be added to the plot.\nSee: - legend function - https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#other-plot-types",
    "href": "09/lecture_intro_matplotlib.html#other-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Other plot types",
    "text": "Other plot types\nWe can also apply similiar principles to other plot types. We can generate some more random data to look at this. Here we have created two normal distributions containing different numbers of points.\n\n\n\n\n\n\nWe could create a simple plot using the subplots function and the hist() function:\n\n\n\n\n\n\nUsing the exact same data we could update our plot using relevant inputs for our hist function and setting values on our axis:\n\n\n\n\n\n\nFor our histogram, in addition to options we used for our scatter and line plot, we have set more options available to us: - alpha - This allows us to make our data partially transparent to better view overlapping data - bins - We defined and included an input for the bin sizes rather than using the default - density - This is a plot type we can set which normalised our data for the different datasets. This can be useful if you are comparing datasets which have different sample sizes.\nIn general, you will need to look at the specific documentation for each of the the plot types to see what options are available.",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "href": "09/lecture_intro_matplotlib.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a figure",
    "text": "Anatomy of a figure\nThis is a summary image to show the make up (anatomy) of a plot in matplotlib.\n\nYou can see some features we have described above such as “Figure”, “Axes”, “x axis label”, “y axis label”, “legend”. But you can also see how our inputs have influenced other aspects of the plot e.g. “Major tick”, “Minor tick”, “Major tick label”, “Minor tick label”, which were updated when we set the limits on the x and y axes, and “Markers” from our scatter plot which updated the marker style and colour.\nBecoming familiar with this terminology when applied to a matplotlib figure allows you to put a name to any part of the plot you wish to modify and to dig into the features offered for how to update these plots.\n\n\nExercise B (Worked through as needed in class)\n\nCreate a scatter plot with the same data from Exercise A showing x_range versus random_sample1 adding or setting the following features:\n\n\nchanging the marker and colour\nsetting appropriate x and y labels\n\nRemember, you always need to recreate your fig and ax objects using the subplots function to create a new plot using Jupyter notebooks\n\n\n\n\n\n\n\nCreate a histogram plot overlaying data from random_sample1 and random_sample2.\n\n\nExperiment with different inputs to see if you can improve the default plot (e.g. setting the bin size, including transparency, changing the colours etc.)\nYou can also look at the hist() function documentation for more inputs to try e.g. histtype.\n\n\n\n\n\n\n\nExtra. Create a plot containing both a scatter plot for x_range versus random_sample1 AND a line plot for x_range versus random_sample2. Add or set the following features: - changing the line style and colour - setting a title for your plot\nHint: Look at “set_” commands within https://matplotlib.org/stable/api/axes_api.html#axis-labels-title-and-legend\n\n\n\n\n\n\n\nExtended: Pick an interesting plot from the matplotlib gallery and see if you replicate some of the additional features for these plots.\n\nYou can now proceed with the remaining exercises\n\nExercise C - Plotting data from a file\nA fun session - Using matplotlib to create a fun plot",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting with `matplotlib`"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html",
    "href": "07/lecture_intro_numpy.html",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\n\n\n\n\n\n\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\n\n\n\n\n\n\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n\n\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\n\n\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n\n\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n\n\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n\n\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\n\n\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "href": "07/lecture_intro_numpy.html#what-is-the-numpy-module",
    "title": "The numpy module",
    "section": "",
    "text": "A collection of many functions is called a module. One of the most useful modules in Python is called numpy (numerical Python) – it contains many functions to deal with numerical programming. This is technically an extension to the Core Python functionality we’ve been focussing on so far but now comes as standard in most Python installations.\nThe numpy module builds on the core functionality but also adds additional features including:\n\nIt is performant which means it is well optimised\nIt offers additional numerical computing tools\nIt adds an additional object called an n-dimensional array\n\n\n\nOne thing we can use the numpy module for is to create a new object called a numpy array. This is another data structure, in addition to the in-built Python types we’ve been learning about, and is similiar to a list.\n\n\n\nNumpy arrays\n\nNumpy module (and arrays) are a Python extension (but often come as standard)  Ordered  Mutable  Less flexible - One data type per array  Allows implicit element-wise operations  Generally quicker (optimised) More memory efficient\n\nLists\n\nLists are part of Python in-built functionality  Ordered  Mutable  Very flexible - All types in any list  Needs explicit element-wise operations  Generally slower performance Less memory efficient\n\n\nWhen using these objects, list objects are highly flexible, in both content and shape whereas numpy.array objects are much more strict and require every item to be the same type and often work best when they have a consistent shape (e.g. 2x3 grid).\n\n\n\nnumpy.array objects are mutable, ordered container objects but must contain a specific object type and have n-dimensional shape.\nTo use the numpy module we first need to import it.\n\n\n\n\n\n\nThe as part of this import statement gives us a shorthand to use in the code when we want to access numpy, in this case np. This is the convention most often used for the numpy module. import statements themselves are the way we access additional Python modules such as numpy or matplotlib.\nOne way to create a numpy.array is from a list:\n\n\n\n\n\n\nwhere we need the np. at the start of the function to tell python to access the numpy module.\nWe can also index and slice numpy.arrays in a similar way to other iterable objects (i.e. objects with length like lists):\n\n\n\n\n\n\nAnd a numpy.array has an additional properties (attributes) called dtype which tells us what is contained within the array and shape which tells us the dimensions of the array.\n\n\n\n\n\n\n\n\n\nThe numpy module itself also provides some additional tools and syntax to complete simple operations more succinctly. For instance, we’ve shown before one way to act on every item in a list using a for loop:\n\n\n\n\n\n\nThere is actually a short hand for creating a new list using a for loop for very simple operations called a list comprehension.\n\n\n\n\n\n\nBut this is still more complex than using a numpy.array, where the same operation can be performed using an operator directly on the whole array:\n\n\n\n\n\n\n\n\n\nFor large numbers of elements the time difference between operations using lists and numpy.arrays can start to be measurable. We can quickly check this my importing the time module:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComparing the two operations we can see that performing this operation with the list takes longer than within a numpy.array (this is highly variable though):\n\n\n\n\n\n\nYou may recall, when we first introduced list and dict objects, we also mentioned other Python objects which were similar but with some differences in functionality (tuple and set objects). In Python, as in many languages, there are often many tools which can be used to complete a task and it’s up to you to choose the correct tool for the job. Overall, list objects may be more appropriate when you need to store a set of strings or if you don’t know the number of elements in advance (appending to a list is faster than appending to an numpy.array due to the way the data is stored in memory). Whereas numpy.array objects would be more appropriate when performance is a factor or for simpler numerical operations.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#working-with-numpy",
    "href": "07/lecture_intro_numpy.html#working-with-numpy",
    "title": "The numpy module",
    "section": "Working with numpy",
    "text": "Working with numpy\nTo use the numpy module we always need to start by using an import statement. In this case we import the numpy module and use the shorthand np:\n\n\n\n\n\n\n\n\n\n\n\n\nWe’ve seen that we can apply operators directly to a numpy.array:\n\n\n\n\n\n\nSimilarly you can use additional functions provided by the numpy module to do something to each element in the array. For example you can apply a square root:\n\n\n\n\n\n\nOr perform a reductive operation such as calculating the mean of all the elements:\n\n\n\n\n\n\nWe can also apply mathematical operations over the whole array. For instance we can look at the np.cos function which produces applies the cosine function element-wise:\n\n\n\n\n\n\nThe help states that this wants an array-like object and wants the input in radians. We can write this as:\n\n\n\n\n\n\nIf we look at arr1 we can see that this has not been updated by the application of these operations - when using this functionality a copy of the array is returned which you can choose to re-assign to the original variable name or create a new variable:",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#element-wise-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Element-wise operations on 1D arrays",
    "text": "Element-wise operations on 1D arrays\nElement-wise operations in numpy allow you to perform arithmetic or mathematical functions on each corresponding element of arrays. For example, if you have two arrays of the same length, arr1 and arr2, you can add them directly: arr1 + arr2. This will produce a new array where each element is the sum of the elements at the same position in the original arrays. Similarly, you can use other operators (-, *, /) or numpy functions (np.sqrt(arr1), np.cos(arr1)) to apply operations to each element individually. The arrays must have compatible shapes for these operations.\n\n\n\n\n\n\n\n\n\n\n\n\nWhen 1D arrays have different lengths, you need to be careful about the operations you perform. Element-wise operations: Operations such as arr1 + arr3 or arr1 * arr3 require arrays to have the same length or compatible shapes. If the lengths differ, numpy will raise a ValueError due to shape mismatch.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "href": "07/lecture_intro_numpy.html#basic-operations-on-1d-arrays",
    "title": "The numpy module",
    "section": "Basic operations on 1D arrays",
    "text": "Basic operations on 1D arrays\nSumming all elements in a 1D numpy array can be done with np.sum(arr1).\nFor cumulative summing, use np.cumsum(arr1), which returns an array where each element is the sum of all previous elements.\nSorting is performed with np.sort(arr1), which returns a sorted copy of the array.\nTo concatenate two arrays, use np.concatenate([arr1, arr2]). This joins the arrays end-to-end, creating a new array containing all elements from both arrays in order. Concatenation is useful for combining datasets or extending arrays.\nTo find unique elements, use np.unique(arr1), which returns an array of the distinct values in arr1. These operations are efficient and commonly used for data analysis.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "The `numpy` module"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html",
    "href": "07/exercises_numpy.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180]) 1. Convert these angles to radians (hint: multiply by π/180, use np.pi) 2. Calculate the sine and cosine of each angle 3. Verify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos()) 4. Print all results",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "href": "07/exercises_numpy.html#challenge-1-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge 1: Temperature Conversion",
    "text": "Challenge 1: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "href": "07/exercises_numpy.html#challenge-2-kinetic-energy",
    "title": "numpy Exercises",
    "section": "Challenge 2: Kinetic energy",
    "text": "Challenge 2: Kinetic energy\nTask Given arrays of mass (kg) and velocity (m/s) for several objects:\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n\nCalculate the kinetic energy \\(K\\) for each object using the formula:\n\n\\[K =  \\dfrac{1}{2}m v^2\\]\n\nCalculate the total kinetic energy of the system (sum of all objects)",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature.",
    "crumbs": [
      "Home",
      "07 Introduction to NumPy",
      "`numpy` Exercises"
    ]
  },
  {
    "objectID": "slides/tmp.html",
    "href": "slides/tmp.html",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "list_ex = [1, 2, 3, 4]\nprint(list_ex)\nimport numpy as np\n#notice that we explicitly call the np.array()\narr_ex = np.array([1, 2, 3, 4]) \nprint(arr_ex)\nWe are going to see these differences in detail."
  },
  {
    "objectID": "slides/tmp.html#arrays-from-lists",
    "href": "slides/tmp.html#arrays-from-lists",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Arrays from lists",
    "text": "Arrays from lists\nA purely numerical list can readily be converted to an array.\n\nimport numpy as np\n# Create array from list\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\nprint(arr1)\n\n. . .\nThe type of the elements yields the data type of the array\n\nprint(arr1.dtype)\n\n\nTry and change the list1 object to contain only integers and see the change!"
  },
  {
    "objectID": "slides/tmp.html#array-properties",
    "href": "slides/tmp.html#array-properties",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Array properties",
    "text": "Array properties\nArrays possess plenty of properties.\nThese are accessed with the . notation1.\n\nprint(f\"Data type: {arr1.dtype}\")\nprint(f\"Shape: {arr1.shape}\")\nprint(f\"Shape: {arr1.size}\")\n\nFor now, we consider only 1d arrays, i.e. sequences. Their length is is their size and corresponds to the first element of the property shape."
  },
  {
    "objectID": "slides/tmp.html#accessing-array-elements",
    "href": "slides/tmp.html#accessing-array-elements",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Accessing array elements",
    "text": "Accessing array elements\nSimilarly to lists, we access an element in an array via zero-based indexing\n\nprint(arr1[0])    # First element\nprint(arr1[-1])   # Last element\n\nAgain, similarly to lists, we can access regions of the array via slicing\n\nprint(arr1[3:6])  # Elements from index 3 to 6"
  },
  {
    "objectID": "slides/tmp.html#element-wise-operations",
    "href": "slides/tmp.html#element-wise-operations",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe main motivation to use arrays is that lists are cumbersome when performing maths.\nSuppose we have a list and want to double all of its elements:\n\nlist1 = [1,2,3,4]\n\nWe need to loop over all of them and create a new list\n\nlist2 = []\nfor item in list1:\n    list2.append(2*item)\nprint(list2)\n\nIn fact, we can do this in a slightly more compact way using list comprehension\n\nlist2 = [item*2 for item in list1]\n\nStill, an explicit loop is needed. Loops in Python are slow."
  },
  {
    "objectID": "slides/tmp.html#element-wise-operations-1",
    "href": "slides/tmp.html#element-wise-operations-1",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe numpy syntax avoids the explicit Python loop.\n\narr1 = np.array(list1)\narr2 = 2*arr1\nprint(arr2)\n\nThis is not just a cosmetic change: under the hood numpy uses an efficient architecture that performs operations in compiled code, making it much faster than Python loops."
  },
  {
    "objectID": "slides/tmp.html#performance-advantage",
    "href": "slides/tmp.html#performance-advantage",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Performance advantage",
    "text": "Performance advantage\nThis performance difference can be tracked explicitly.\nWe create a large list and a large array with identical content\n\n# Create a large list and array\nlarge_list = list(range(1_000_000))\nlarge_array = np.array(large_list)\n\nAnd then track the time for the two operations\n\nimport time\n#  Track the time taken for the list multiplication\nstart = time.time()\nlist_result = [x * 2 for x in large_list]\nend = time.time()\nprint(f\"List comprehension time: {end - start:.5f} seconds\")\n\n# Time array multiplication\nstart = time.time()\narray_result = large_array * 2\nend = time.time()\nprint(f\"NumPy array time: {end - start:.5f} seconds\")"
  },
  {
    "objectID": "slides/tmp.html#general-mathematical-functions",
    "href": "slides/tmp.html#general-mathematical-functions",
    "title": "Introduction to Coding and Data Analysis",
    "section": "General mathematical functions",
    "text": "General mathematical functions\nThe multiplication we performed earlier is done element-wise: every element is update according to teh same rule.\nWe can apply plenty of element-wise operations to the arrays.\nMany of these are available as numpy functions directly accessed from the np. module\n\n# Element-wise functions\nprint(f\"Square root: {np.sqrt(arr1)}\")\nprint(f\"Mean: {np.mean(arr1)}\")\nprint(f\"Cosine: {np.cos(arr1)}\")\n\n. . .\nThe operations do not modify the original array, but produce new copies\n\narr2 = arr1*3/2 + 5\nprint(f\"Original: {arr1}\")\nprint(f\"Modified: {arr2}\")"
  },
  {
    "objectID": "slides/tmp.html#sums",
    "href": "slides/tmp.html#sums",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Sums",
    "text": "Sums\nOther convenent numpy functions allow you to accumulate values without loops.\nAssume we have an array \\(x\\)\n\nx = np.array([1,2,3,4,5,6,7,8])\n\nSums\n\\[\nS = \\sum_{i=1}^{n} x_i\n\\]\nIn NumPy, this is translated as:\n\nS = np.sum(x)\nprint(S)"
  },
  {
    "objectID": "slides/tmp.html#sums-1",
    "href": "slides/tmp.html#sums-1",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Sums",
    "text": "Sums\nCumulative sums\nA cumulative sum is a sequence where each element is the sum of all previous elements up to that position. \\[\ny_i = \\sum_{j=1}^{i} x_j\n\\]\nIn NumPy, this is translated as:\n\n y = np.cumsum(x)\n print(y)"
  },
  {
    "objectID": "slides/tmp.html#example-molecular-masses",
    "href": "slides/tmp.html#example-molecular-masses",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Example: molecular masses",
    "text": "Example: molecular masses\nLet’s consider the formula for the molecular mass of a compound:\n\\[\nM = \\sum_{i=1}^{n} a_i m_i\n\\]\nwhere\n\n\\(a_i\\) is the number of atoms of element \\(i\\)\n\\(m_i\\) is the atomic mass of element \\(i\\)\n\n. . .\nWith numpy, you can compute this as:\n\na = np.array([2, 1, 4])      # Number of atoms for each element\nm = np.array([12.01, 1.01, 16.00])  # Atomic masses (e.g., C, H, O)\nM = np.sum(a * m)\nprint(f\"Molecular mass: {M}\")"
  },
  {
    "objectID": "slides/tmp.html#operations-between-arrays",
    "href": "slides/tmp.html#operations-between-arrays",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Operations between arrays",
    "text": "Operations between arrays\nYou can perform arithmetic operations directly between arrays of the same shape. Operations like addition, subtraction, multiplication, and division are applied element-wise.\nFor example:\nElement-wise operations:\n\nadded = arr1 + arr2\nmultiplied = arr1 * arr2\nprint(f\"Added: {added}\")\nprint(f\"Multiplied: {multiplied}\")\n\n. . .\nNote: Arrays must have compatible shapes!\n\narr3 = np.array([1, 2, 3])\narr4 = np.array([4, 5])\nresult = arr3 + arr4"
  },
  {
    "objectID": "slides/tmp.html#combining-arrays",
    "href": "slides/tmp.html#combining-arrays",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Combining arrays",
    "text": "Combining arrays\nWith lists, the + operator concatenated different lists. Since for arrays the sign + corresponds to true mathematical addition, a dedicated concatenation function exists:\n\ncombined = np.concatenate([arr1, arr2])\nprint(f\"Unique elements: {combined}\")\n\nMany other variations of concatenation exist. Consult the documentation."
  },
  {
    "objectID": "slides/tmp.html#key-takeaways",
    "href": "slides/tmp.html#key-takeaways",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy arrays are optimized for numerical operations\nElement-wise operations work implicitly\nPerformance benefits for large datasets\nMathematical functions apply to entire arrays\nShape compatibility required for operations\nChoose the right tool for your task"
  },
  {
    "objectID": "slides/tmp.html#footnotes",
    "href": "slides/tmp.html#footnotes",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nuse . and then TAB to see all of the properties↩︎"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "href": "slides/10_multidimensional_arrays_slides.html#numpy-arrays-beyond-1d",
    "title": "Multi-dimensional Arrays",
    "section": "NumPy Arrays Beyond 1D",
    "text": "NumPy Arrays Beyond 1D\nMulti-dimensional arrays enable representation of: - 2D: Grid/Matrix (rows × columns) - 3D: Cuboid/Tensor (depth × rows × columns) - nD: Higher dimensions\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nimport numpy as np\nfrom numpy import random\nrng = random.default_rng(seed=24)\n\n# 2D array (3×3 matrix)\narray_2d = rng.random((3, 3))\nprint(f\"Shape: {array_2d.shape}\")\nprint(array_2d)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#indexing-multi-dimensional-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Indexing Multi-dimensional Arrays",
    "text": "Indexing Multi-dimensional Arrays\nRow-major order: [row, column] (like [y, x])\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Access single element\nprint(\"Element at [1,2]:\", array_2d[1, 2])\n\n# Access entire row\nprint(\"First row:\", array_2d[0, :])\n\n# Access entire column  \nprint(\"First column:\", array_2d[:, 0])\nSlicing works with multiple dimensions:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nprint(\"First 2 rows:\\n\", array_2d[:2])"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "href": "slides/10_multidimensional_arrays_slides.html#array-properties",
    "title": "Multi-dimensional Arrays",
    "section": "Array Properties",
    "text": "Array Properties\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Creating arrays with different shapes\nzeros_2d = np.zeros((2, 3))  # 2 rows, 3 columns\nrandom_3d = rng.integers(0, 3, size=(2, 3, 4))  # 2×3×4 tensor\n\nprint(\"2D shape:\", zeros_2d.shape)\nprint(\"3D shape:\", random_3d.shape)\nprint(\"3D rank/dimensions:\", random_3d.ndim)\nTerminology: - Rank/ndim: Number of dimensions - Matrix: Rank 2 array - Tensor: Rank 3+ array"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "href": "slides/10_multidimensional_arrays_slides.html#operations-along-axes",
    "title": "Multi-dimensional Arrays",
    "section": "Operations Along Axes",
    "text": "Operations Along Axes\nAxis-specific operations:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nmatrix = rng.integers(0, 5, size=(3, 4))\nprint(\"Original matrix:\\n\", matrix)\n\nprint(\"Sum along axis 0 (columns):\", matrix.sum(axis=0))\nprint(\"Sum along axis 1 (rows):\", matrix.sum(axis=1))\nprint(\"Mean along axis 0:\", np.mean(matrix, axis=0))\nAxis 0: Operations across rows (result has column shape)\nAxis 1: Operations across columns (result has row shape)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "href": "slides/10_multidimensional_arrays_slides.html#reshaping-and-flattening",
    "title": "Multi-dimensional Arrays",
    "section": "Reshaping and Flattening",
    "text": "Reshaping and Flattening\nReshape without changing data:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\narr_1d = np.arange(12)\narr_2d = arr_1d.reshape((3, 4))\narr_3d = arr_1d.reshape((2, 2, 3))\n\nprint(\"1D:\", arr_1d)\nprint(\"2D (3×4):\\n\", arr_2d)\nprint(\"3D shape:\", arr_3d.shape)\nUsing -1 for automatic dimension:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# -1 means \"figure out this dimension\"\nauto_reshape = arr_1d.reshape(-1, 4)  # ? rows, 4 columns\nprint(\"Auto-reshaped:\\n\", auto_reshape)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#flattening-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Flattening Arrays",
    "text": "Flattening Arrays\nravel() - returns view (shares data):\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nmatrix = rng.integers(0, 10, (2, 3))\nprint(\"Original:\\n\", matrix)\n\nview = matrix.ravel()\nview[0] = 99  # Changes original!\nprint(\"After modifying view:\\n\", matrix)\nflatten() - returns copy:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nmatrix = rng.integers(0, 10, (2, 3))\ncopy = matrix.flatten()\ncopy[0] = 99  # Original unchanged\nprint(\"Original unchanged:\\n\", matrix)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "href": "slides/10_multidimensional_arrays_slides.html#broadcasting",
    "title": "Multi-dimensional Arrays",
    "section": "Broadcasting",
    "text": "Broadcasting\nCombine arrays of different shapes automatically:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nmatrix = np.array([[1, 2, 3],\n                   [4, 5, 6]])\nvector = np.array([10, 20, 30])\n\n# Vector is broadcast to each row\nresult = matrix + vector\nprint(\"Matrix + Vector:\\n\", result)\nCreate grids with broadcasting:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nrow_vec = np.arange(3).reshape(1, -1)    # Shape: (1, 3)\ncol_vec = np.arange(3).reshape(-1, 1)    # Shape: (3, 1)\ngrid = row_vec + col_vec                 # Shape: (3, 3)\nprint(\"Broadcast grid:\\n\", grid)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-with-numpy",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra with NumPy",
    "text": "Linear Algebra with NumPy\nMatrix operations for solving systems: \\[A\\mathbf{x} = \\mathbf{b}\\]\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# System: 2x + 3y + z = 5, 4x - y = 1, 2y + z = 3\nA = np.array([[2, 3, 1], \n              [4, -1, 0], \n              [0, 2, 1]])\nb = np.array([[5], [1], [3]])\n\n# Solve the system\nx = np.linalg.solve(A, b)\nprint(\"Solution:\", x.flatten())\n\n# Verify: A @ x should equal b\nprint(\"Verification:\\n\", A @ x)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "href": "slides/10_multidimensional_arrays_slides.html#linear-algebra-operations",
    "title": "Multi-dimensional Arrays",
    "section": "Linear Algebra Operations",
    "text": "Linear Algebra Operations\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Matrix multiplication with @\nresult = A @ x\n\n# Transpose with .T\nprint(\"b transpose:\", b.T)\n\n# Dot product\ndot_product = np.dot(b.T, b)\nprint(\"Dot product:\", dot_product)\n\n# Matrix inverse\nA_inv = np.linalg.inv(A)\nx_alt = A_inv @ b  # Alternative solution method\nNumPy.linalg provides: inverse, solve, eigenvalues, SVD, etc."
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "href": "slides/10_multidimensional_arrays_slides.html#arrays-as-images",
    "title": "Multi-dimensional Arrays",
    "section": "Arrays as Images",
    "text": "Arrays as Images\nVisualize 2D arrays as images:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nimport matplotlib.pyplot as plt\n\n# Simple matrix visualization\nmatrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))\n\nax1.matshow(matrix)\nax1.set_title('matshow')\n\nax2.imshow(matrix, origin='lower')\nax2.set_title('imshow (origin=lower)')"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "href": "slides/10_multidimensional_arrays_slides.html#working-with-real-images",
    "title": "Multi-dimensional Arrays",
    "section": "Working with Real Images",
    "text": "Working with Real Images\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nfrom skimage import data\n\n# Grayscale image\ngray_image = data.camera()\nprint(\"Image shape:\", gray_image.shape)\n\nfig, ax = plt.subplots(figsize=(6, 6))\nax.imshow(gray_image, cmap='gray')\nax.set_title('Grayscale Image')\nImages are arrays: Each pixel is a number (intensity)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "href": "slides/10_multidimensional_arrays_slides.html#color-images-3d-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Color Images (3D Arrays)",
    "text": "Color Images (3D Arrays)\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Color image has 3 channels: RGB\ncolor_image = data.chelsea()\nprint(\"Color image shape:\", color_image.shape)\n\nfig, axes = plt.subplots(1, 4, figsize=(15, 4))\n\naxes[0].imshow(color_image)\naxes[0].set_title('Full Color')\n\n# Individual color channels\nchannels = ['Reds', 'Greens', 'Blues']\ntitles = ['Red Channel', 'Green Channel', 'Blue Channel']\n\nfor i, (cmap, title) in enumerate(zip(channels, titles)):\n    axes[i+1].imshow(color_image[:, :, i], cmap=cmap)\n    axes[i+1].set_title(title)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "href": "slides/10_multidimensional_arrays_slides.html#boolean-operations-on-images",
    "title": "Multi-dimensional Arrays",
    "section": "Boolean Operations on Images",
    "text": "Boolean Operations on Images\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Extract green channel\ngreen = color_image[:, :, 1]\n\n# Create binary mask\nthreshold_mask = green &gt; 120\n\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\nax1.imshow(green, cmap='Greens')\nax1.set_title('Green Channel')\n\nax2.imshow(threshold_mask, cmap='gray')\nax2.set_title('Thresholded (&gt;120)')\nLogical operations: & (AND), | (OR), ~ (NOT)"
  },
  {
    "objectID": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "href": "slides/10_multidimensional_arrays_slides.html#key-takeaways",
    "title": "Multi-dimensional Arrays",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nMulti-dimensional arrays represent grids, images, tensors\nIndexing: [row, col] for 2D arrays\nAxis operations reduce along specific dimensions\nReshaping changes shape without changing data\nBroadcasting enables operations on different shapes\nLinear algebra operations available in np.linalg\nImages are just arrays of pixel values\nBoolean indexing works on multi-dimensional arrays"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "href": "slides/11_beyond_notebook_slides.html#file-system-navigation",
    "title": "Beyond the Notebook",
    "section": "File System Navigation",
    "text": "File System Navigation\nNotebooks exist in directories - we can navigate using bash commands\nKey commands (use ! prefix in notebooks):\n# Current directory location\n! pwd\n\n# List files and directories\n! ls\n\n# Create new directory\n! mkdir new_folder\n\n# Change directory\n! cd new_folder\n! cd ..  # Go back to parent directory"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#working-with-files",
    "href": "slides/11_beyond_notebook_slides.html#working-with-files",
    "title": "Beyond the Notebook",
    "section": "Working with Files",
    "text": "Working with Files\nCreating and viewing files:\n# Create empty file\n! touch filename.txt\n\n# View file contents\n! cat filename.txt\n\n# View first/last lines\n! head filename.txt\n! tail filename.txt\nFile system navigation: - . = current directory - .. = parent directory - Paths can be absolute (/full/path) or relative (folder/file)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "href": "slides/11_beyond_notebook_slides.html#python-scripts-vs-notebooks",
    "title": "Beyond the Notebook",
    "section": "Python Scripts vs Notebooks",
    "text": "Python Scripts vs Notebooks\nNotebooks (.ipynb): - Rich multimedia content - Markdown, images, metadata - Interactive development - Complex file format\nScripts (.py): - Pure Python code only - Comments with # - Simple text files - Portable and lightweight"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#running-scripts",
    "href": "slides/11_beyond_notebook_slides.html#running-scripts",
    "title": "Beyond the Notebook",
    "section": "Running Scripts",
    "text": "Running Scripts\nFrom notebook:\n# Using the 'run' magic command\nrun path/to/script.py\nFrom terminal:\n# Using python command\npython path/to/script.py\nExample script (hello.py):\nprint(\"Hello, World!\")\nx = 42\nprint(f\"The answer is {x}\")"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#the-terminal",
    "href": "slides/11_beyond_notebook_slides.html#the-terminal",
    "title": "Beyond the Notebook",
    "section": "The Terminal",
    "text": "The Terminal\nText-based interface to the operating system\nAccessing terminal: - In Noteable: New → Terminal - Pure command-line environment - No mouse interaction - Uses bash scripting language\nBasic terminal workflow: 1. Navigate to directory (cd) 2. Create/edit files (touch, text editor) 3. Run Python scripts (python script.py)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "href": "slides/11_beyond_notebook_slides.html#creating-python-modules",
    "title": "Beyond the Notebook",
    "section": "Creating Python Modules",
    "text": "Creating Python Modules\nScripts can be imported as modules:\nStep 1: Create math_utils.py:\ndef add_numbers(a, b):\n    return a + b\n\ndef square(x):\n    return x ** 2\n\nPI = 3.14159\nStep 2: Import and use:\nimport math_utils as mu\n\nresult = mu.add_numbers(5, 3)\narea = mu.PI * mu.square(radius)"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "href": "slides/11_beyond_notebook_slides.html#practical-example-plotting-module",
    "title": "Beyond the Notebook",
    "section": "Practical Example: Plotting Module",
    "text": "Practical Example: Plotting Module\nCreate plotting.py:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_parabola(a, b, c, xlo=0, xhi=10, npoints=100):\n    x = np.linspace(xlo, xhi, npoints)\n    y = a * x**2 + b * x + c\n    \n    plt.figure()\n    plt.plot(x, y, 'b-', linewidth=2)\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title(f'Parabola: y = {a}x² + {b}x + {c}')\n    plt.grid(True)\n    plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "href": "slides/11_beyond_notebook_slides.html#using-custom-modules",
    "title": "Beyond the Notebook",
    "section": "Using Custom Modules",
    "text": "Using Custom Modules\nImport your module:\nimport plotting as plt_mod\n\n# Use your custom function\nplt_mod.plot_parabola(a=1, b=-2, c=1)\nBenefits of modules: - Reusability: Use same code across projects - Organization: Separate concerns - Maintainability: Update code in one place - Collaboration: Share functionality"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "href": "slides/11_beyond_notebook_slides.html#bash-command-options",
    "title": "Beyond the Notebook",
    "section": "Bash Command Options",
    "text": "Bash Command Options\nCommands often have options using - syntax:\n# List files in long format\nls -l\n\n# List files in reverse time order\nls -lt\n\n# Get help for any command\ncommand_name --help\nCommon file operations:\n# Move/rename files\nmv old_name.py new_name.py\n\n# Copy files\ncp source.py destination.py\n\n# Remove files (careful!)\nrm filename.py"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "href": "slides/11_beyond_notebook_slides.html#script-vs.-notebook-output",
    "title": "Beyond the Notebook",
    "section": "Script vs. Notebook Output",
    "text": "Script vs. Notebook Output\nNotebook execution: - Output appears inline - Variables remain in memory - Interactive environment\nScript execution: - Output goes to terminal/file - No persistent variables - One-time execution - For plots: use plt.savefig() instead of plt.show()"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#best-practices",
    "href": "slides/11_beyond_notebook_slides.html#best-practices",
    "title": "Beyond the Notebook",
    "section": "Best Practices",
    "text": "Best Practices\nWhen to use scripts: - Reusable functions - Production code - Automated tasks - Sharing with others\nWhen to use notebooks: - Exploratory analysis - Documentation with results - Teaching/presentations - Prototyping\nModule organization: - Group related functions - Clear, descriptive names - Add docstrings to functions"
  },
  {
    "objectID": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "href": "slides/11_beyond_notebook_slides.html#key-takeaways",
    "title": "Beyond the Notebook",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nFile system navigation with bash commands\nScripts are portable, reusable Python code\nTerminal provides direct system access\nModules enable code organization and reuse\nChoose the right tool: notebooks for exploration, scripts for production\nPractice using both environments effectively\n\nNext steps: Start organizing your code into reusable modules!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This is the course material for Introduction to coding and data analysis, SCIF10002.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#welcome-to-the-course",
    "href": "index.html#welcome-to-the-course",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "This is the course material for Introduction to coding and data analysis, SCIF10002.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Introduction to Coding and Data Analysis",
    "section": "How to use",
    "text": "How to use\n\nYou will find the more theoretical introduction under Lesson\nThe hands-on exercises will be under Exercises\nOver the course of the weeks the solutions will be released under Solutions\nRegularly, interactive formative tests will be released under Formative tests\n\nImportant. You can use the search button 🔎 to search across all the pages and skim through the course.\nNote. Many of the following pages also allow you to interact with the code by running Python snippets inside your browser. It is useful\n\nAs a fallback option if Noteable is unreachable.\nFor the regularly released formative tests.\n\nNote. In the online cells, you press\n\nCtrl/Cmd+Enter to run ▶ the cell\nCtrl/Cmd+] to indent ⇥\nCtrl/Cmd+[ to unindent ⇤\n\nThe content in this website mirrors the interactive notebooks released on Noteable.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Getting Started",
    "text": "Getting Started\nNavigate through the course using the sidebar or the navigation menu above. Each Week builds upon the previous one, so it’s recommended to work through them in order.",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Features",
    "text": "Features\n\nInteractive Jupyter notebooks\nStep-by-step exercises with solutions\nComprehensive coverage of NumPy and Matplotlib\nReal-world examples and applications",
    "crumbs": [
      "Home",
      "Course Overview",
      "Introduction to Coding and Data Analysis"
    ]
  },
  {
    "objectID": "10/slides_multidarray.html",
    "href": "10/slides_multidarray.html",
    "title": "Multi-dimensional Arrays",
    "section": "",
    "text": "numpy arrays can be multi-dimensional, not just 1D lists.\n\n1D array: a sequence of numbers\n2D array: a grid (rows and columns)\n3D array: a cuboid\nAnd so on…\n\nThe key property is shape - the size of each dimension."
  },
  {
    "objectID": "10/slides_multidarray.html#what-are-multi-dimensional-arrays",
    "href": "10/slides_multidarray.html#what-are-multi-dimensional-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "",
    "text": "numpy arrays can be multi-dimensional, not just 1D lists.\n\n1D array: a sequence of numbers\n2D array: a grid (rows and columns)\n3D array: a cuboid\nAnd so on…\n\nThe key property is shape - the size of each dimension."
  },
  {
    "objectID": "10/slides_multidarray.html#creating-a-2d-array",
    "href": "10/slides_multidarray.html#creating-a-2d-array",
    "title": "Multi-dimensional Arrays",
    "section": "Creating a 2D Array",
    "text": "Creating a 2D Array\nSimple example: you can create a 2D array with random numbers by specifying the shape of the array"
  },
  {
    "objectID": "10/slides_multidarray.html#indexing-in-2d",
    "href": "10/slides_multidarray.html#indexing-in-2d",
    "title": "Multi-dimensional Arrays",
    "section": "Indexing in 2D",
    "text": "Indexing in 2D\nWe extend the one dimensional notation by putting the desired index in a sequence separated by commas. For example, in 2D, access elements using row, column notation:\n\n\n\n\n\n\nRemember: indices start at 0, and order is [row, column] (like [y, x])."
  },
  {
    "objectID": "10/slides_multidarray.html#selecting-rows-and-columns",
    "href": "10/slides_multidarray.html#selecting-rows-and-columns",
    "title": "Multi-dimensional Arrays",
    "section": "Selecting Rows and Columns",
    "text": "Selecting Rows and Columns\nUse the : operator to select entire dimensions:\n\n\n\n\n\n\nThe : means “all elements” in that dimension."
  },
  {
    "objectID": "10/slides_multidarray.html#array-shape-and-initialization",
    "href": "10/slides_multidarray.html#array-shape-and-initialization",
    "title": "Multi-dimensional Arrays",
    "section": "Array Shape and Initialization",
    "text": "Array Shape and Initialization\nCreate arrays with specific shapes using familiar functions:\n\n\n\n\n\n\nShape is always a tuple: (rows, columns) for 2D."
  },
  {
    "objectID": "10/slides_multidarray.html#rank-dimensions",
    "href": "10/slides_multidarray.html#rank-dimensions",
    "title": "Multi-dimensional Arrays",
    "section": "Rank = Dimensions",
    "text": "Rank = Dimensions\nThe number of dimensions (i.e. the number of indices needed to access an element) is called the rank of the array. Rank = number of dimensions, accessible via .ndim:"
  },
  {
    "objectID": "10/slides_multidarray.html#operations-along-axes",
    "href": "10/slides_multidarray.html#operations-along-axes",
    "title": "Multi-dimensional Arrays",
    "section": "Operations Along Axes",
    "text": "Operations Along Axes\nIt is very useful to be able to perform operations only along specific dimensions (axes) of an array. If you think that a 2d array is like a table, we can in one go compute useful operations like the sum of each column, or the mean of each row by specifiying the axis along which to perform the operation.\n\n\n\n\n\n\naxis=0 operates on rows, axis=1 operates on columns."
  },
  {
    "objectID": "10/slides_multidarray.html#statistical-operations",
    "href": "10/slides_multidarray.html#statistical-operations",
    "title": "Multi-dimensional Arrays",
    "section": "Statistical Operations",
    "text": "Statistical Operations\nApply statistics along axes too:\n\n\n\n\n\n\nWorks with mean, std, min, max, etc."
  },
  {
    "objectID": "10/slides_multidarray.html#slicing-multi-dimensional-arrays",
    "href": "10/slides_multidarray.html#slicing-multi-dimensional-arrays",
    "title": "Multi-dimensional Arrays",
    "section": "Slicing Multi-dimensional Arrays",
    "text": "Slicing Multi-dimensional Arrays\nSlicing is the operation of selecting sub-portions of an array. With multi-dimensional arrays, you can slice along multiple axes at once by re-using the syntax we saw for 1D arrays, but separating the slices for each dimension with commas."
  },
  {
    "objectID": "10/slides_multidarray.html#flattening-ravel-vs-flatten",
    "href": "10/slides_multidarray.html#flattening-ravel-vs-flatten",
    "title": "Multi-dimensional Arrays",
    "section": "Flattening: ravel() vs flatten()",
    "text": "Flattening: ravel() vs flatten()\nAFrequently we convert higher dimensional arrays to a simple one-dimnensional sequence of numbers (this is for example very common in machine learning applications where for example images get mapped onto a vector).\nThere aare dedicated ways to do this:"
  },
  {
    "objectID": "10/slides_multidarray.html#broadcasting",
    "href": "10/slides_multidarray.html#broadcasting",
    "title": "Multi-dimensional Arrays",
    "section": "Broadcasting",
    "text": "Broadcasting\nnumpy allows us in general to avoid teh usage of for loops. A particularly nice featre is that numpy tries automatically to expand arrays of different shapes to make operations possible. This is called broadcasting.\n\n\n\n\n\n\nnumpy expands the smaller array to match the larger one."
  },
  {
    "objectID": "10/slides_multidarray.html#matrices-as-images",
    "href": "10/slides_multidarray.html#matrices-as-images",
    "title": "Multi-dimensional Arrays",
    "section": "Matrices as Images",
    "text": "Matrices as Images\nOne very interesting use of numpy multi dimensional array is to represent images.\nAn image is the n a grid of numbers, and every number is a apixel with its intensity level. Then, 2D arrays can represent grayscale images:\n\n\n\n\n\n\nEach number is a pixel intensity value."
  },
  {
    "objectID": "10/slides_multidarray.html#working-with-color-images",
    "href": "10/slides_multidarray.html#working-with-color-images",
    "title": "Multi-dimensional Arrays",
    "section": "Working with Color Images",
    "text": "Working with Color Images\nColor images are 3D arrays: (height, width, channels)\n\n\n\n\n\n\nThree channels: Red, Green, Blue (RGB)."
  },
  {
    "objectID": "10/slides_multidarray.html#boolean-indexing-on-images",
    "href": "10/slides_multidarray.html#boolean-indexing-on-images",
    "title": "Multi-dimensional Arrays",
    "section": "Boolean Indexing on Images",
    "text": "Boolean Indexing on Images\nWe saw boolean indexing with numpy vectors. Well, the same principle applies to multi-dimensional arrays. We can perform tests and conditions on arays to produce new arrays with the same shape but with True/False values that we can use as masks to filter the original array."
  },
  {
    "objectID": "10/slides_multidarray.html#logical-operations-on-masks",
    "href": "10/slides_multidarray.html#logical-operations-on-masks",
    "title": "Multi-dimensional Arrays",
    "section": "Logical Operations on Masks",
    "text": "Logical Operations on Masks\nLogical arrays can be combined element-by-element using logical operators:\n\n\n\n\n\n\nUse & (AND), | (OR), ~ (NOT)."
  },
  {
    "objectID": "10/slides_multidarray.html#key-takeaways",
    "href": "10/slides_multidarray.html#key-takeaways",
    "title": "Multi-dimensional Arrays",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nMulti-dimensional arrays have shape and rank\nIndex with [row, column] notation\nOperations can work along specific axes\nReshape and flatten change array structure\nBroadcasting automatically expands arrays\n2D/3D arrays represent images naturally\nBoolean indexing creates powerful masks"
  },
  {
    "objectID": "10/slides_multidarray.html#pair-programming-exercise",
    "href": "10/slides_multidarray.html#pair-programming-exercise",
    "title": "Multi-dimensional Arrays",
    "section": "Pair programming exercise",
    "text": "Pair programming exercise\n\nFirst, have a look at the multi-dimensonal array lecture material and understand its conent\nThen, try to work accorcin to the pair programming paradigm:\n\nOne person is the “driver” (writes the code)\nThe other is the “navigator” (reviews, suggests, finds docs)\n\nYou have two exercises :\n\nCreating a mask containing a circle\nUsing a mask\n\nStudent A starts as driver, Student B as navigator in exercise 1 and they switch roles in exercise 2.\nDiscuss and agree on the solution together\nAlteranatively, you can also work alone if you prefer so."
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html",
    "href": "10/lecture_multidimensionalArrays.html",
    "title": "Multi-dimensional arrays",
    "section": "",
    "text": "A numpy.ndarray is the more complete term for a numpy array object. Up until this point we have mainly been dealing with and using one dimensional arrays. Numpy arrays (unlike lists) have the concept of shape whicih means they can be multi-dimensional. This means they can represent a grid (2D), a cuboid (3D) and so forth.\nThe code below generates a numpy.array object containing random numbers. This is a 2D array with a 3 x 3 shape:\nWe can select one element from this array using the following syntax. We still use square brackets and pass an index value but now we can pass values for each dimension seperated by a comma (,). This index is selecting the third column within the second row:\nUsing slicing (Start:Stop) syntax you can select an entire dimension at once by omitting both the Start and Stop values and just using :. You can see how this works if you try the slice with just the Start or just the Stop e.g.\nNot including a Start index includes values from the beginning of the array/list etc. up to (but not including) the Stop.\nNot including a Stop index reads from the Start to the end of the array/list etc.\nSo just using : with no Start or Stop selects all elements for that dimension.\nThis following syntax returns first row (first row, every column):\nAnd this would return the first column (every row, first column):\nnumpy array objects store data in row-major order. Essentially this means for a 2D index this would be the equivalent of [y, x] rather than [x, y].",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "href": "10/lecture_multidimensionalArrays.html#basic-properties-of-multi-dimensional-arrays",
    "title": "Multi-dimensional arrays",
    "section": "Basic properties of multi-dimensional arrays",
    "text": "Basic properties of multi-dimensional arrays\n\nShape\nThe shape of a multi-dimensional array is a tuple that describes the size of each dimension. For example, a 2D array with 3 rows and 4 columns has a shape of (3, 4). You can access the shape of an array using the .shape attribute.\nWe can use many of the array initialisation functions we haver seen for 1d arrays also to create multi-dimensional arrays. For example, we can use np.zeros to create a 2D array of zeros, or np.ones to create a 2D array of ones. We can also use np.random.rand to create a 2D array of random numbers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAxis and Rank\nA multi-dimensional array has multiple dimensions, each of which can be thought of as an axis. The number of dimensions is called the rank of the array. For example, a 2D array has a rank of 2, while a 3D array has a rank of 3. It is accessible via the .ndim attribute.\nWe typically call a rank 2 array a matrix. A rank 3 array (or higher) is often called a tensor.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can perform operations along specific axes of a multi-dimensional array. For example, we can sum all the elements along a specific axis using the np.sum function with the axis parameter.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOne can do the same also with useful statistical descriptors such as np.mean, np.std, etc.\n\n\n\n\n\n\n\n\nSlicing\nSlicing works similarly to 1D arrays, but you can slice along multiple axes. For example, you can slice a 2D array to get a submatrix or a specific row or column.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReshaping and flattening\nThe last example show an inetresting case: we extracted a single column from the matrix, but it is still a 2D array with shape (3, 1).\n\n\n\n\n\n\nWhat if we wanted a truly 1d array (rank 1)? We need to reshape the array.\nWe can use the np.reshape function to change the shape of an array without changing its data. For example, we can reshape a 2D array into a 1D array or vice versa.\nReshape takes a tuple of the new shape as an argument. If you want to flatten an array (convert it to a 1D array), you can use -1 as one of the dimensions, which tells NumPy to infer the size of that dimension based on the total number of elements.\n\n\n\n\n\n\n\n\n\n\n\n\nAnother way to cast a multi-dimensional array to a 1D array is to use the np.ravel() function, which returns a flattened view of the array (not a copy).\n\n\n\n\n\n\nIf we modify the view, we modify the original array as well.\n\n\n\n\n\n\nTo obtain a completely independent flattened copy of the array, you can use the np.flatten() method, which returns a copy of the array in a 1D format.\n\n\n\n\n\n\nWe can also do the opposite and increase the rank of an array by reshaping it. For example, we can reshape a 1D array into a 2D array with one column or one row.\n\n\n\n\n\n\n\n\nBroadcasting\nCombining arrays of different shapes is possible in NumPy using a feature called broadcasting. Broadcasting allows NumPy to perform operations on arrays of different shapes by automatically expanding the smaller array to match the shape of the larger one.\n\n\n\n\n\n\nYou can reshape a 1D array to a column or row vector and use broadcasting to expand it into a large table. For example, to create a table where each row is the original 1D array, or each column is the original array:",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "href": "10/lecture_multidimensionalArrays.html#two-dimensional-arrays-as-matrices-some-linear-algebra",
    "title": "Multi-dimensional arrays",
    "section": "Two-dimensional arrays as matrices: some linear algebra",
    "text": "Two-dimensional arrays as matrices: some linear algebra\nTwo-dimensional arrays are often used to represent matrices or images. In a matrix, each element can be accessed using two indices: - one for the row - one for the column.\nA matrix is a rectangular array of numbers, symbols, or expressions arranged in rows and columns and is an essential concept in linear algebra.\nFor examplle, let’s consider the simple system of simultaneous equations:\n\\[ \\begin{align*}\n2x + 3y +z &= 5 \\\\\n4x - y &= 1 \\\\\n2y +z &= 3\n\\end{align*} \\]\nThis can be represented in matrix form as: \\[ \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\n\\end{bmatrix}\n=\n\\begin{bmatrix}5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nAnd if we call \\(A\\) the matrix of coefficients, \\(\\mathbf{x}\\) the vector of variables, and \\(b\\) the vector of constants, we can write this as: \\[ A \\mathbf{x} = \\mathbf{b} \\]\nwhere \\[A = \\begin{bmatrix}\n2 & 3 &1  \\\\\n4 & -1 &0 \\\\\n0 & 2 &1\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\nx \\\\\ny\\\\\nz\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5 \\\\\n1\\\\\n3\n\\end{bmatrix} \\]\nA key result of linear algebra is that if \\(A\\) is invertible, we can solve for \\(\\mathbf{x}\\) by multiplying both sides of the equation by the inverse of \\(A\\): \\[ \\mathbf{x} = A^{-1} \\mathbf{b} \\]\nwhere \\(A^{-1}\\) is the inverse of matrix \\(A\\).\nNumPy has a dedicated linear algebra submodule called numpy.linalg that provides functions for performing various linear algebra operations, including matrix inversion, solving systems of equations, and computing eigenvalues and eigenvectors.\n\n\n\n\n\n\nThe linear algebra submodule has a function called solve which can be used to solve the above equation efficiently:\n\n\n\n\n\n\nBut we can use numpy to verify that this is correct. We can use the symbol @ to perform matrix multiplication in numpy.\n\n\n\n\n\n\nWe can also directly calculate the inverse of a matrix using the inv function from the numpy.linalg and use it to solve the equation\n\n\n\n\n\n\nAll the most common linear algebra operations are available in the numpy.linalg submodule:\n\ntranpose\n\n\n\n\n\n\n\n\nscalar (dot) product (which takes two vectors and returns a scalar)\n\n\n\n\n\n\n\n\ncross product\n\n\n\n\n\n\n\nLinear algebra applications are beyond the scope of this course (so, there will be no assessment of these), but they are widely used in various fields such as physics, computer science, and engineering. For example, they are essential in computer graphics for transformations, in machine learning for optimization, and in physics for solving systems of equations. So it is important for you to know that all these can be implemented efficiently using numpy.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "href": "10/lecture_multidimensionalArrays.html#matrices-as-images",
    "title": "Multi-dimensional arrays",
    "section": "Matrices as images",
    "text": "Matrices as images\nA two-dimensional table of numbers can also be used to represent an image. Each number in the table corresponds to a pixel in the image, and the value of the number represents the color or intensity of that pixel.\nmatplotlib provides a convenient way to visualize 2D arrays as images. The matshow function can be used to display a 2D matrix as an image, where the values in the array are mapped to colors.\n\n\n\n\n\n\nNotice that the indices of the y-axis increase as we go down. These are the indices of the rows in the matrix.\nFor a matrix of a given shape we can get the indices using the np.indices function, which returns a grid of indices for each dimension. This can be useful for creating masks or selecting specific regions of the matrix.\n\n\n\n\n\n\nAn alternative function is imshow, which is more general and can be used for both 2D arrays and images.\nHere we can set the origin of the axis:\n\n\n\n\n\n\n\n\n\n\n\n\nThe main difference between matshow and imshow is that matshow is specifically designed for displaying matrices, while imshow is more general and can be used for both 2D arrays and images. matshow automatically adjusts the aspect ratio to make the matrix square, while imshow does not. Also the interpolation method used by matshow is different from that used by imshow, which can affect the appearance of the image.\nImages are represneted as 3d arays: every entry is a the intensity of a pixel (if the image is grayscale) or the intensity of a colour (e.g. red, green or blue) if the image is in colour.\n\n\n\n\n\n\nLet’s take a colour image\n\n\n\n\n\n\nThis is no longer just a 2d array, it has a third dimension for the colour channels (red, green, blue). We can access the individual colour channels by slicing the array along the third dimension.\n\n\n\n\n\n\nWe can slice the array to get the various channels (notice that we specify the colormap cmap argument to display the channels in the appropriate colour):\n\n\n\n\n\n\nIf we want to subsample regions of an image, we can simply slice the array further in its rows and columns.\n\n\n\n\n\n\nWe can also use boolean indexing to filter the image based on conditions.\nFor example, we can binarise it by applying a threshold\n\n\n\n\n\n\nWe can even perform logical operations using numpy\n\nAND with &\nOR with |\nNOT with ~ or np.logical_not",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/lecture_multidimensionalArrays.html#pair-programming",
    "href": "10/lecture_multidimensionalArrays.html#pair-programming",
    "title": "Multi-dimensional arrays",
    "section": "Pair programming",
    "text": "Pair programming\nThe following exercise will allow you explore multi-dimensional arrays by working in pairs. One person will write the code, while the other will explain what the code does. You can switch roles after each exercise.\nThere are two parts so, you can switch roles after each part.\n\nPart1\nPart2",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Multi-dimensional arrays"
    ]
  },
  {
    "objectID": "10/exercises_part2.html",
    "href": "10/exercises_part2.html",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#pair-programming-part-2",
    "href": "10/exercises_part2.html#pair-programming-part-2",
    "title": "Using a mask",
    "section": "",
    "text": "For the second part of this activity you will remain in the same pairs/threes as the first part and you should continue writing code in the same way using pair programming. However, you should swap your roles, so one of the people directing (the navigator) should now be writing the code (the driver) and vice versa.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#masking-a-galaxy",
    "href": "10/exercises_part2.html#masking-a-galaxy",
    "title": "Using a mask",
    "section": "Masking a galaxy",
    "text": "Masking a galaxy\nOne application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\n\n\n\n\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\n\n\n\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2.html#creating-an-elliptical-mask",
    "title": "Using a mask",
    "section": "Creating an elliptical mask",
    "text": "Creating an elliptical mask\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\n\n\n\n\n\n\nEquations for an ellipse\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\n\n\n\n\n\n\n\n\nExercise B\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTake time to discuss this but if you are both really stuck, there is a hint notebook available which shows how you would apply a mask which includes a rectangle to an image.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/exercises_part2.html#calculating-the-magnitude",
    "href": "10/exercises_part2.html#calculating-the-magnitude",
    "title": "Using a mask",
    "section": "Calculating the magnitude",
    "text": "Calculating the magnitude\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\nExercise C\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Using a mask"
    ]
  },
  {
    "objectID": "10/hint2_apply_mask.html",
    "href": "10/hint2_apply_mask.html",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "",
    "text": "Example: Applying a mask containing a rectangle to an image\nI have downloaded an online image of a house for this example (from Vector Stock). This image contains four different rooms and I want to use a rectangular mask so that only the office room is displayed. As described previously, we can open this image using a the Image sub-module of a module called pillow (imported as PIL) which understands how to read image files. We can then convert this input into a numpy array object.\nim is a three dimensional numpy array object - includes height, width and colour channel (R, G, B).\nThe imshow function knows how to interpret this 3D shape to show a colour image."
  },
  {
    "objectID": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "href": "10/hint2_apply_mask.html#create-a-rectanglar-mask-using-a-function",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Create a rectanglar mask using a function",
    "text": "Create a rectanglar mask using a function\nI can define an function called inside_rectangle() to tell me whether a given (x, y) position is within a rectangle for a set of parameters. This will return True if the position is inside the rectangle and False otherwise.\nThe rectangle can be evaluated using the conditions:\n\\[|x - x_0| = w/2\\] and \\[|y - y_0| = h/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the rectangle - \\(w\\), \\(h\\) - are the full width and height of the rectangle - \\(| |\\) means the magnitude of the difference\n\n\n\n\n\n\nFor this mask, I want to define the parameters as follows:\n\n\n\n\n\n\nThe inside_rectangle function allows you to pass the parameters for your position and your rectangle and can tell you whether the position is within your rectangle (returns a True value) or not (returns a False value). For example if we had a position of (50, 50) we could use the function as follows:\n\n\n\n\n\n\nHere we used the output of inside_rectangle as our condition directly (Python sees this if True or if False and follows the logic accordingly).\nWe can use the inside_rectangle() function to define our mask - looping over every element and checking the x, y position with the inside_rectangle() function with the appropriate parameters:\n\n\n\n\n\n\nAs before, we don’t need an else block here because the array we have defined already contains zeros.\nExtended: See alternative numpy method mask in Hint 1 notebook for a more efficient way to create a square mask. Could you extend this method to reproduce a rectangular mask (without the need for the inside_rectangle function)?"
  },
  {
    "objectID": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "href": "10/hint2_apply_mask.html#apply-mask-to-the-image",
    "title": "Hint 2 - applying a rectangular mask",
    "section": "Apply mask to the image",
    "text": "Apply mask to the image\nNow we have created rect_mask, we need to apply this to my image. We can do this by multiplying im by rect_mask and this will combine element-wise. This means that each pixel in the image will be multiplied by the corresponding value within the mask. Multipying by 0 will result in the output pixel also being 0 but multiplying by 1 will retain the original value in that pixel.\nFor creating the im_masked output there a few ways you could do this - the upshot is that you want to create an array of the right shape: - Create an empty array of the right shape - Create a new variable called im_masked which is a copy of the im using the copy() function (method)\nBecause im is a three dimensional array (height x weight x colour channel), one way to apply the mask is to do this for each of the three colours (R, G, B channels) separately."
  },
  {
    "objectID": "17/lecture_advanced_plotting.html",
    "href": "17/lecture_advanced_plotting.html",
    "title": "Advanced Plotting with Python",
    "section": "",
    "text": "In previous lectures, we have explored the fundamentals of data visualization using matplotlib and pandas. We learned how to create basic plots such as line plots, scatter plots, and histograms.\nAs data analysis becomes more sophisticated, there are often cases where we want to explore data in more complex ways:\nIn this lecture, we will explore these three powerful plotting approaches and learn how to combine them with pandas DataFrames for effective data exploration and communication."
  },
  {
    "objectID": "17/lecture_advanced_plotting.html#d-plotting-with-matplotlib",
    "href": "17/lecture_advanced_plotting.html#d-plotting-with-matplotlib",
    "title": "Advanced Plotting with Python",
    "section": "3D Plotting with Matplotlib",
    "text": "3D Plotting with Matplotlib\nMatplotlib’s mplot3d toolkit enables the creation of 3D plots. This is particularly useful when you want to visualize three continuous variables simultaneously or show relationships between multiple dimensions.\nTo use 3D plotting capabilities, we need to import the necessary libraries.\n\n\n\n\n\n\n\nCreating a 3D Scatter Plot\nLet’s start by creating some sample 3D data and visualizing it with a scatter plot.\n\n\n\n\n\n\nNow let’s create a 3D scatter plot. When we call plt.figure(), we specify projection='3d' to create a 3D axis.\n\n\n\n\n\n\n\n\nCreating a 3D Surface Plot\nSurface plots are useful for visualizing functions of two variables, such as z = f(x, y).\n\n\n\n\n\n\n\n\nControlling the Viewing Angle\nOne of the advantages of 3D plots in matplotlib is the ability to rotate the view. You can use the view_init() method to set the elevation and azimuth angles. These are defined as follows\n\nElevation Angle\nControls the vertical tilt of the viewing perspective. An elevation of 0° views the plot from the side, 90° views it from directly above, and negative values tilt the view downward.\n\n\nAzimuth Angle\nControls the horizontal rotation around the plot. It determines which direction you’re “looking” at the 3D object. Common values are 0° (front view), 90° (right side), 180° (back view), and 270° (left side).\nTogether, these angles allow you to rotate a 3D plot to any desired perspective. For example: - view_init(elev=30, azim=45) gives a standard 3D perspective view - view_init(elev=90, azim=0) views the plot from directly above - view_init(elev=0, azim=0) views it from the front at ground level"
  },
  {
    "objectID": "17/lecture_advanced_plotting.html#statistical-plotting-with-seaborn",
    "href": "17/lecture_advanced_plotting.html#statistical-plotting-with-seaborn",
    "title": "Advanced Plotting with Python",
    "section": "Statistical Plotting with Seaborn",
    "text": "Statistical Plotting with Seaborn\nseaborn is built on top of matplotlib and provides a higher-level interface for creating statistical graphics. It integrates well with pandas DataFrames and automatically handles common tasks like aggregating data, computing statistics, and creating legends.\nSome key advantages of seaborn are:\n\nBeautiful default styles: Professional-looking plots out of the box\nStatistical estimation: Automatic computation of error bars, confidence intervals, and regression lines\nEasy multi-plot grids: Functions like FacetGrid for creating faceted plots\nColor palettes: Rich color palette options for categorical data\n\nYou can find th complete documentation for seaborn (with lots of examples) at https://seaborn.pydata.org\n\n\n\n\n\n\n\nScatter Plots with Regression Lines\nOne of seaborn’s most powerful functions is regplot(), which creates a scatter plot with a fitted line and confidence interval.\nThis is useful whn we want to find trends in the data. At the moment, this is a pure black box. We will see more about fitting in the next workshops.\n\n\n\n\n\n\n\n\nCategorical Plots\nOften data is labelled by groups: types of experiments; locations; species; gender; status (“active”, “pending”) and infinitely many others.\nseaborn provides several functions for visualizing categorical data. An extremely common way to visualise categorical data are box plots:\nBox plots provide a compact summary of a distribution for a numerical variable (e.g. the marks in an assessment), typically grouped by a categorical variable (the school of affiliation of the marked students).\nThe box plot is centered around the idea of quartiles: - Q1 (first quartile): 25th percentile - Q2 (second quartile): 50th percentile (median) - Q3 (third quartile): 75th percentile - Q4 (fourth quartile): 100th percentile (maximum)\nThese components are visualized as follows:\n\nBox: interquartile range (IQR = Q3 − Q1), showing the middle 50% of data\n\nMedian: line inside the box (Q2)\n\nWhiskers: extend to the most extreme data points within 1.5 × IQR from the quartiles (common convention)\n\nOutliers: individual points beyond the whiskers, plotted separately\n\nNotches (optional): approximate confidence interval around the median\n\nThe boxplot() function creates box plots grouped by categories, while stripplot() shows individual data points over the boxplot itself.\n\n\n\n\n\n\n\n\nHeatmaps\nHeatmaps are useful for visualizing 2D arrays of data, particularly correlation matrices or contingency tables.\n\n\n\n\n\n\n\n\nMulti-plot Grids\nThe FacetGrid function allows you to create grids of plots, one for each value of a categorical variable. This is powerful for comparing patterns across different subsets of data."
  },
  {
    "objectID": "17/lecture_advanced_plotting.html#interactive-plotting-with-plotly",
    "href": "17/lecture_advanced_plotting.html#interactive-plotting-with-plotly",
    "title": "Advanced Plotting with Python",
    "section": "Interactive Plotting with Plotly",
    "text": "Interactive Plotting with Plotly\nplotly is a powerful library for creating interactive, web-based visualizations. Unlike matplotlib, which creates static images, plotly plots are interactive and allow users to:\n\nHover over data points to see values\nZoom and pan to focus on regions of interest\nToggle data series on and off using the legend\nExport plots as PNG images\n\nPlotly integrates seamlessly with pandas DataFrames through the plotly.express module, which provides a simple interface similar to seaborn.\nPlotly also supports 3D plotting and statistical plots, making it a versatile tool for data visualization.\nAll these features make plotly a great choice for interactive dashboards: these are simple web applications that allow users to explore data through interactive visualizations.\n\n\n\n\n\n\n\nBasic Interactive Scatter Plot\nCreating an interactive scatter plot with plotly is straightforward using plotly.express.scatter().\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive 3D Scatter Plot\nPlotly can create interactive 3D scatter plots where you can rotate the plot using your mouse.\n\n\n\n\n\n\n\n\nInteractive Box and Violin Plots\nPlotly also provides functions for creating interactive statistical plots.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInteractive Line Plots with Multiple Series\nLine plots with plotly allow you to interactively toggle series on and off.\n\n\n\n\n\n\n\n\nAdvanced: Subplots with Plotly\nFor more complex layouts, use plotly.subplots.make_subplots() to create grids of plots."
  },
  {
    "objectID": "17/lecture_advanced_plotting.html#comparison-and-best-practices",
    "href": "17/lecture_advanced_plotting.html#comparison-and-best-practices",
    "title": "Advanced Plotting with Python",
    "section": "Comparison and Best Practices",
    "text": "Comparison and Best Practices\n\nWhen to use each library:\n\n\n\n\n\n\n\n\n\nLibrary\nUse Case\nStrengths\nLimitations\n\n\n\n\nMatplotlib (3D)\nAcademic publications, static images\nFull control, publication-ready\nStatic, requires more code\n\n\nSeaborn\nStatistical analysis, exploratory data analysis\nBeautiful defaults, statistical features\nLess customizable, static plots\n\n\nPlotly\nInteractive dashboards, web applications, presentations\nInteractive, web-ready, modern look\nHeavier file sizes, learning curve\n\n\n\n\n\nRecommendations:\n\nStart with Seaborn for quick exploratory data analysis with minimal code.\nUse Matplotlib (with 3D) when you need publication-quality figures with precise control.\nChoose Plotly when interactivity is important or when creating web-based dashboards.\nCombine libraries: Use pandas to prepare data, seaborn for initial exploration, and plotly for presentations.\n\n\n\nData preparation with pandas:\nAll three libraries work seamlessly with pandas DataFrames: - Both matplotlib and seaborn accept DataFrames through the data= parameter - plotly.express functions work directly with DataFrames - For matplotlib’s 3D plots, extract arrays using .to_numpy() or access columns directly"
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html",
    "href": "16/exercises_pandas_vs_numpy-solutions.html",
    "title": "Numpy vs Pandas: Exercises",
    "section": "",
    "text": "We explore a numerical dataset freely avaible under MIT license on Kaggle, a platform for data science competitions and datasets.\nThe dataset focuses on solar system objects and contains several attributes."
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-1-extracting-numpy-arrays",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-1-extracting-numpy-arrays",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 1: Extracting numpy arrays",
    "text": "Exercise 1: Extracting numpy arrays\n\nSelect the columns semimajorAxis, density, and gravity from the DataFrame df and convert them into a numpy array named np_solar_data.\nThen, design a test (e.g. using an if/else statement or an assert statement) to verify that np_solar_data is indeed a numpy array. Notice that simply printing the type of np_solar_data is not a test!\n\nReminder. An assert statement is a way to test if a condition in your code returns True. If not, the program will raise an AssertionError.\nIt uses the keyword assert followed by the condition to test and an optional error message.\nassert condition, \"Error message if condition is False\"\nHint. If the conversion to numpy array is correct, then the type of np_solar_data should be np.ndarray"
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-2-extracting-basic-statistics",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-2-extracting-basic-statistics",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 2: Extracting basic statistics",
    "text": "Exercise 2: Extracting basic statistics\n\nUsing the numpy array np_solar_data created in Exercise 1, compute the mean and standard deviation for each of the three columns: semimajorAxis, density, and gravity. Store the results in two separate numpy arrays named mean_values and std_values.\nCan you find way to compute these same statistics from the original DataFrame df without converting it to a numpy array? Store these results in two separate pandas Series named mean_series and std_series.\nInspect the stand deviations in the numpy and pandas result. Can you choose parameters such that the results are identical?"
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-3-understanding-pandas-settingwithcopywarning",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-3-understanding-pandas-settingwithcopywarning",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 3: Understanding Pandas SettingWithCopyWarning",
    "text": "Exercise 3: Understanding Pandas SettingWithCopyWarning\nYou want to analyze only the rocky planets by creating a subset and adding a calculated column.\nTask: - Create a subset rocky_planets from df filtering for isPlanet == True and density &gt; 3 - Add a new column mass_estimate to rocky_planets calculated as density * gravity - Observe any warnings that pandas displays - What does the warning mean? Why did it appear?"
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-4-when-views-and-copies-actually-break-your-code",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-4-when-views-and-copies-actually-break-your-code",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 4: When Views and Copies Actually Break Your Code",
    "text": "Exercise 4: When Views and Copies Actually Break Your Code\nThe warning is nice, but let’s see actual unexpected behavior! You’ll try to add a column categorizing planets as inner or outer solar system objects, but the code won’t work as expected.\nNote. There are two types of chained indexing, both problematic:\n\nColumn-then-row: df['column'][condition] = value (select column, then filter)\nRow-then-column: df[condition]['column'] = value (filter rows, then select column)\n\nBoth create intermediate objects (potential copies) before assignment, so modifications may be lost!\n\nReload the DataFrame: df = pd.read_csv(\"kaggle_solar/sol_data.csv\")\nFilter for planets: planets = df[df['isPlanet'] == True].copy()\nInitialize a column: planets['outer_planet'] = False\nTry row-then-column chained indexing: planets[planets['semimajorAxis'] &gt; 5]['outer_planet'] = TrueNote: Objects with semimajorAxis &gt; 5 AU are beyond Jupiter’s orbit (outer solar system).\nCheck if it worked, then use .loc[] to do it correctly"
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-5-extracting-data-and-processing-it-with-numpy-and-matpltolib",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-5-extracting-data-and-processing-it-with-numpy-and-matpltolib",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 5: extracting data and processing it with numpy and matpltolib",
    "text": "Exercise 5: extracting data and processing it with numpy and matpltolib\nWe now want to extract data and process it with numpy functions.\n\nUsing numpy or pandas extract the escape velocity and the mass in kg for all the objects and plot them in a scatter plot using matplotlib.\nConsider that th escape velocity can be calculated as follows:\n\n\\[\nv_{e s c}=\\sqrt{2 g R}\n\\]\nwhere: - \\(g\\) is the surface gravity - \\(R\\) is the radius of the object in\n\nImprove your plotting to illustrate this relationship explicitly (e.g. by changing the scales, plotting guides to the eye, etc.). Note that the radius is in km, the escape veclocity is in m/s, and the gravity is in m/s²."
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-6-string-operations---pandas-vs-numpy",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-6-string-operations---pandas-vs-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 6: String Operations - Pandas vs NumPy",
    "text": "Exercise 6: String Operations - Pandas vs NumPy\nExtract planet names and convert them to uppercase using both pandas and numpy approaches.\nTask: - Filter the DataFrame to get only planets (where isPlanet == True) - Extract the planet names (column eName) using pandas methods and convert them to uppercase (UPPERCASE). Store this in a variable named pandas_upper_names - Now try to do the same using numpy: convert the eName column to a numpy array and apply string operations:\n- you can use a for loop to iterate through the names and convert them to uppercase (e.g. via list comprehension)\n- or use `numpy.char` sub module for vectorized string operations\n\nWhich approach is easier for string operations?"
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-7-grouping-and-aggregation---pandas-vs-numpy",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-7-grouping-and-aggregation---pandas-vs-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 7: Grouping and Aggregation - Pandas vs NumPy",
    "text": "Exercise 7: Grouping and Aggregation - Pandas vs NumPy\nCalculate the mean density for planets vs non-planets using pandas groupby, then try to replicate this in numpy.\nTask: - Use pandas groupby() to compute the mean density grouped by isPlanet (True/False) - Now try to replicate this result using only numpy arrays: - Convert the relevant columns to numpy arrays - Manually separate the data into two groups (planets and non-planets) - Calculate the mean for each group\n\nWhich approach is more convenient? What happens if you need to group by multiple columns?"
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-8-correlation-matrix---pandas-vs-numpy",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-8-correlation-matrix---pandas-vs-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 8: Correlation Matrix - Pandas vs NumPy",
    "text": "Exercise 8: Correlation Matrix - Pandas vs NumPy\nCalculate the correlation matrix for physical properties using pandas and numpy.\nBackground:\nThe covariance between two variables \\(X\\) and \\(Y\\) measures how they vary together: \\[\\text{cov}(X,Y) = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_i - \\bar{x})(y_i - \\bar{y})\\]\nThe correlation coefficient normalizes covariance by the standard deviations: \\[r_{XY} = \\frac{\\text{cov}(X,Y)}{\\sigma_X \\sigma_Y}\\] where \\(\\sigma_X = \\sqrt{\\frac{1}{n-1}\\sum(x_i - \\bar{x})^2}\\) is the standard deviation.\nCorrelation ranges from -1 (perfect negative) to +1 (perfect positive), with 0 meaning no linear relationship.\nStandardization: Transform each variable to have mean = 0 and standard deviation = 1: \\[z_i = \\frac{x_i - \\bar{x}}{\\sigma_x}\\]\nAfter standardization, the correlation matrix can be computed using matrix multiplication.\nTask:\n\nUse pandas .corr() to compute the correlation matrix for density, gravity, and meanRadius\nNow replicate this using numpy by following these steps:\n\nExtract data: Get the three columns as an \\(n \\times 3\\) matrix \\(X\\) (n rows/objects, 3 columns/variables)\nCenter the data: Subtract the mean of each column to get \\(X_{\\text{centered}}\\) (remember that you can use the axis parameter in numpy functions)\nStandardize: Divide each centered column by its standard deviation to get \\(Z\\) (the standardized matrix)\nCompute correlation: The correlation matrix is \\(R = \\frac{1}{n-1} Z^T Z\\) (a \\(3 \\times 3\\) matrix)\nCompare with the pandas result\n\n\nNote: The matrix \\(Z\\) has shape \\((n \\times 3)\\), so \\(Z^T\\) has shape \\((3 \\times n)\\), and their product gives a \\((3 \\times 3)\\) correlation matrix."
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy-solutions.html#exercise-9-creating-a-theoretical-model-visualization-with-numpy",
    "href": "16/exercises_pandas_vs_numpy-solutions.html#exercise-9-creating-a-theoretical-model-visualization-with-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 9: Creating a Theoretical Model Visualization with NumPy",
    "text": "Exercise 9: Creating a Theoretical Model Visualization with NumPy\nCreate a contour plot showing how escape velocity varies with surface gravity and radius, then overlay real solar system objects.\nScientific Background:\nFrom \\(v_{esc} = \\sqrt{2gR}\\), we can predict escape velocity for any combination of surface gravity \\(g\\) and radius \\(R\\). This creates a “phase space” showing where different types of objects fall.\nTask:\n\nCreate a grid of theoretical values using numpy:\n\nUse np.linspace() to create arrays of gravity values (0.1 to 30 m/s²) and radius values (100 to 100,000 km)\nUse np.meshgrid() to create 2D grids for both variables\nCalculate theoretical escape velocity on this grid using the formula (remember unit conversions!)\n\nCreate a contour plot:\n\nUse plt.contourf() or plt.contour() to plot the theoretical escape velocity\nAdd contour labels showing escape velocity values\nFilter the dataset for the 8 true planets: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\nOverlay these planets on the contour plot using plt.scatter()\n\nInterpretation:\n\nDo the 8 planets fall on the theoretical contours?\nCan you identify different groups among the planets (rocky vs gas/ice giants)?\n\n\nUse the matplotlib documentation at https://matplotlib.org/stable/contents.html if needed."
  },
  {
    "objectID": "11/exercises_python_riddles.html",
    "href": "11/exercises_python_riddles.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\n\n\n\n\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str.\n\n\n\n\n\n\nThe Peak Finder\n\nRiddle: In a list of numbers, a “peak” is a number that is greater than both its neighbors. The first and last elements can only be peaks if they’re greater than their single neighbor. Write find_peaks(data) that returns a list of all peak values (not their positions, just the values).\nExample: In [1, 3, 2, 5, 4, 6, 1], the peaks are [3, 5, 6] because:\n\n3 &gt; 1 and 3 &gt; 2 ✓\n5 &gt; 2 and 5 &gt; 4 ✓\n6 &gt; 4 and 6 &gt; 1 ✓\n\nTest cases:\n\nfind_peaks([1, 3, 2, 5, 4, 6, 1]) → [3, 5, 6]\nfind_peaks([1, 2, 3, 4, 5]) → [5] (only the last element)\nfind_peaks([5, 4, 3, 2, 1]) → [5] (only the first element)\nfind_peaks([1, 1, 1]) → [] (no peaks - they must be strictly greater!)\n\n\nHint: Loop through indices 0 to len(data)-1 and check neighbors carefully at the boundaries.\n\n\n\n\n\n\n\n\n\n\n\n\nThe Frequency Detective\n\nRiddle: In a dataset, you want to find the value that appears most often (the “mode”). But here’s the twist: if there’s a tie, return the smallest value among the most frequent ones. Write find_mode(data) to solve this mystery.\nExample: In [1, 2, 2, 3, 3, 4], both 2 and 3 appear twice. Return 2 (smallest of the tied values).\nTest cases:\n\nfind_mode([1, 2, 2, 3, 3, 4]) → 2 (2 and 3 tied at 2 occurrences, but 2 is smaller)\nfind_mode([5, 5, 3, 3, 3, 1]) → 3 (appears 3 times, most frequent)\nfind_mode([7, 7, 7, 2, 2, 2]) → 2 (tied at 3 occurrences, 2 is smaller)\nfind_mode([4]) → 4 (single element)\n\n\nHint: Count occurrences with a dictionary, find the maximum count, then among all values with that count, return the minimum."
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html",
    "href": "11/lecture_beyond_the_notebook.html",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#our-file-system",
    "href": "11/lecture_beyond_the_notebook.html#our-file-system",
    "title": "Beyond the notebook",
    "section": "",
    "text": "Our notebooks in jupyter do not exist in the void. They are stored in a directory on an online account on the Noteable server. These directories have a structure, the file system, and we can navigate this structure using dedicated commands.\nThese are not python commands, but are in fact specific to the file system itself, and follow different logic and conventions. For this reason, we prepend them with the ! character. At the moment, we will use one command per cell.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#pathway-to-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Pathway to the current directory",
    "text": "Pathway to the current directory\nFirst, let’s check where we are right now in the file system. To do so, we query the pathway to the working directory with the pwd command.\n! pwd\nThis shows where we currently are, and each of you should have a different path, with a different username.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "href": "11/lecture_beyond_the_notebook.html#listing-the-content-of-the-current-directory",
    "title": "Beyond the notebook",
    "section": "Listing the content of the current directory",
    "text": "Listing the content of the current directory\nThe ls command lists the files and directories in the current directory. The current directory is represented by a . (dot).\n! ls",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "href": "11/lecture_beyond_the_notebook.html#creating-a-new-directory",
    "title": "Beyond the notebook",
    "section": "Creating a new directory",
    "text": "Creating a new directory\nThe mkdir command creates a new directory in the specified path. For example, to create a new directory in the current directory we can write\n! mkdir new_directory \nWe can check its existence with ls.\n! ls\nEqually, we can go back to the jupyter interface and see the new directory in the graphical user interface.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#changing-directory",
    "href": "11/lecture_beyond_the_notebook.html#changing-directory",
    "title": "Beyond the notebook",
    "section": "Changing directory",
    "text": "Changing directory\nIt is easy to change the current directory with the cd command. For example, to go to the new_directory with\n! cd new_directory\nAnd we we can go back to the previous directory with the cd command again using ..\n! cd ..",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "href": "11/lecture_beyond_the_notebook.html#creating-an-empty-file",
    "title": "Beyond the notebook",
    "section": "Creating an empty file",
    "text": "Creating an empty file\nThe touch command creates a new file in the specified path. For example, to create a new file in the current directory we can write\n! touch new_directory/new_file.txt\nWe can check its existence with ls.\n! ls new_directory\nWe can open this file in the graphical user interface and edit the contents\n[follows demonstration in Noteable with dummy text in the file new_file.txt]",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "href": "11/lecture_beyond_the_notebook.html#viewing-file-content",
    "title": "Beyond the notebook",
    "section": "Viewing file content",
    "text": "Viewing file content\nThe cat command prints the content of a file. For example, to view the content of new_file.txt we can write\n! cat new_directory/new_file.txt \nSeveral other commands exist to display parts of files, such as head, tail etc. Try them if you like!",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise",
    "href": "11/lecture_beyond_the_notebook.html#exercise",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a new jupyter notebook using the graphical user interface.\nFrom the notebook, use the commands above to create:\n\na new directory called src\na new file inside the directory called naive_script.py\nopen it with double click for the files tab in jupyter and write a minimal code\n\nprint(\"Hello, World!\")\n\nsave the file\nuse the cat command from the notebook to view the content of naive_script.py",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "href": "11/lecture_beyond_the_notebook.html#running-scripts-from-the-notebook",
    "title": "Beyond the notebook",
    "section": "Running scripts: from the notebook",
    "text": "Running scripts: from the notebook\nFor the entire duration of this course, you have been running python codes by typing them inside the notebook cells and executing the code cells.\nThe notebooks are complex files, that contain a lot of information beyond your code: the markdown, images, and a lot of extra data (called metadata).\nA much more essential way to store python code is to use scripts. These are files with the .py extension, like your naive_script.py file. Inside a script you can only have\n\npython code\npython comments to the code (i.e. lines prepended by the #)\n\nThis means that the scripts are simple, portable pure text files containing instructions in the python language.\nCan we execute such instructions? Yes, we run a script in various way. A simple way is to do it directly from a code cell in the notebook. For this we use a special jupyter command called run followed by the path to the script.\n[check that you are in the correct path and the script exist]\nrun src/naive_script.py\nAs you can see, we have executed the instructions of the script and its textual output has been printed in the notebook. No variables are created during the process.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#the-terminal",
    "title": "Beyond the notebook",
    "section": "The Terminal",
    "text": "The Terminal\nAll the commands that we have seen above can be used in a pure-text environment called the terminal. The terminal is a text-based interface to an operating system (local or remote).\nYou do not use the mouse to perform actions. Instead, you write commands. These commands belong to the scripting language called bash (see here for more information). It is different from python, they can interact together in the notebook.\nYou can launch a terminal directly from Noteable by clicking on the New button, then selecting Terminal.\n\n\n\nimage.png",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-1",
    "href": "11/lecture_beyond_the_notebook.html#exercise-1",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\n\nWe try to navigate folders from the terminal and create a file\nOpen the terminal and\n\nchange the directory to src (using cd)\ncreate a new file inside the directory called parabola.py (use touch)\ngo back to the Noteable file tab, refresh the web-page and open the parabola.py file\nopen it and write a minimal code to plot a parabola. For example:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\na = 1.\nb =1.\nc = 2\nxlo = 0\nxhi = 10\nnpoints = 100\nx = np.linspace(xlo, xhi, npoints)\ny = a*x**2 + b*x + c\nplt.plot(x,y)\nplt.savefig(\"parabola.png\")\n\n\nsave the file and go back to the Terminal tab\nuse the cat command to check the content",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#exercise-running-scripts-from-the-terminal",
    "title": "Beyond the notebook",
    "section": "Exercise: Running scripts from the Terminal",
    "text": "Exercise: Running scripts from the Terminal\nWe have seen that we can run the scripts from the notebook using the run command. In a very similar way, we can run scripts from the terminal, just by using the python command followed by the path to the script.\nDo the following:\n\nfirst run the parabola script from the notebook using run: you should see the plot appear in the notebook.\nthen go back to the Terminal and run the parabola.py script using the python command followed by the path to the script: e.g. python src/parabola.py. Where is the output?\n\nrun src/parabola.py",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#reusing-code",
    "href": "11/lecture_beyond_the_notebook.html#reusing-code",
    "title": "Beyond the notebook",
    "section": "Reusing code",
    "text": "Reusing code\nThe most useful feature of the scripts is that they can store code for future usage in an organized manner. We do not need to have all of our code in a single notebook: we can split the relvant bits, put them into scripts and use them again and again in different projects.\nWhat allows us to do this is the special python keywork import, that we have already used many times.\nLet’s move our working directory to src and try importing our parabola.py script\ncd src\nIn python we can only import .py files, so we drop the .py extension when importing.\nimport parabola\nNow the variables defined in parabola.py are available in our current notebook.\nprint(parabola.xhi)\nCongratulations! You have written your first python module!",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#exercise-2",
    "href": "11/lecture_beyond_the_notebook.html#exercise-2",
    "title": "Beyond the notebook",
    "section": "Exercise",
    "text": "Exercise\nThe module above is not very useful. A better way to reuse code is to encapsulate it in a **custom .\n\nModify your parabola.py script to create a function plot_parabola that takes a, b, c, xlo, xhi as parameters.\nThen, import your parabola module in the present notebook using the following line:\nimport parabola as pb\nCan you find a way to access your function plot_parabola from pb ?\nImprove your function to customize the appearence of the plot (adding custom labels, colors, linestyles) and use the function with such changes. Important you will need to restart the notebook for these to take effect, because a module is loaded only once.",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "href": "11/lecture_beyond_the_notebook.html#more-exercises-on-the-terminal",
    "title": "Beyond the notebook",
    "section": "More exercises on the terminal",
    "text": "More exercises on the terminal\n\nMost commands in bash allow you to acces their documentation with &lt;name_of_the_command&gt; --help. Can you find out what the command mv does?\n\n##YOUR CODE HERE\n\nFind a way to rename your parabola.py script to geometry.py\n\n##YOUR CODE HERE\nMost commands in bash support options, using the dash - sytax. For example, ls -l will list the files in a long format. Can you use ls --help to find out what the -l option does\nls --help\n\nCan you find an additional option for ls -l to fils files in reverse time order?\n\n##YOUR CODE HERE",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/lecture_beyond_the_notebook.html#riddles",
    "href": "11/lecture_beyond_the_notebook.html#riddles",
    "title": "Beyond the notebook",
    "section": "Riddles",
    "text": "Riddles\nTo revise the material from the previous lectures, we can try to solve some riddles.\nYou can find the exercises here below\n\nPython Riddles\nNumpy Riddles",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Beyond the notebook"
    ]
  },
  {
    "objectID": "11/exercises_numpy_riddles.html",
    "href": "11/exercises_numpy_riddles.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\n\n\n\n\n\nDiagonal Sum:\n\nRiddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal.\nExample: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n\n\n\n\n\n\nUnique Elements Count:\n\nRiddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array.\nExample: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n\n\n\n\n\n\nRandom sample ands cumulative sum:\n\nRiddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n\n\n\n\n\n\nRolling Window:\n\nRiddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size.\nFor example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n\nHint: you can use list comprehension and convert the final list to an array.\n\n\n\n\n\n\nProduct of elements:\n\nRiddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean.\nExample: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n\n\n\n\n\n\nVectorised calculations and visualisation:\n\nRiddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatter() from matplotlib according to their radial coordinate:\n\nuse the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$.\nuse the hexadecimal colour \"ffe701\" for points furtehr away.\n\n\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")"
  },
  {
    "objectID": "11/exercises_riddles.html",
    "href": "11/exercises_riddles.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nRiddles\nWe have two sets of riddles to test your knowledge of Python and NumPy.\n\nPython Riddles: exercises_python_riddles.qmd\nNumPy Riddles: exercises_numpy_riddles.qmd",
    "crumbs": [
      "Home",
      "11 Beyond the Notebook",
      "Riddles"
    ]
  },
  {
    "objectID": "formative/numpy_basics.html",
    "href": "formative/numpy_basics.html",
    "title": "Basic NumPy Arrays and Operations",
    "section": "",
    "text": "This is a formative test. It is an occasion to practice the course material. It does not contribute to your final grade.\nUsing the topics covered within the workshops (or otherwise), complete the questions below.\nMake sure to use any described variable names exactly and do not change the name of this file. This ensures the nbgrader tool can grade your work correctly.\n\n\n\n\nQuestion 1\n1A) Create a NumPy array called numbers containing the values [1, 3, 5, 7, 9].\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse np.array([1, 3, 5, 7, 9]) to create a NumPy array from a list.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nnumbers = np.array([1, 3, 5, 7, 9])\n\n\n\n\n\n1B) Create a NumPy array called zeros_array containing 8 zeros using a NumPy function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse np.zeros(8) to create an array with 8 zeros.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nzeros_array = np.zeros(8)\n\n\n\n\n\n\n\nQuestion 2\n\n\n2A) Access the third element (value 30) from the data array and assign it to a variable called third_element.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nThe third element has index 2.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nthird_element = data[2]\n\n\n\n\n\n2B) Create a slice of the data array containing the last three elements and assign it to last_three.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse negative indexing: data[-3:] to get the last three elements.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nlast_three = data[-3:]\n# Alternative solution:\n# last_three = data[2:]\n\n\n\n\n\n\n\nQuestion 3\n\n\n3A) Multiply all elements in the values array by 3 and assign the result to tripled.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nNumPy allows element-wise operations: values * 3.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\ntripled = values * 3\n\n\n\n\n\n3B) Add the arrays values and tripled together element-wise and assign to sum_array.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse values + tripled for element-wise addition.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nsum_array = values + tripled\n\n\n\n\n\n\n\nQuestion 4\n4A) Create a NumPy array called range_array containing integers from 0 to 9 using np.arange().\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse np.arange(10) to create integers from 0 to 9.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nrange_array = np.arange(10)\n\n\n\n\n\n4B) Calculate the mean (average) of the range_array and assign it to a variable called mean_value.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse np.mean(range_array) or range_array.mean().\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nmean_value = np.mean(range_array)\n# or\nmean_value = range_array.mean()\n\n\n\n\n\n\n\nQuestion 5\n\n\n5A) Find all elements in the measurements array that are greater than 2.5 and assign them to filtered_data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse Boolean indexing: measurements[measurements &gt; 2.5].\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nfiltered_data = measurements[measurements &gt; 2.5]\n\n\n\n\n\n5B) Count how many elements in the measurements array are greater than the mean of the array. Assign this count to count_above_mean.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nFirst calculate the mean, then use np.sum(measurements &gt; mean_value) to count True values.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nmean_val = np.mean(measurements)\ncount_above_mean = np.sum(measurements &gt; mean_val)\n# or in one line:\ncount_above_mean = np.sum(measurements &gt; np.mean(measurements))"
  },
  {
    "objectID": "02/week_02_home.html",
    "href": "02/week_02_home.html",
    "title": "Booleans and Conditionals",
    "section": "",
    "text": "Welcome to the second week of the 2025 SCIF10002 Introduction to Coding and Data Analysis for Scientists course! This week we shall be looking at Booleans and conditional statements.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Booleans and Conditionals"
    ]
  },
  {
    "objectID": "02/week_02_home.html#todays-material",
    "href": "02/week_02_home.html#todays-material",
    "title": "Booleans and Conditionals",
    "section": "Today’s Material",
    "text": "Today’s Material\nIn today’s class, we shall focus on the if statement. As in week 1, this week you have a choice of working through one of three notebooks.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\nOption 1: Beginner\nIf you have not spent much time coding in Python prior to taking this course, today you should work through the If Statements notebook linked below:\n\nBeginner: If Statements\n\nThis notebook will talk you through the basics of the if statement. Please read through the text carefully and attempt all exercises!\n\n\nOption 2: Intermediate\nThis weeks intermediate notebook should only be taken by those who are very comfortable with the material in the beginner notebook. Please ensure that you are able to complete the exercises in the beginner notebook before attempting this option. The intermediate material for this week is given below:\n\nIntermediate: Match Statements\n\nThis notebook will guide you through the recently introduced Match statement, which can serve as a convenient alternative to an if-elif statement in many settings. Ensure you read through the text and attempt all exercises.\n\n\nOption 3: Advanced\nIf you are an experienced programmer with a strong grasp of Python, begin by reviewing the exercises in the notebooks below to ensure you are fully comfortable with the material:\n\nBeginner: If Statements\n\nIntermediate: Match Statements\n\nOnce you are confident in your understanding, move on to the following notebook:\n\nAdvanced: Conditional Expressions and Lazy Evaluation\n\nThis notebook will talk you through some of the more complex nuances to boolean logic in Python, including lazy evaluation and in-line conditional evaluation. Please attempt this only if you have spent a lot of time developing code in Python already.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Booleans and Conditionals"
    ]
  },
  {
    "objectID": "02/week_02_home.html#getting-help",
    "href": "02/week_02_home.html#getting-help",
    "title": "Booleans and Conditionals",
    "section": "Getting Help",
    "text": "Getting Help\nThere is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\n\n\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Booleans and Conditionals"
    ]
  },
  {
    "objectID": "02/week_02_slides.html#todays-lecture",
    "href": "02/week_02_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 2: Booleans and Conditionals\n\nRecap: Accessing Noteable\nRecap: Booleans\nIf statements\nPractical"
  },
  {
    "objectID": "02/week_02_slides.html#why-learn-to-code",
    "href": "02/week_02_slides.html#why-learn-to-code",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Why learn to code?",
    "text": "Why learn to code?\nWhichever course you are taking you will likely need to write code at some point - Chemistry - Analyse experimental data - Automate repetitive calculations - Model chemical reactions/simulations"
  },
  {
    "objectID": "02/week_02_slides.html#why-learn-to-code-1",
    "href": "02/week_02_slides.html#why-learn-to-code-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Why learn to code?",
    "text": "Why learn to code?\nWhichever course you are taking you will likely need to write code at some point - Physics - Simulate physical systems - Process experimental measurements - Visualise complex phenomena"
  },
  {
    "objectID": "02/week_02_slides.html#why-learn-to-code-2",
    "href": "02/week_02_slides.html#why-learn-to-code-2",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Why learn to code?",
    "text": "Why learn to code?\nWhichever course you are taking you will likely need to write code at some point - Data Science - Clean and organise datasets - Apply statistical methods and machine learning - Communicate insights with visualisations"
  },
  {
    "objectID": "02/week_02_slides.html#recap-accessing-noteable",
    "href": "02/week_02_slides.html#recap-accessing-noteable",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Accessing Noteable",
    "text": "Recap: Accessing Noteable\n\nOpen Blackboard\nGo to Introduction to Coding and Data Analysis for Scientists 2025\nClick Unit Information and Resources\nOpen Noteable\n\nMake sure Jupyter Classic (Legacy) is selected.\nClick Start\n\nClick +GitRepo\nPaste into Git Repository URL: git@github.com:TomMaullin/SCIF10002-2025.git\nPress clone"
  },
  {
    "objectID": "02/week_02_slides.html#recap-last-time",
    "href": "02/week_02_slides.html#recap-last-time",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Last Time",
    "text": "Recap: Last Time\n\nLast week, we started looking at the Python language\nWe saw that variables can be assigned values using =\nTo display the values of variables we can use print"
  },
  {
    "objectID": "02/week_02_slides.html#recap-last-time-1",
    "href": "02/week_02_slides.html#recap-last-time-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Last Time",
    "text": "Recap: Last Time\n\nVariables have their own Data Types\n\nStrings are sequences of characters\nFloats are decimals, Ints are integers\nBooleans are True/False values\nLists are ordered groups of items\n\nWe spent some time looking at various things we could do with some of these data types"
  },
  {
    "objectID": "02/week_02_slides.html#recap-booleans",
    "href": "02/week_02_slides.html#recap-booleans",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Booleans",
    "text": "Recap: Booleans\n\nA Boolean is variable that can be either True or False\nBooleans represent logical statements.\nFor instance, we saw an example where:\n\ncat_is_black represented the sentence “The cat is black”\ncat_has_four_legs represented the sentence “The cat has four legs”\n\nWe can use logical operators to combine Boolean statements\n\ncat_is_black and cat_has_four_legs represented the sentence “The cat is black and has four legs”"
  },
  {
    "objectID": "02/week_02_slides.html#recap-booleans-1",
    "href": "02/week_02_slides.html#recap-booleans-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Booleans",
    "text": "Recap: Booleans"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements",
    "href": "02/week_02_slides.html#if-statements",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nWe should be starting to feel comfortable with giving a computer instructions via code\nBut sometimes, we don’t want every line to run automatically\nInstead, we may want Python to act only when a specific condition is true\nThis is where the if statement comes in…"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements-1",
    "href": "02/week_02_slides.html#if-statements-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nAn if statement lets you run code when a Boolean statement is True\n\n\n\n\n\n\n\n\nIndentation is important!\n\nPython tells what is in the body by looking at which code is indented!\n\nOften we don’t bother naming the boolean, and instead write it directly inside the if statement"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements-2",
    "href": "02/week_02_slides.html#if-statements-2",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nWe can also tell the if statement what to do when the Boolean is False by using else!"
  },
  {
    "objectID": "02/week_02_slides.html#if-statements-3",
    "href": "02/week_02_slides.html#if-statements-3",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "If Statements",
    "text": "If Statements\n\nAn elif (short for else if) can be added to check more extra conditions.\n\n\n\n\n\n\n\n\nMultiple elif can be added."
  },
  {
    "objectID": "02/week_02_slides.html#practical",
    "href": "02/week_02_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_02_home.ipynb\nFor the rest of today, you must work through a Python notebook\nYou have a choice of one of three options\n\nOption 1: Beginner - If Statements\nOption 2: Intermediate - Match Statements\nOption 3: Advanced - Conditional Expressions and Lazy Evaluation"
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html",
    "href": "02/week_02_solutions_demonstrator_version.html",
    "title": "Week 2: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 2 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html#beginner-if-statements",
    "href": "02/week_02_solutions_demonstrator_version.html#beginner-if-statements",
    "title": "Week 2: Solutions",
    "section": "Beginner: If Statements",
    "text": "Beginner: If Statements\nQuestion 1: The answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to give students their first practice with if statements. If a student is struggling, check in with them regularly and recap strings and the len() function as needed.\n\nQuestion 2: The code for this question is below.\n\n\n\n\n\n\n\nDemonstrator Notes: Please be mindful that some students may not be familiar with the pH scale, either because they have not studied Chemistry recently or because they learned it using different terms or acronyms. Before explaining the code, check that they understand the context - they might not say anything if they are confused.\n\nQuestion 3: The problem with this code is that the boolean for the if evaluates as True when the temperature exceeds 100, so the elif is never executed. A simple solution would be to switch the order of the clauses like so:\n\n\n\n\n\n\n\nDemonstrator Notes: The students have been given a similar example, where the solution is to reorder the clauses, in the Worked Example: Determining a Leap Year section. If students are struggling with this question, please suggest they re-read this section before providing them with the answer.\n\nQuestion 4: The code for this question is below:\n\n\n\n\n\n\n\nDemonstrator Notes: Many students will not immediately think to add up the days in each month in the manner the above code has. Because of the unfamiliar logic, be ready to guide them step by step and ‘’hold their hands’’ a bit more than usual for this question.\n\nQuestion 5: One potential solution to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Many students may struggle here because they have forgotten, or never fully grasped, the % operator. Make sure they understand this operator before giving the answer, explaining it in terms of modular/“clock” arithmetic if necessary.\n\nQuestion 6: An answer to this question is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: Last year, many students really struggled with unit conversions. Check they are doing distance_km / 1.60934 instead of distance_km*1.60934.\n\nQuestion 7: A solution to this question is given below:\n\n\n\n\n\n\n\nQuestion 7: This question may feel daunting to students at first. In reality, the solution only requires adding the first clause (year % 400 == 0). One way to help is to have students test a few example years on paper before coding so the logic becomes clearer. Only encourage them to start coding once you feel they have a strong conceptual grasp of the problem.\n\nQuestion 8: The pass statement is a placeholder which effectively does nothing. If it were not there, we would have a SyntaxError as the if statement must contain code.\n\nDemonstrator Notes: This question has two purposes. First, it introduces students to the pass statement, which they will need later in the course. Second, and more importantly, it encourages them to practice using documentation and independent research. Prompt students to look up the answer online rather than giving it to them directly.\n\nQuestion 9: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This is a classic introduction to coding task. If student’s are struggling encourage them to search for FizzBuzz exercise python online. They will find lots of good advice which does not instantly give them the answer.\n\nQuestion 10: The desired answer is below:\n\n\n\n\n\n\nAn alternative is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: Below is a step-by-step solution to reducing this problem. First, note that we can combine the x &lt; 4, x &lt; 15 and x &gt; 30 cases to get:\n\n\n\n\n\n\n\n\nNext, note that the final elif should never be evaluated as if z &lt; -1 then z &lt; 0, so the if is executed instead.\n\n\n\n\n\n\n\n\nWe can now combine the innermost if and else as follows:\n\n\n\n\n\n\n\n\nNow, note that the z &gt; 20 can’t ever be evaluated True, as if we are inside the outer if then z &lt; 0.\n\n\n\n\n\n\n\n\nWe can now combine the inner if and elif:\n\n\n\n\n\n\n\n\nBy combining the outer if and inner statements, we now get the result."
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html#intermediate-match-statements",
    "href": "02/week_02_solutions_demonstrator_version.html#intermediate-match-statements",
    "title": "Week 2: Solutions",
    "section": "Intermediate: Match Statements",
    "text": "Intermediate: Match Statements\nQuestion 1: The answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to give the students pratice with the match statement. Before offering help, it might be worth checking that they understand the context for this question. Before offering help, check that they understand the context: less mathematical students, or non-native speakers, may not feel confident with terms like “Cartesian plane” or “quadrant.”\n\nQuestion 2: The solution to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Because this example looks very similar when written with if statements, students may wonder what the point of match is. Point them to the section Converting Long elif Statements to match, which provides a more compelling example and highlights the advantages of match in certain situations.\n\nQuestion 3: A model answer is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: A common mistake here is confusing operators with their string forms - for example, writing \"*\" instead of *, or the reverse.\n\nQuestion 4: An example solution is provided below:\n\n\n\n\n\n\n\nDemonstrator Notes: See the notes on Beginner Question 6 about unit conversion. In this question, some students may try to code every possible pair of conversions separately (e.g. GBP -&gt; USD, GBP -&gt; EUR, … , EUR -&gt; JPY). Discourage this, as it leads to unnecessary repetition (especially if we wanted to add more currency units!). Instead, hint at the approach shown above: convert everything via a common unit, requiring only two conversions.\n\nQuestion 5: Below is a solution to this exercise:\n\n\n\n\n\n\n\nDemonstrator Notes: Some students may skip the note directing them to review tuples in the intermediate Week 1 material. Before offering help, check that they understand what a tuple is. If they do not, redirect them back to that material."
  },
  {
    "objectID": "02/week_02_solutions_demonstrator_version.html#advanced-conditional-expressions-and-lazy-evaluation",
    "href": "02/week_02_solutions_demonstrator_version.html#advanced-conditional-expressions-and-lazy-evaluation",
    "title": "Week 2: Solutions",
    "section": "Advanced: Conditional Expressions and Lazy Evaluation",
    "text": "Advanced: Conditional Expressions and Lazy Evaluation\nQuestion 1: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The logic in this question is very similar to the absolute value example in the Conditional Expressions section. If students are unsure what to do here, begin by referring them back to this example.\n\nQuestion 2: The answers to this question, alongside commented code are given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Explanations of the behaviour are given below:\n\nThe first statement gives a division by zero error because the left-hand side is True, so Python must also evaluate the right-hand side to determine the result of the and.\nThe second statement does not throw an error: since the left-hand side is False, Python stops there and assigns False directly to my_variable without checking the right-hand side.\nThe third statement avoids the error for the same reason as the second. Wrapping the code in str() means my_variable is assigned the string value \"False\" instead of the boolean value False.\nThe fourth case again causes a division by zero error. This is because str(False) is the string \"False\", which is a truthy value in Python (the only Falsy string is the empty string \"\"). Since it is not False, Python must evaluate the second argument 1/0, which triggers the error.\n\n\nQuestion 3: When Python evaluates an and expression, it checks the left-hand side first.\n\nIf my_boolean is True, the right-hand side (print(...)) must also be evaluated, so the message is printed.\nIf my_boolean is False, Python stops immediately, as it knows the and must be False, and the right-hand side is never run - so nothing is printed.\n\n\nDemonstrator Notes: If students are struggling with this question, first refer them to the text in the Lazy Evaluation section. This section offers a similar explanation to the above text.\n\nQuestion 4: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question may be challenging for students who are still new to Boolean logic. Encourage them to first rewrite the statements in plain English before attempting to code, drawing clear links between the and, or, and not operators and their plain-English meanings.\n\nQuestion 5: The rule for evaluating x or y is:\n\nIf x is Truthy, return x.\nIf x is Falsy, return y.\n\nThis is the mirror image of how and works. Some example code is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: The reasoning behind the answer is as follows. Suppose x and y are Boolean values and we want to evaluate x or y. We would do the following\n\nFirst check x. If x is True, then the whole or expression is True and there is no need to check y. In this case, we return x.\nIf x is False, then we must check y. If y is True, the whole expression is True; otherwise, it is False. In either case, the result is the truth value of y, so we return y.\n\nGeneralising from Booleans, we replace True with Truthy and False with Falsy, giving the final rule:\n\nIf x is Truthy, return x.\n\nIf x is Falsy, return y."
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html",
    "title": "Intermediate: Match Statements",
    "section": "",
    "text": "Welcome to the Week 2 Intermediate Python Notebook. This notebook is designed for students who already have some experience with Python and are ready to build on the basics.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are designed to deepen your understanding and give you practical experience with new concepts.\nIn this notebook, you will explore a recent addition to Python: the match statement; a powerful tool for handling multiple conditions, particularly useful when your programs need to deal with many different cases.\nBe sure to work through the examples and attempt all the exercises. They are designed to help you practice, reinforce your learning, and prepare you for the more advanced topics ahead.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#what-is-a-match-statement",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#what-is-a-match-statement",
    "title": "Intermediate: Match Statements",
    "section": "What is a match Statement?",
    "text": "What is a match Statement?\nThe match statement is a relatively new addition to Python, having been added in Python 3.10 in 2021. This statement can be used to compare the value of a variable to different many different patterns. When it finds a match, the code inside the corresponding case block runs.\nThis is similar to using lots of if/elif checks, but can be cleaner and easier to read.\nHere’s a simple example:\n\n\n\n\n\n\nThe above code tells us what to do if we see a specific color at a traffic light. In the code, we provide the color we have seen as a string (which has been set to \"red\" in the above) and the match statement will consider a number of cases one at a time, checking whether the color variable matches the value for that case. When it finds a match, it runs the code inside that case block.\nNote that in the final case we have an underscore, _. This simply means “match anything that hasn’t already matched.” You can think of it like the else at the end of an if/elif statement. It serves as a “catch-all” to deal with any unexpected or unhandled values.\n\nTest your understanding: How might you modify the above code to allow case-sensitive examples such as color=\"ReD\" or color=\"GreEn\"? Hint: recall the lower() function from the beginner notebook in Week 1.\n\n\n\n\n\n\n\nSometimes, you may want several different inputs to trigger the same response. In such cases, instead of writing out separate case blocks for each value, we can group them together inside a single case using the pipe symbol, |. This lets us list several alternatives side by side, and if the variable matches any one of them, that case is chosen.\nFor example, in the below code we group “Saturday” and “Sunday” together, since both are weekend days:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#converting-long-elif-statements-to-match",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#converting-long-elif-statements-to-match",
    "title": "Intermediate: Match Statements",
    "section": "Converting Long elif Statements to match",
    "text": "Converting Long elif Statements to match\nOne of the biggest advantages of the match statement is how cleanly it handles data with complex structures.\nSuppose we want to represent different 3D solids using dictionaries. For example:\n\n\n\n\n\n\n\nNote: If you are not yet comfortable with dictionaries, please review the week 1 intermediate notebook on collections. There you will find introductory material on the dict data type.\n\nHere, solid_data describes a cylinder with a given radius and height. We might also store information for other solids:\n\n\n\n\n\n\nEach solid requires different keys: a sphere has only a radius, a rectangular prism has width, height, and depth, while a cylinder needs both radius and height.\nNow imagine we want to compute the volume automatically, regardless of which solid is described. A natural first attempt is a long chain of if-elif-else statements:\n\n\n\n\n\n\nWhile this works, it quickly becomes unwieldy. Each branch requires lots of repetition (.get(), nested ifs), and adding new shapes means adding even more clutter.\nThe match statement for this task is much simpler. This is in part due to some useful syntax; we can unpack the values inside the dictionary immediately, without using the .get() function as shown below:\n\n\n\n\n\n\nThis is much cleaner:\n\nNo need for repeated .get() calls\nNo nested if checks\nSimple, readable case syntax\n\nAnd adding a new solid is now as simple as writing one more two-line case.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#combining-match-and-if",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#combining-match-and-if",
    "title": "Intermediate: Match Statements",
    "section": "Combining match and if",
    "text": "Combining match and if\nAnother helpful feature of the match statement is that it can be modified to include conditionals, using an if guard. This works a lot like an if statement and allows you greater control over when cases are executed. The general syntax is:\nmatch variable:\n    case pattern if condition:\n        # code to run\nHere the code will be run if and only if the variable matches the pattern and the condition is satisfied.\nFor example, suppose we’re working with points in 2D space, which we write as a tuple and wish to describe whether they lie on the cartesian axes. Then we could do the following:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_intermediate.html#exercises",
    "href": "02/week_02_booleans_and_conditionals_intermediate.html#exercises",
    "title": "Intermediate: Match Statements",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Extend the match statement in the Combining match and if section so that it not only handles points on the axes, but also describes points in each of the four quadrants (upper right, lower right, lower left, upper left).\nHint: A 2D point lies in a quadrant when both \\(x\\) and \\(y\\) are nonzero. Use if guards to distinguish whether each coordinate is positive or negative.\n\n\n\n\n\n\nQuestion 2: Convert the below if-elif-else statement to a match statement:\n\n\n\n\n\n\nQuestion 3: You are given two numeric variables, a and b, along with an operator stored as a string (\"+\", \"-\", \"*\", \"/\"). Use a match statement to apply the correct operation and display the result.\nFor example, if operator = \"*\", the program should calculate and store my_result = a * b. If the operator is not one of the four listed above, your code should print \"Invalid operator\".\n\n\n\n\n\n\nQuestion 4: The variable account stores a tuple (balance, currency), where balance is the amount of money a user has and currency is the unit of that balance. The unit will be one of \"USD\", \"EUR\", \"GBP\", or \"JPY\". Your job is to convert this balance into another currency, stored in the variable target_currency (again, one of the four listed above).\nWrite a Python program using match statements to:\n\nConvert account into the requested target_currency using the exchange rates provided below.\n\nPrint the resulting balance, formatted with the correct symbol:\n\n\"USD\" → \"$\"\n\n\"EUR\" → \"€\"\n\n\"GBP\" → \"£\"\n\n\"JPY\" → \"¥\"\n\n\nIf either currency (from account) or target_currency is not one of the four supported codes, print \"Unsupported currency\".\nNote: You will have to look up the current exchange rates online (you need only use three significant figures for the conversion).\nHint: You may wish to use two match statements for this task; one converting to a single currency, say GBP, and another converting from GBP to the desired output currency.\nIf you are unsure what a Tuple is, please revisit the week 01 intermediate notebook on collections.\n\n\n\n\n\n\nQuestion 5: In digital images, colors are represented using RGB values. An RGB value is a 3-tuple (r, g, b) that gives the intensity of the red, green, and blue components of a color, each ranging from \\(0\\) to \\(255\\). For example, \\((255, 0, 0)\\) is bright red, \\((0, 255, 0)\\) is bright green, and \\((0, 0, 0)\\) is black.\nWrite a program that takes an (r, g, b) tuple as input and uses a match statement to classify the tuple into one of the following color names:\n\nRed if r is greater than 200 and both g and b are less than 50.\nGreen if g is greater than 200 and both r and b are less than 50.\nBlue if b is greater than 200 and both r and g are less than 50.\nUnknown for any other combination.\n\nThe color name should be saved as a string variable named color_name. Write your solution in the box below.\n\n\n\n\n\n\nHint: You may wish to use if guards for this question.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Intermediate: Match Statements"
    ]
  },
  {
    "objectID": "05/week_05_slides.html#todays-lecture",
    "href": "05/week_05_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 5: Consolidation\n\nRecap: The Course So Far\nTackling Difficult Problems\nA Worked Example\nPractical"
  },
  {
    "objectID": "05/week_05_slides.html#recap-the-course-so-far",
    "href": "05/week_05_slides.html#recap-the-course-so-far",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: The Course So Far",
    "text": "Recap: The Course So Far\n\nOver the last 4 weeks, we’ve covered the basics of Python\nWe’ve looked at:\n\nDatatypes\nConditional Logic\nLoops\nFunctions"
  },
  {
    "objectID": "05/week_05_slides.html#recap-the-course-so-far-1",
    "href": "05/week_05_slides.html#recap-the-course-so-far-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: The Course So Far",
    "text": "Recap: The Course So Far\n\nBefore moving on to the next parts of the course…\n\nNumPy, Pandas and Matplotlib\n\n… this week we are going to do some “consolidation challenges”\n\nUsing what we have learnt to tackle the kinds of tasks you might encounter in the real world"
  },
  {
    "objectID": "05/week_05_slides.html#aside-dictionaries",
    "href": "05/week_05_slides.html#aside-dictionaries",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Aside: Dictionaries",
    "text": "Aside: Dictionaries\n\nBefore we dive into today’s work, there is one concept we’d like to revisit in more detail\nA dictionary, or dict, is a data type in Python\n\nIt allows us to store values under keys\n\nThink of a real-life dictionary\n\nYou look up a word (the key)\nYou read its definition (the value)\n\nIn the same way, a Python dict lets you\n\nYou look up a key\nGet back the value associated with it"
  },
  {
    "objectID": "05/week_05_slides.html#aside-dictionaries-1",
    "href": "05/week_05_slides.html#aside-dictionaries-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Aside: Dictionaries",
    "text": "Aside: Dictionaries\n\nNew values can be added to the dictionary using the syntax\n\nmy_dict[key] = value"
  },
  {
    "objectID": "05/week_05_slides.html#aside-dictionaries-2",
    "href": "05/week_05_slides.html#aside-dictionaries-2",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Aside: Dictionaries",
    "text": "Aside: Dictionaries\n\nAnd keys and values can be any datatype you like\n\nThey don’t have to be strings!"
  },
  {
    "objectID": "05/week_05_slides.html#aside-dictionaries-3",
    "href": "05/week_05_slides.html#aside-dictionaries-3",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Aside: Dictionaries",
    "text": "Aside: Dictionaries\n\nDictionaries will be crucial to some of today’s challenges as well as throughout the rest of this course\nIf you are unsure about these please take the time to read over:\n\nWeek 1's intermediate notebook Section: Sets and Dictionaries\n\nYou can do this either in today’s class or over the week 6 break"
  },
  {
    "objectID": "05/week_05_slides.html#tackling-difficult-problems",
    "href": "05/week_05_slides.html#tackling-difficult-problems",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Tackling Difficult Problems",
    "text": "Tackling Difficult Problems\n\nToday, we’re going to be looking at some challenge problems\nThese problems may feel a little more open-ended than you are used to\n\nThis can be a little daunting at first\nBut do not worry…\nYou already have all the skills necessary to complete the tasks!\n\nWhen faced with a difficult coding problem, here’s some general tips to help you get started out"
  },
  {
    "objectID": "05/week_05_slides.html#tackling-difficult-problems-1",
    "href": "05/week_05_slides.html#tackling-difficult-problems-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Tackling Difficult Problems",
    "text": "Tackling Difficult Problems\n\nPlan before you code\n\nBefore you start coding, grab a pen and paper and try to solve the problem by hand!\n\nClarify inputs and outputs\n\nWhen getting started think about what you have and what you need – these are probably your inputs and outputs\n\nLook for structure and repetition\n\nWhen you convert your thoughts to code, ask yourself which parts of the code are repetitive or self-contained"
  },
  {
    "objectID": "05/week_05_slides.html#tackling-difficult-problems-2",
    "href": "05/week_05_slides.html#tackling-difficult-problems-2",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Tackling Difficult Problems",
    "text": "Tackling Difficult Problems\n\nDivide and Conquer\n\nTry to break the task down into smaller chunks where possible!\n\nTalk things through\n\nIf you are struggling to get started, talk through the problem with a friend or peer\n\nUse Resources\n\nGoogling and looking up documentation are key coding skills\n\nTrust your own process\n\nTry to avoid using AI to make structural decisions about your code"
  },
  {
    "objectID": "05/week_05_slides.html#tackling-difficult-problems-3",
    "href": "05/week_05_slides.html#tackling-difficult-problems-3",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Tackling Difficult Problems",
    "text": "Tackling Difficult Problems\n\nAbove all, remember…\n\nCoding can be hard!\n\nIt can feel like you are running into the same problems over and over again sometimes\n\nThis is a normal part of the process\n\nIf you keep trying you will get there"
  },
  {
    "objectID": "05/week_05_slides.html#a-worked-example",
    "href": "05/week_05_slides.html#a-worked-example",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "A Worked Example",
    "text": "A Worked Example\n\nLet’s go through an example together to see these principles in action:\n\n\nQuestion: Write some code which, for a given positive integer \\(n\\), finds the largest prime number that is less than or equal to \\(n\\).\n\n\nPrinciples:\n\nPlan before you code\nClarify inputs and outputs\nLook for structure and repetition\nDivide and conquer\nTalk things through\nTrust your own process"
  },
  {
    "objectID": "05/week_05_slides.html#practical",
    "href": "05/week_05_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_05_home.ipynb\nFor the rest of today, you must work through a Python notebook\nThis week is a little different…\nPlease choose the challenge according to your course\n\nChemistry Challenge\nData Science Challenge\nPhysics Challenge"
  },
  {
    "objectID": "05/week_05_chemistry.html",
    "href": "05/week_05_chemistry.html",
    "title": "",
    "section": "",
    "text": "Code",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Chemistry Challenge"
    ]
  },
  {
    "objectID": "05/week_05_chemistry.html#chemistry-challenge",
    "href": "05/week_05_chemistry.html#chemistry-challenge",
    "title": "",
    "section": "Chemistry Challenge",
    "text": "Chemistry Challenge\nThis week, we’ll bring together the skills you’ve developed over the past four weeks to tackle a practical challenge. Specifically, for the Chemistry challenge in this notebook, you will use data from the periodic table to determine various properties of isotopes. This task is designed to give you practice working with strings, conditional logic, and dictionaries in a familiar Chemistry setting.\n\nPlease Note: This week’s challenges are designed to difficult! Do not worry if you are unable to complete a challenge in the time given. The important thing is that you are building resilience and practicing problem-solving skills - everything else is secondary!\n\n\nTable of Contents\n\nWelcome Page\nChallenge 1: Data Science\nChallenge 2: Physics\nChallenge 3: Chemistry\n\nBackground\n\nThe Periodic Table\nIsotopes\n\nThe Challenge\n\nTask 1: Verifying Elements\nTask 2: Verifying the Atomic Number\nTask 3: Counting Electrons, Protons and Neutrons\nTask 4: Group and Period\nTask 5: Isotope Names\nTask 6: Categorizing Isotopes\n\n\nSlides (Powerpoint)",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Chemistry Challenge"
    ]
  },
  {
    "objectID": "05/week_05_chemistry.html#background",
    "href": "05/week_05_chemistry.html#background",
    "title": "",
    "section": "Background",
    "text": "Background\n\nThe Periodic Table\nIn your previous studies, you have likely encountered the periodic table of elements. In this challenge, you will use the periodic table to explore and derive various properties of isotopes.\n\nThe periodic table organizes chemical elements (substances whose atoms contain a fixed number of protons) into rows (periods) and columns (groups). In addition to ordering the elements, the periodic table is also a powerful tool for categorization. It groups together elements that share similar properties.\nFor instance, in the image above, the colors highlight the following categories of elements:\n\n\nAlkali metals: very reactive metals that readily form compounds with nonmetals.\n\n\nAlkaline earth metals: reactive metals that form basic solutions when they react with water.\n\n\nLanthanides: rare earth elements often used in magnets and electronics.\n\n\nActinides: heavy elements, many of which are radioactive.\n\n\nTransition metals: versatile metals widely used in alloys and catalysts.\n\n\nPost-transition metals: softer metals with lower melting points than transition metals.\n\n\nMetalloids: elements with properties of both metals and nonmetals.\n\n\nHalogens and other nonmetals: generally poor conductors; many are gases or brittle solids, and halogens in particular are very reactive.\n\n\nNoble gases: very stable gases that rarely react with other elements.\n\n\nBy convention, we assume that all lathanides have period 6 and group 3, and all actinides have period 7 and group 3 (see periodic table above).\nIn each box of the periodic table, you can see the name, chemical symbol, and category of the element. The atomic number is shown in the top left. This tells you how many protons are in the nucleus of the atom, and it also determines the element’s position in the table. An atom has the same number of protons and electrons, so the atomic number also represents the number of electrons in the atom. The relative atomic mass is shown in the top right. This value represents the average mass of all the naturally occurring isotopes of that element, taking into account how common each isotope is.\nFor example, the box for carbon (C) shows the atomic number 6 in the top left, which means every carbon atom has 6 protons. In the top right, the relative atomic mass is shown as about 12.01, reflecting the natural mixture of mostly carbon-12 and a small amount of carbon-13.\n\n\nIsotopes\nAs noted above, not all of the atoms of the same element have the same mass. This is because, although atoms of the same element must have, by definition, the same number of protons, they can have different numbers of neutrons. An atom with a fixed number of neutrons is known as an isotope and we usually denote isotopes by the element name followed by the mass number: that is, the total number of protons and neutrons in the atom. For instance, carbon-12 is an isotope of carbon with a mass number of 12. You might also see this written as \\(^{12}C\\) or \\(^{12}_6C\\), if we want to highlight that the atom possesses \\(6\\) protons.",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Chemistry Challenge"
    ]
  },
  {
    "objectID": "05/week_05_chemistry.html#the-challenge",
    "href": "05/week_05_chemistry.html#the-challenge",
    "title": "",
    "section": "The Challenge",
    "text": "The Challenge\nYou are given a string of one of the following forms: N_P_E or N_E, where: - \\(N\\) is an integer representing the number of mass number of the isotope, - \\(P\\) is an integer representing the number of protons in an isotope, - \\(E\\) is the chemical symbol of the element.\nFor instance, 12_6_C represents \\(^{12}_6C\\) and 12_C represents \\(^{12}C\\).\n\n\n\n\n\n\nYou are also given the variable named periodic_table, loaded in by the below code. This includes some of the data displayed in the periodic table, saved as a dictionary of dictionaries.\n\n\n\n\n\n\n\nNote: Don’t worry if you are unsure what the import and from keywords are doing in the above code. For now, you can think of these as a way of loading in pre-written functions such as the get_periodic_table function. You’ll have plenty of opportunities to practice and understand these features of Python as the course goes on.\n\nTry running the following commands to see if you can understand how to use this variable:\n\n\n\n\n\n\n\nNote: Before proceeding, if you are unsure about dictionaries please see the week 1 intermediate notebook for further detail.\n\nFor an arbitrary isotope represented as described above, the challenge is to solve the following tasks.\nNote: If you are not sure how to get started, have a look at the guidance section on this week’s home page.\n\nImportant: For this task, you may only use material covered in the previous 4 week’s classes. To solve the challenge problems, you may use any content from the beginner, intermediate, or advanced notebooks. However, every challenge can be completed using only the material in the beginner notebooks, so don’t worry if you haven’t looked at the others. The tasks are designed to be accessible to everyone!\n\n\nTask 1: Verifying Elements\nWrite a function that takes two inputs; a string representing an isotope and the periodic_table dictionary. The function should verify whether the chemical symbol in the isotope string corresponds to a valid element in the periodic table and print a message indicating the result.\n\n\n\n\n\n\nHint: You can convert the keys in dictionary to a list using list(dict_name.keys()).\n\n\nTask 2: Verifying the Atomic Number\nWrite a function that takes two inputs; a string representing an isotope and the periodic_table dictionary. The function must check whether the number of protons, if provided, matches that in the periodic table.\n\n\n\n\n\n\n\n\nTask 3: Counting Electrons, Protons and Neutrons\nUpdate your code from Task 2 so that, unless an incorrect number of protons is provided, it prints the number of protons, neutrons, and electrons in the isotope. Make sure your code outputs these values even if the number of protons is not explicitly included in the isotope string.\n\n\n\n\n\n\n\n\nTask 4: Group and Period\nWrite a function that takes two inputs; a string representing an isotope and the periodic_table dictionary. The function must print the group and period of the element in the periodic table.\n\n\n\n\n\n\n\n\nTask 5: Isotope Names\nWrite a function which return a string representing the name of the isotope. For instance, 12_C should return \"Carbon-12\". Note that \\(^1H\\),\\(^2H\\) and \\(^3H\\) do not follow the standard convention and are usually referred to as \"Hydrogen\", \"Deuterium\" and \"Tritium\" rather than \"Hydrogen-1\", \"Hydrogen-2\" and \"Hydrogen-3\", respectively.\n\n\n\n\n\n\n\n\nTask 6: Categorizing Isotopes\nWrite a function which returns a string representing the category the isotope belongs to (e.g. \"Alkali Metals\", \"Actinides\",…, etc).",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Chemistry Challenge"
    ]
  },
  {
    "objectID": "05/week_05_solutions_demonstrator_version.html",
    "href": "05/week_05_solutions_demonstrator_version.html",
    "title": "Week 5: Solutions",
    "section": "",
    "text": "This notebook presents solutions to the Week 5 challenges in Data Science, Physics and Chemistry. Unlike previous weeks, these challenges are designed to be more open-ended, so the answers provided below are intended only as examples. There are many ways to approach these questions, and it is not our intention to suggest that the given answers are the “best” approaches, or that a “best” approach even exists."
  },
  {
    "objectID": "05/week_05_solutions_demonstrator_version.html#challenge-1-data-science",
    "href": "05/week_05_solutions_demonstrator_version.html#challenge-1-data-science",
    "title": "Week 5: Solutions",
    "section": "Challenge 1: Data Science",
    "text": "Challenge 1: Data Science\nTo run the solutions for this challenge, you will first need to run the below import statement.\n\n\n\n\n\n\nTask 1: Getting Started. Code for this task can be found below:\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this task is two-fold: (i) to get students familiar with the robot environment and (ii) to get students thinking about how they can use loops to repeatedly move in a given direction. If you see students who are writing \"robot.move()\" repeatedly, please encourage them to think about how they can make their code shorter by using loops for this task.\n\nTask 2: Sensing Danger. Here is an answer to this problem:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to get students thinking about how they can use if statements to navigate the robot environment. It should be noted that students are not asked to stop the robot from turning if it senses a wall to the left or right. The reason that we do not ask for this is that the robot could be in a dead-end (e.g. there is a wall left, right and ahead). If we ask the students to prevent the robot from turning whenever it senses a wall, then in a dead-end the robot will get stuck and the while loop will execute indefinitely. If you see students with this issue, remind them that the question does not ask them to modify the turning behaviour of the robot - it only asks them to modify the call to robot.move().\n\nTask 3: End of the Road. The below code provides a solution to this question.\n\n\n\n\n\n\n\nDemonstrator Notes: Some general advice for this question: - Make sure students have their browser zoomed far enough out so that they can see both the Robot Console and the maze at the same time. - If they haven’t already, advise students to set the robot delay so that the robot moves slowly (e.g. robot.delay = 2). This will allow them to verify that what the robot is printing the correct response in real time. - There are many ways to approach this task; however, one of the most convenient is to count the number of walls around the robot, as counting the wall allows you to handle the dead-end, single-wall and unbordered-square cases immediately. - When students are trying to count the number of walls, let them first write out the robot.sense(\"AHEAD\"), robot.sense(\"LEFT\"),… etc calls one-at-a-time. Once they have done this, point out the repetitive nature of the code to them, and explain why this code might be cleaner using a loop. - When distinguishing between corners and corridors it is easier to list the situations in which you are in a corridor (there is a wall to the left and right, or there is a wall behind and ahead) then the situations where you are in a corner (there is a wall ahead and left, ahead and right, behind and left, behind and right).\n\nTask 4: Turning Back. Below is an example solution for this question.\n\n\n\n\n\n\n\nDemonstrator Notes: This challenge is difficult as it will be drawing on many concepts, some of which are relatively new to the students. It is expected that many students will struggle with (i) identifying the explored and unexplored squares and (ii) choosing randomly from these directions. Feel free to offer more guidance/hold-the-hands of those students that are struggling on this question and stress that it is okay to be struggling at this level. Solving this question should be satisfying, as the robot will move towards the target in a much more directed fashion than in the previous questions.\n\nTask 5: Final Challenge. There are plenty of solutions to this task. Here is just one example:\n\n\n\n\n\n\n\nDemonstrator Notes: Although there are lots of possible algorithms students could use here, the most sensible choice, both in terms of efficiency and implementability, given the setup we have, is the “Hand on Wall Rule”. Encourage students who are unsure to try this rule; compared to part 4 of this challenge, this algorithm is surprisingly easy to implement."
  },
  {
    "objectID": "05/week_05_solutions_demonstrator_version.html#challenge-2-physics",
    "href": "05/week_05_solutions_demonstrator_version.html#challenge-2-physics",
    "title": "Week 5: Solutions",
    "section": "Challenge 2: Physics",
    "text": "Challenge 2: Physics\nThis code will load in the challenge data.\n\n\n\n\n\n\nTask 1: Clean the Data. Below is an example solution for part (1) of the Physics challenge.\n\n\n\n\n\n\n\nDemonstrator Notes: This is the hardest part of this challenge and it is expected that many of the students will struggle at first. Encourage students to try and break down this question into parts. e.g. useful advice could inclue: - Make sure you can describe the experiment/context in words before starting to code. - Start by considering a string for a single trial. - Write out some string examples on paper first. Make sure you understand the rules for replacing errors before starting to code. - If necessary, try working with some smaller example strings first, e.g. write out test_string = 'ooexx'; test_string2 = 'ooxxe'; test_string3 = 'oeexx' and try to “clean” these one by one.\nAlso, it is possible for students to get to this point in the course without having worked with dictionaries and lists very much. If a student seems unsure about dictionaries and lists please refer them to the week 1 and week 3 intermediate notebooks for further reading.\n\nTask 2: Detect When Each Bar Begins to Block the Beam. Solution code for part (1) of the Physics challenge is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: It is expected that a large stumbling block for students will be figuring out how they are going to approach the question and, in particular, how they plan to store the results of their computations. Encourage them to think about how carefully about how many time values they will have to store before they start to code:\n\nIn an invidiual trial, they will have to record the time in seconds every time a bar blocks the sensor. This means they will have one time recorded per bar.\nThe dataset has been deliberately constructed so that different trials use a different number of bars. This is mentioned in the section titled “The Data”.\nSo for each trial, we have one time per bar and the number of bars may vary between trials.\n\nBy first discussing the above, it should be easier to motivate potential approaches to storing the time values. For instance, in the above code, a dictionary of lists is used. This approach can be motivated by noting that we have many time values per trial, so it seems reasonable to store these as a list, and then noting that we wish to keep track of which trial each list of times came from, hence the dictionary.\n\nTask 3: Estimate Average Velocities. Example code for this question is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: Compared to the previous, this question is much simpler. However, it is expected that many students may fail to notice that the number of recorded velocities (which are computed as finite differences in distance) will be one less than the number of recorded times (that is, in the above it should be the case that len(times_data)==len(velo_list)+1). If students are experiencing index out of bounds errors, it is worth checking their logic here and writing out on paper an example illustrating how \\(n\\) datapoints leads to \\(n-1\\) finite differences. E.g.\n\\[(2,4,5) \\rightarrow (4-2,5-4)=(2,1)\\]\n\nTask 4: Estimate Accelerations. An answer to this question is provided below.\n\n\n\n\n\n\n\nDemonstrator Notes: If students have got this far they are likely to complete this question and the next successfully. That said, if reading too fast, some students may confuse \\(\\tau_k\\) and \\(t_k\\). If students are getting any strange values in their computation, it may be worth checking they have this notation correct.\n\nTask 5: Estimate \\(g\\). The below code computes the within-trial averages of the acceleration.\n\n\n\n\n\n\nThe following code averages acceleration across trials.\n\n\n\n\n\n\n\nDemonstrator Notes: The final value output should be 9.825957197907218 (up to python rounding errors). If a student has something wildly different to this, they have likely made a mistake somewhere."
  },
  {
    "objectID": "05/week_05_solutions_demonstrator_version.html#challenge-3-chemistry",
    "href": "05/week_05_solutions_demonstrator_version.html#challenge-3-chemistry",
    "title": "Week 5: Solutions",
    "section": "Challenge 3: Chemistry",
    "text": "Challenge 3: Chemistry\nTo run the solutions for this challenge you must first run the below code.\n\n\n\n\n\n\nTask 1: Verifying Elements. Here is an example solution to this problem.\n\n\n\n\n\n\n\nDemonstrator Notes: Students will still be building confidence with dictionaries at this point. Try to provide simple examples where possible to help them get to grips with the idea of keys and values.\n\nTask 2: Verifying the Atomic Number. Here is an example answer to task 2.\n\n\n\n\n\n\n\nDemonstrator Notes: Students who skim the text may miss that the number of protons is the atomic number in the periodic table. If they ask about this, encourage them to look back through the text for clarification.\n\nTask 3: Counting Electrons, Protons and Neutrons. Here is some example code for task 3:\n\n\n\n\n\n\n\nDemonstrator Notes: Students who skim the text may miss the fact that the number of protons is the same as the number of electrons. Encourage students who are unsure to CTRL+F for the word electron.\n\nTask 4: Group and Period. Example code for this task is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: This question is laborious but not difficult once you understand the logic. The basic idea is to break the table down into chunks for which the atomic number can be used to predict the group and period. For instance, along the fourth row, the period is 4 and the group is num_protons - 18. If students are struggling with this question, encourage them to narrow their focus to a smaller segment of the table and work with that.\n\nTask 5: Isotope Names. An example solution for this is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Compared to the previous questions, this is a little easier. Try not to give too much direct assistance on this question, as most students should be able to complete it. The main errors expected on this question are TypeErrors due to students forgetting to cast the string values to integers.\n\nTask 6: Categorizing Isotopes. Here is an example solution to this task.\n\n\n\n\n\n\n\nDemonstrator Notes: This question is much easier if you use the group and period computed in task 4. If students are stuck, encourage them to think about which of the previous tasks might help them here, and highlight that they can use the functions they have already written. To understand the logic of the solution, it helps to draw out a rough periodic table on paper and shade each section covered by successive clauses of the if statement."
  },
  {
    "objectID": "05/week_05_data_science.html",
    "href": "05/week_05_data_science.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "05/week_05_data_science.html#data-science-challenge",
    "href": "05/week_05_data_science.html#data-science-challenge",
    "title": "",
    "section": "Data Science Challenge",
    "text": "Data Science Challenge\nThis week we are consolidating the skills we have learned over the past four weeks in order to tackle a practical challenge. In this notebook, you will find the data science challenge, in which you will have to write code that will navigate a small virtual robot around a maze.\n\nPlease Note: These challenges are designed to difficult! Do not worry if you are unable to complete a challenge in the time given. The important thing is that you are building resilience and practicing problem-solving skills - everything else is secondary!\n\n\nTable of Contents\n\nWelcome Page\nChallenge 1: Data Science\nPreliminaries\nTutorial: The Robot Maze\n\nCreating a Robot Maze\nMoving the Robot\nResetting and Saving the Maze\nAims and Limits\n\nChallenges\n\nTask 1: Getting Started\nTask 2: Sensing Danger\nTask 3: End of the Road\nTask 4: Turning Back\nTask 5: Final Challenge\n\nChallenge 2: Physics\nChallenge 3: Chemistry\nSlides (Powerpoint)"
  },
  {
    "objectID": "05/week_05_data_science.html#preliminaries",
    "href": "05/week_05_data_science.html#preliminaries",
    "title": "",
    "section": "Preliminaries",
    "text": "Preliminaries\nThis notebook draws on the knowledge you’ve built over the last four weeks. This challenge assumes knowledge of only the material from the beginner notebooks - however, you are welcome to draw upon material from the intermediate and advanced notebooks as well! The tasks are designed to be accessible to everyone.\nBefore getting started, you’ll need to know how to generate random numbers. Here’s a quick primer.\nTo load in a package (collection of functions) that will let you generate random numbers, you must run the below code:\n\n\n\n\n\n\nYou only need to run the above line of code once (unless you restart the notebook, in which case you will have to run it again after restarting). Once you have run the import code you will be able to generate random numbers using the random.random() and random.randint() functions like so:\n\n\n\n\n\n\nTry running the above box a few times and observe how a new value is produced each time you call random or randint. For today’s class, this is all the knowledge we will need concerning random numbers in Python. We’ll explore random number generation in greater depth later on in the course."
  },
  {
    "objectID": "05/week_05_data_science.html#tutorial-the-robot-maze",
    "href": "05/week_05_data_science.html#tutorial-the-robot-maze",
    "title": "",
    "section": "Tutorial: The Robot Maze",
    "text": "Tutorial: The Robot Maze\nToday, you will be programming a robot to navigate a small maze. To get started, run the code box below. This will load in the RobotMaze function which we will be working with today.\n\n\n\n\n\n\n\nCreating a Robot Maze\nThe RobotMaze function will create a new randomly generated maze with a robot inside it. Try running the below code to see what this looks like:\n\n\n\n\n\n\nLet’s break down what we can see here. The maze contains:\n\nWhite Squares: Open spaces, which the robot has not yet visited.\nBlack squares: Walls. The robot cannot walk into these.\nGrey squares: These are open spaces that the robot has visited previously.\nA red circle with a white arrow: This is the robot. The arrow tells us which way it is facing.\nA green circle with a T: This is the target. This is where the robot must move to.\n\nAt the top of the maze, we see the title Robot Maze - Run #1. Here, the number #1 refers to the number of times we have attempted to solve the maze.\nAt the bottom of the maze, we see the Robot Console. This is a handy message box, which we shall use to display messages from the robot throughout this task.\n\n\nMoving the Robot\nHere are some instructions you can give the robot:\n\nrobot.move(): Running this will cause the robot to take one step forward in the direction it is currently facing.\nrobot.turn(): This function takes a string as input. It will turn the robot to the left if the string is \"LEFT\", right if the string is \"RIGHT\", behind if the string is \"BEHIND\" and ahead if the string is \"AHEAD\". The robot always turns relative to the direction it is currently facing (that is, where the white arrow is pointing).\n\nRun the below code to see how this works.\n\n\n\n\n\n\n\nNote: If the robot bumps into a wall, it will not move forward. Instead, it will print a message to the Robot Console telling you it has bumped into a wall.\n\nIf the robot is moving too fast or slow, you can change the speed at which it moves using the robot.delay parameter. For instance:\n\n\n\n\n\n\n\nNote: Due to limitations on how Jupyter notebooks are rendered, there is a limit to how fast the robot can move. That is, setting robot.delay to less than around 0.1 might not result in much of a speedup.\n\n\n\nResetting and Saving the Maze\nIf you want to reset the maze, and send the robot back to the start, you can use the robot.reset() command like so. Notice that the title will now say Robot Maze - Run #2, but the Robot Console will keep the robot’s message history.\n\n\n\n\n\n\nEvery time you run the robot = RobotMaze(), a new random maze is generated. Sometimes you might want to save a particular maze to come back to later. You can do this by running robot.get_maze_id(). For instance, to save the maze you have above, you can run the following:\n\n\n\n\n\n\nYou can then load the same maze again later on using my_maze_id. Try commenting out and uncommenting the below lines of code to test your understanding.\n\n\n\n\n\n\n\nRecall: You can clear the output of a cell in a Jupyter notebook by going to Cell on the toolbar, then Current Outputs and Clear.\n\n\nRecall: You can interrupt a cell that is running in Jupyter by pressing the stop button on the toolbar (which looks like a square) or by clicking Kernel and then Interrupt.\n\n\n\nAims and Limits\nYour aim in this challenge to write code that moves the robot to the target. However, there is a catch - the robot only has a finite amount of fuel!\nThe robot begins with 1000 units of fuel. Each call to robot.move() and robot.turn() costs one unit of fuel. Once the robot has no fuel left, it will not be able to move.\nHere are some functions you can use to check on the robot’s status:\n\nrobot.at_target(): This will return True if the robot is on the target square and False otherwise.\nrobot.check_fuel(): This will tell you how much fuel the robot has left. The amount will be returned as an integer between 0 and 1000.\nrobot.print(): This will print a message to the robot console.\n\nThe below code uses the above commands. See if you can understand what it is doing.\n\n\n\n\n\n\nFinally, the robot is equipped with a sensor that can detect what type of square is in a given direction.\nTo use the sensor, call the robot.sense() function with one of the following inputs: \"AHEAD\", \"LEFT\", \"RIGHT\", or \"BEHIND\". The function returns a string describing the square in that direction, returning either \"WALL\", \"EMPTY\", or \"BEEN_THERE\" if the robot has already visited it.\nHave a look at the below code for an example:\n\n\n\n\n\n\n\nNote: Using the sensor does not require fuel! That is, it may be better to sense before you move…"
  },
  {
    "objectID": "05/week_05_data_science.html#challenges",
    "href": "05/week_05_data_science.html#challenges",
    "title": "",
    "section": "Challenges",
    "text": "Challenges\nWe’re now ready to get to grips with the robot environment!\n\nTask 1: Getting Started\nThe below code will load a simple four by four RobotMaze.\n\n\n\n\n\n\nIn the below box, use the robot.move() and robot.turn() functions to navigate the robot to the target.\n\n\n\n\n\n\nTry to write your code as concisely as possible.\nHint: You may want to use for loops like we did in the example in the Aims and Limits section.\n\n\nTask 2: Sensing Danger\nWe’re now going to look at a pre-written robot maze program. In the below code box, you will see there is a function named my_controller. See if you can determine what this controller does before reading ahead.\n\n\n\n\n\n\nThe nice thing about writing our commands for the robot inside a function is that we can now run the entire set of instructions simply by calling the function, like so:\n\n\n\n\n\n\nTry updating the my_controller function so that the robot first checks for a wall in front of it before attempting to move forward. If a wall is detected, the robot should stay in place and not move.\n\n\n\n\n\n\n\n\nTask 3: End of the Road\nContinuing with the my_controller function, modify your code to identify if the robot is:\n\nAt a dead-end (a square surrounded by three walls),\nAt a corner (a square bordering two walls whose corners touch),\nIn a corridor (a square with two walls bordering it on opposing sides),\nNext to a single wall (a square with only one wall bordering it),\nOn an unbordered square (a square sharing no edges with a wall).\n\nUse the robot.print() function to print a message to the console stating which type of square the robot is on.\n\n\n\n\n\n\n\n\nTask 4: Turning Back\nWrite your own controller function which does the following: - Senses the squares around the robot. - If there at least one of the surrounding squares is \"EMPTY\", the robot should choose an \"EMPTY\" square at random and move to it. - If there are no \"EMPTY\" squares, the robot should choose at random from the \"BEEN_THERE\" squares surrounding it and move to the chosen square.\n\n\n\n\n\n\n\n\nTask 5: Final Challenge\nIt is now up to you!\nBy doing your own research on maze solving algorithms, choose a method to solve the maze and try writing it up as a controller function. Can you solve the maze faster than the my_controller robot, or your solution to Task 4?\nGood luck!"
  },
  {
    "objectID": "05/exercises_python_on_the_field.html",
    "href": "05/exercises_python_on_the_field.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nPython in the field - Exercises\nThe following exercises allow to progress at your pace discovering Python applied to your subjects.\n\nChemistry\nPhysics\nData Science\n\nThere is no requirement to succeed at all of them. Come back to these over time to check the progression of your understanding."
  },
  {
    "objectID": "04/week_04_solutions.html",
    "href": "04/week_04_solutions.html",
    "title": "Week 4: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 4 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "04/week_04_solutions.html#beginner-defining-functions",
    "href": "04/week_04_solutions.html#beginner-defining-functions",
    "title": "Week 4: Solutions",
    "section": "Beginner: Defining Functions",
    "text": "Beginner: Defining Functions\nQuestion 1: Running the code gives the following output.\n3 4\n4 3\n2 4\n2 1\n3 1\nIn the first line, the inputs are assigned according to the order they were read in, so that x=3 and y=4. In the second line, they are assigned according to the keyword/variable names given, so that x=4 and y=3. In the third line, x takes the default value of 2 whilst y=4. In the fourth line, both default values x=2 and y=1 are used. And in the final line, y takes the default value of 1 while x=3.\n\n\n\n\n\n\nQuestion 2: An answer to this question is provided below.\n\n\n\n\n\n\nQuestion 3: The functions for this question are given below.\n\n\n\n\n\n\nQuestion 4: A sample answer for this question is given below:\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 5: The time() function gives the number of seconds passed since epoch (the point where time begins, e.g. January 1, 1970, 00:00:00 UTC is epoch on unix systems). Some suggested code to show students for this question is given below.\n\n\n\n\n\n\nQuestion 6: An example answer for this question is given below.\n\n\n\n\n\n\nQuestion 7: If you write a function which redefines a global variable, then inside the function, Python makes a new local variable x when you assign x = 20. That local version is separate from the global version x = 10. So inside you see 20, and outside you still see 10.\nQuestion 8: Here is an example answer for this question.\n\n\n\n\n\n\nQuestion 9: Example code for this question is given below:\n\n\n\n\n\n\nQuestion 10: Code for this question can be found below"
  },
  {
    "objectID": "04/week_04_solutions.html#intermediate-flexible-inputs-and-outputs",
    "href": "04/week_04_solutions.html#intermediate-flexible-inputs-and-outputs",
    "title": "Week 4: Solutions",
    "section": "Intermediate: Flexible Inputs and Outputs",
    "text": "Intermediate: Flexible Inputs and Outputs\nQuestion 1: The output of the function calls are as follows:\na: 1\nb: 2\nargs: ()\nkwargs: {}\n---------------\na: 1\nb: 2\nargs: (3, 4)\nkwargs: {}\n---------------\na: 1\nb: 2\nargs: ()\nkwargs: {'x': 10, 'y': 20}\n---------------\na: 1\nb: 2\nargs: (3, 4)\nkwargs: {'x': 10, 'y': 20}\n\n\n\n\n\n\nQuestion 2: An example answer for this question is given below:\n\n\n\n\n\n\nQuestion 3: The expected output for this question is:\nHere is another print statement.\n----------------------------\n----------------------------\nHere is a print statement.\n----------------------------\nHere is a print statement.\n----------------------------\n\n\n\n\n\n\nQuestion 4: The code returns True if the integer is prime and False otherwise. The answers to the listed questions are as follows:\n\nWhat values of i will the loop check?\n\nIt will check all values between 2 and my_integer-1, inclusive. Given no prior knowledge, these are the values which could possibly be factors of my_integer.\n\nWhat does the expression my_integer % i mean?\n\nThis is the modulo operator, which we met in the Week 1 Beginner notebook. It gives the remainder obtained from dividing my_integer by i. If this expression equals zero, then my_integer is divisible by i (i.e. i is a factor of my_integer).\n\nUnder what condition does the function return False?\n\nThe function returns False whenever we find an integer i (lying between 2 and my_integer-1) that is a factor of my_integer. In other words, it returns False when my_integer has a factor, that is when my_integer is not prime.\nQuestion 5: The another_mystery_function function takes in a string and reverses the order of the letters. The same thing can be done using, for example, the below loop:"
  },
  {
    "objectID": "04/week_04_solutions.html#advanced-lambda-functions-and-functional-programming",
    "href": "04/week_04_solutions.html#advanced-lambda-functions-and-functional-programming",
    "title": "Week 4: Solutions",
    "section": "Advanced: Lambda Functions and Functional Programming",
    "text": "Advanced: Lambda Functions and Functional Programming\nQuestion 1: An answer to this question is given below:\n\n\n\n\n\n\nQuestion 2: Example code for this question is given below:\n\n\n\n\n\n\nQuestion 3: An example answer is provided below.\n\n\n\n\n\n\nQuestion 4: The reduce expression here is performing function composition and the new function is being evaluated with 5 as input. In other words, if the expression is given a list of function \\([f_1,...,f_n]\\) then the output will be \\((f_1 \\circ f_2 \\circ ... \\circ f_n)(5)=f_1(f_2(...f_n(5)...))\\).\nQuestion 5: This function computes the maximum value in a list. Behind the scenes, it is doing the following:\n\nIt first takes the first two elements, 3 and 1, and applies the lambda function which returns the maximum of the two.\nNext, it takes the result of the first step, in this case 3, and the next element in the list 4. Again it applies the lambda function which returns the maximum of the two.\nIt then repeats this process, each time comparing the current result with the next element of the list, and choosing the maximum of the two, until there are no elements left.\nThe final value produced is the largest value in the list.\n\nAnother way of thinking about it is as doing the following:"
  },
  {
    "objectID": "04/week_04_functions_beginner.html",
    "href": "04/week_04_functions_beginner.html",
    "title": "Beginner: Defining Functions",
    "section": "",
    "text": "Welcome Page\nBeginner: Defining Functions\n\nWhat is a Function?\nAnatomy of a Function\nInputs and Outputs\nVariable Scope\nExercises\n\nIntermediate: Flexible Inputs and Outputs\nAdvanced: Lambda Functions and Functional Programming\nSlides (Powerpoint)",
    "crumbs": [
      "Home",
      "04 Functions",
      "Beginner: Defining Functions"
    ]
  },
  {
    "objectID": "04/week_04_functions_beginner.html#what-is-a-function",
    "href": "04/week_04_functions_beginner.html#what-is-a-function",
    "title": "Beginner: Defining Functions",
    "section": "What is a Function?",
    "text": "What is a Function?\nFunctions are a handy way of parceling up your code, making it easier to reuse, share, and organize. You can think of a function as a block of “pre-prepared” code that you might want to run again and again.\nYou’ve already used a lot of functions without realizing it - for instance:\n\nprint() to display text\n\"hello\".split() to split strings\nstr(), int(), and float() to convert between types\n\nAnything that looks like a name followed by round brackets () is usually a function in Python.\nTo understand why functions are useful, suppose we were writing some code, and it ended up looking something like this:\n\n\n\n\n\n\nIn this program there are several places where we are doing the same operation: doubling a number, adding one, and then printing the result.\nWe can’t use a loop here, since the overall program is not simply repeating over and over, but it is clear that this calculation is repetitive. This is the kind of situation where functions are useful.\nWe can put the repeated logic into a function and give it a name. In Python, functions are created using the def keyword, followed by the function name, a pair of parentheses, and a colon. The code inside the function is indented:\n\n\n\n\n\n\n\nNote: Much like if statements and loops, indentation is very important for functions. Whilst in other languages such as Matlab there are keywords signifying when a function ends (such as end); in Python the only way to tell which code is and is not inside a function is through indentation. In short, make sure your indentation is present and consistent! Also, don’t forget the colon after the def expression!\n\nNow we can call our function whenever we need that same operation, without having to repeat the calculation each time:\n\n\n\n\n\n\nThis version of the program behaves exactly the same, but the repeated calculation is written only once, inside the function. If we ever needed to change the logic (for example, triple the number instead of double it), we would only have to update the function (instead of updating the three lines it was used on one by one).",
    "crumbs": [
      "Home",
      "04 Functions",
      "Beginner: Defining Functions"
    ]
  },
  {
    "objectID": "04/week_04_functions_beginner.html#anatomy-of-a-function",
    "href": "04/week_04_functions_beginner.html#anatomy-of-a-function",
    "title": "Beginner: Defining Functions",
    "section": "Anatomy of a Function",
    "text": "Anatomy of a Function\nLet’s break down the basic syntax of a function.\nThe first line always begins with the def keyword and ends with a colon :. These tell Python where the function starts.\n\n`def` keyword        colon\n  ↓                    ↓\ndef my_function(inputs):\n    print(\"Code inside function\")\n    \nprint(\"Code outside function\")\n\n\nAfter def, we choose a name for the function. In this case, it’s my_function. This is the name we will later use to “call” (i.e. run) the function.\n\n      name of function\n           ↓\ndef my_function(inputs):\n    print(\"Code inside function\")\n    \nprint(\"Code outside function\")\n\n\nNext, inside the round brackets (), we specify the inputs to the function. These are the variables or values that the function will use when it runs.\n\n      inputs to the function\n                 ↓\ndef my_function(inputs):\n    print(\"Code inside function\")\n    \nprint(\"Code outside function\")\n\n\nThe indented block of code that follows is called the body of the function. This code does not run until the function is called.\n\ndef my_function(inputs):\n   print(\"Code inside function\") ← body of the function\n   \nprint(\"Code outside function\")\n\n\nFinally, any code that is not indented is outside the function and will run as normal when the program is executed.\n\ndef my_function(inputs):\n    print(\"Code inside function\")\n    \nprint(\"Code outside function\") ← this code will run as normal\n\n\nDon’t worry if this seems a little confusing for now, we will see lots of examples in the next few sections.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Beginner: Defining Functions"
    ]
  },
  {
    "objectID": "04/week_04_functions_beginner.html#inputs-and-outputs",
    "href": "04/week_04_functions_beginner.html#inputs-and-outputs",
    "title": "Beginner: Defining Functions",
    "section": "Inputs and Outputs",
    "text": "Inputs and Outputs\nYou can think of a function a bit like a black box: you put some inputs into it, the function runs some code, and it gives you a result.\nFor example, the print_double_and_add_one function we saw earlier took in a number x, doubled it, added one, and printed the result.\nUp until now, our functions have only printed things. But often we want a function to return a result that we can use later in our program. This is done with the return keyword.\n\n\n\n\n\n\n\n\n\n\n\n\nNotice how this function doesn’t print the result directly. Instead, it returns it. We then stored the result in m and printed it afterwards.\n\nTest your understanding: Try changing the value of k above. What do you think will happen when you do this?\n\n\nNote: We can also write return(y) instead of return y. Both are valid and do exactly the same thing.\n\nOnce a return statement is reached, the function ends immediately. Any code written after it will not be executed. For instance:\n\n\n\n\n\n\nA function doesn’t just have to have one input. Multiple inputs to a function can be specified like so:\n\n\n\n\n\n\n\nTest your understanding: Write some code which calls this function on the values x=3 and y=2. Predict what output your code will give, and check your answer by running the code.\n\n\n\n\n\n\n\nMultiple outputs can also be returned like so:\n\n\n\n\n\n\nIf we don’t want all the outputs, we can ignore one with the underscore _:\n\n\n\n\n\n\nFunctions can also be written with no inputs or outputs at all. For example:\n\n\n\n\n\n\nInput arguments are named, meaning you can call the function on inputs by using their names, rather than by using the order they were defined in. For example:\n\n\n\n\n\n\nYou can also specify default values for inputs so that if an input is not entered, the function will assume it takes some predefined value. For example:",
    "crumbs": [
      "Home",
      "04 Functions",
      "Beginner: Defining Functions"
    ]
  },
  {
    "objectID": "04/week_04_functions_beginner.html#variable-scope",
    "href": "04/week_04_functions_beginner.html#variable-scope",
    "title": "Beginner: Defining Functions",
    "section": "Variable Scope",
    "text": "Variable Scope\nWhen we create variables inside a function, those variables only exist inside the function. The region of the program where a variable can be used is called the scope of the variable.\nFor example:\n\n\n\n\n\n\nThe variable output_variable is created inside the function, so it only exists while the function is running. Once the function finishes, output_variable disappears.\nVariables created inside a function are called local variables. They can’t be accessed outside of the function.\nOn the other hand, variables created outside of a function are called global variables, and they can be used inside functions (though usually it’s better practice to pass them in as inputs).\n\n\n\n\n\n\nIn general, it’s good practice to:\n\nUse function inputs and outputs rather than relying on global variables.\nGive your variables clear names so you don’t accidentally confuse a local variable with a global one.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Beginner: Defining Functions"
    ]
  },
  {
    "objectID": "04/week_04_functions_beginner.html#exercises",
    "href": "04/week_04_functions_beginner.html#exercises",
    "title": "Beginner: Defining Functions",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Below is a simple function with two inputs.\n\n\n\n\n\n\nWhat do you think will be printed when each of the following is run?\n\nmy_simple_function(3,4)\nmy_simple_function(y=3,x=4)\nmy_simple_function(y=4)\nmy_simple_function()\nmy_simple_function(x=3)\n\nExplain your results and verify your answers by running the code.\nQuestion 2: Write a function that takes a string my_string as input and returns the number of uppercase letters it contains. For example, if the input is \"this Is mY string\", the function should return 2.\nHint: Recall from week 3 that a string is an iterable object. This means that you can iterate over the characters in a string using for character in my_string:. You may also wish to use the upper function.\n\n\n\n\n\n\nQuestion 3: In physics, energy can take different forms. In this question, you will write two functions to calculate kinetic and potential energy.\n\nThe first, calculate_kinetic_energy, should take mass (in kg) and velocity (in m/s) as inputs and return the kinetic energy, E_k, computed using the formula \\(E_{K} = \\frac{1}{2}mv^2\\). For example, if the mass is 2 kg and velocity is 10 m/s, the function should return 100.0.\nThe second, calculate_potential_energy, should take mass (in kg), height (in m), and gravity (in m/s²) as inputs and return the gravitational potential energy, E_p, computed using the formula \\(E_{P} = mgh\\). For example, if mass is 1 kg, height is 50 m, and gravity is 9.8 m/s², the function should return 490.0.\n\n\n\n\n\n\n\nQuestion 4: Your task in this question is to write code which models the behaviour of a ball falling from rest.\nTo begin, you must create a list of time points from 0 to 5 seconds in increments of 0.1 seconds. For every time point, you must then compute the velocity of the ball, using \\(v = gt\\) (\\(g = 9.8\\) m/s²), and the height of the ball using \\(h = h_0 - \\frac12gt^2\\) (where \\(h_0 = 100\\) m is the initial height from which it is dropped). You must record the values in three lists named times, velocities, and heights.\n\n\n\n\n\n\nNext, you must use the functions you wrote in Question 3 to calculate the kinetic and potential energy at each time and store the results in lists called kinetic_energy and potential_energy.\n\n\n\n\n\n\nOnce you have created the lists named times, kinetic_energy and potential_energy, you can run the below code, which should create a plot of the two forms of energy against time. Try to describe what these plots are telling you. Are the energies increasing or decreasing over time? How do you explain their behaviour?\n\n\n\n\n\n\n\nNote: Don’t worry if you are unsure what the import and from keywords are doing in the above code. For now, you can think of these as a way of loading in pre-written functions such as the plot_energy_over_time function. You’ll have plenty of opportunities to practice and understand these features of Python as the course goes on.\n\nQuestion 5: The below code will load a function called time which you can run as time(). See if you can work out what this function does (you may have to look online).\n\n\n\n\n\n\nQuestion 6: Often in speech-to-text processing, spoken audio is transcribed as text. This can produce long strings of English sentences that have been automatically generated from speech. One common problem is that people often use filler words such as \"um\", \"uh\", \"uhm\", \"er\", and \"err\".\nWrite a function remove_filler which takes in a string containing transcribed speech and returns a new string with the same speech but with the filler words listed above removed. For instance, given the text\n\"Um I was, uh, going to the store but uhm I er forgot.\"\nyour function should return\n\"I was, going to the store but I forgot.\"\n\n\n\n\n\n\nHint: You may want to consider the split function for strings for this problem.\nQuestion 7: Consider the following badly written code that uses both a global and a local variable with the same name, x. When you run the code, you’ll notice that the two print statements output different values. By performing your own research online if necessary, see if you can explain why the value printed inside the function differs from the value printed outside the function.\n\n\n\n\n\n\nQuestion 8: The \\(n\\)th Fibonnaci number, \\(F(n)\\), is defined by the following recurrence relation;\n\\(F(0)=0, F(1)=1\\) and \\(F(n)=F(n-1)+F(n-2)\\) for \\(n&gt;1\\)\nWrite a function Fibonnaci which takes in a list of integers [x1,x2,...,xk] of arbitrary length and returns their corresponding fibonnaci numbers, i.e. [F(x1),F(x2),...,F(xk)].\n\n\n\n\n\n\nQuestion 9: The “Look and Say” sequence is a sequence of integers defined in the following way.\n\nThe first member of the “Look and Say” sequence is 1, i.e. \\(l(1) = 1\\).\nTo generate a member of the sequence from the previous member, read the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as “one 1” or 11 (\\(l(2) = 11\\)).\n11 is read off as “two 1s” or 21 (\\(l(3) = 21\\)).\n21 is read off as “one 2, then one 1” or 1211 (\\(l(4) = 1211\\)).\n1211 is read off as “one 1, one 2, then two 1s” or 111221 (\\(l(5) = 111221\\)).\n111221 is read off as “three 1s, two 2s, then one 1” or 312211 (\\(l(6) = 312211\\)).\n\n\nWrite a function which, given the kth integer from the look and say sequence, \\(l(k)\\), computes the (k+1)th integer in the sequence, \\(l(k+1)\\). Hint: The str function may be helpful for this task!\n\n\n\n\n\n\nQuestion 10: Using your function from Question 9, now write a function las_k which given an integer, \\(k\\), returns the kth look and say number, \\(l(k)\\). Give 3 reasons why you think it may be useful to lay out your code in functions in this way.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Beginner: Defining Functions"
    ]
  },
  {
    "objectID": "04/week_04_functions_intermediate.html",
    "href": "04/week_04_functions_intermediate.html",
    "title": "Intermediate: Flexible Inputs and Outputs",
    "section": "",
    "text": "Welcome Page\nBeginner: Defining Functions\nIntermediate: Flexible Inputs and Outputs\n\nParameters and Arguments\nArbitrary Positional and Keyword Arguments\nPositional-Only and Keyword-Only Arguments\nMultiple Returns\nRecursion\nExercises\n\nAdvanced: Lambda Functions and Functional Programming\nSlides (Powerpoint)",
    "crumbs": [
      "Home",
      "04 Functions",
      "Intermediate: Flexible Inputs and Outputs"
    ]
  },
  {
    "objectID": "04/week_04_functions_intermediate.html#parameters-and-arguments",
    "href": "04/week_04_functions_intermediate.html#parameters-and-arguments",
    "title": "Intermediate: Flexible Inputs and Outputs",
    "section": "Parameters and Arguments",
    "text": "Parameters and Arguments\nIn this week’s beginner notebook, we introduced functions and described the values they take in and give out as inputs and outputs. In this notebook, we will use some more precise Python terminology for inputs: parameters and arguments.\n\nA parameter is the variable listed in a function’s definition. It acts as a placeholder that says “this function expects a value here.”\nAn argument is the actual value you provide when calling the function.\n\nFor instance, consider the simple function below:\n\n\n\n\n\n\nIn this case, name is the parameter. It is the label inside the function that will hold the input. \"Sofia\" is the argument. It is the concrete value we supply when calling the function.\nThere are two main ways to pass arguments to a function in Python: - Positional arguments are matched to parameters by the order they appear. - Keyword arguments are matched to parameters by name, using the parameter=value syntax.\nTo see what we mean here, consider the following example:\n\n\n\n\n\n\nThe first call to make_greeting uses positional arguments. This means that arguments are assigned based on the order they are passed into the function. Here, \"Hello\" is matched to greeting and \"Brad\" is matched to name by position.\nThe second call to make_greeting uses keyword arguments. This means that the arguments are matched by name, using the parameter=value syntax. Here, \"Liam\" goes to name and \"Hi\" goes to greeting, even though the order is reversed.\nIn the first half of this notebook, we will look at the different kinds of parameters Python allows us to define, and how arguments can be passed to them in flexible ways.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Intermediate: Flexible Inputs and Outputs"
    ]
  },
  {
    "objectID": "04/week_04_functions_intermediate.html#arbitrary-positional-and-keyword-arguments",
    "href": "04/week_04_functions_intermediate.html#arbitrary-positional-and-keyword-arguments",
    "title": "Intermediate: Flexible Inputs and Outputs",
    "section": "Arbitrary Positional and Keyword Arguments",
    "text": "Arbitrary Positional and Keyword Arguments\nSometimes when coding you may want a function to allow an arbitrary number of inputs. This can be useful because it reduces repetition and makes your code cleaner.\nFor example, consider the following repetitive code:\n\n\n\n\n\n\nThis is not very efficient. It would be much easier if we could just write one function that sums any number of values. One way to do this is to pass a tuple:\n\n\n\n\n\n\nThis works, but notice that the function calls require two sets of round brackets, which, even for this simple example, is slightly clunky and could easily lead to mistakes.\nPython provides a cleaner way of writing the above code using the * operator. This collects all positional arguments into a single tuple inside the function like so:\n\n\n\n\n\n\nThe code inside the function is essentially the same, but now the function calls look much cleaner since we can pass in values directly without square brackets.\nBy convention, when using the * operator to pass arbitrary positional arguments into a function, we name the tuple we pass in args, which stands for “arguments”.\n\n\n\n\n\n\nSo far we have seen how to accept an arbitrary number of positional arguments. But what if we want to accept an arbitrary number of keyword arguments?\nImagine we tried to write separate functions for describing a person:\n\n\n\n\n\n\nThis code is pretty repetitive and messy. One way we could imagine simplifying this code is by using if statements and a dictionary, like so:\n\n\n\n\n\n\nThis works, but again the code feel awkward because we now have to write out a dictionary whenever we call the function.\nPython provides a cleaner way of writing the above code the ** operator. This gathers all keyword arguments into a dictionary inside the function:\n\n\n\n\n\n\nInstead of naming the dictionary my_dict like in the above code, by convention we use tend to use the name kwargs, which is short for “keyword arguments”.\n\n\n\n\n\n\nIn the same way that we can write a function which takes as input both a tuple and a dictionary, such as below:\n\n\n\n\n\n\nWe can instead write a function that takes both arbitrary positional arguments and arbitrary keyword arguments, using *args and **kwargs:",
    "crumbs": [
      "Home",
      "04 Functions",
      "Intermediate: Flexible Inputs and Outputs"
    ]
  },
  {
    "objectID": "04/week_04_functions_intermediate.html#positional-only-and-keyword-only-arguments",
    "href": "04/week_04_functions_intermediate.html#positional-only-and-keyword-only-arguments",
    "title": "Intermediate: Flexible Inputs and Outputs",
    "section": "Positional-Only and Keyword-Only Arguments",
    "text": "Positional-Only and Keyword-Only Arguments\nSo far, we have seen that function arguments in Python can normally be passed either by position or by keyword:\n\n\n\n\n\n\nBoth calls work the same way. But sometimes we want more control. Python gives us two special symbols for this:\n\n/ means everything to the left of it must be positional-only.\n* means everything to the right of it must be keyword-only.\n\nSo you can think of / and * as markers in the parameter list that divide it into three possible regions:\nmy_function(a,b,/,c,d,*,e,f)\nHere, we have that:\n\na and b are positional-only parameters.\nc and d can be specified using position or keyword.\ne and f are keyword-only parameters.\n\nLet’s, look at some examples. The below function will take positional arguments only:\n\n\n\n\n\n\nHere, x and y are to the left of /, so they can only be given by position.\nSimilarly, this example will accept keyword arguments only:\n\n\n\n\n\n\nHere, name and age are to the right of *, so they must be given as keywords.\nWe can allow a function to have a mix of all three types of parameters (positional-only, keyword or positional, or keyword-only) as follows:\n\n\n\n\n\n\n\nTest your Understanding: Without writing code, consider the following expressions:\n\ndemo(1, 2, c=3, d=4, e=5, f=6)\ndemo(a=1, 2, 5, e=3, d=4, f=6)\ndemo(1, 2, c=5, e=3, d=4, f=6)\ndemo(1, 2, d=3, 4, e=5, f=6)\n\nWhat do you think each of the above will print and why? Will any of them error? If so, which?",
    "crumbs": [
      "Home",
      "04 Functions",
      "Intermediate: Flexible Inputs and Outputs"
    ]
  },
  {
    "objectID": "04/week_04_functions_intermediate.html#multiple-returns",
    "href": "04/week_04_functions_intermediate.html#multiple-returns",
    "title": "Intermediate: Flexible Inputs and Outputs",
    "section": "Multiple Returns",
    "text": "Multiple Returns\nSo far, we’ve spent time looking at how you can flexibly specify arguments for functions. Now let’s shift focus slightly and look at another useful trick when writing functions: multiple return statements.\nNormally, a function ends when it reaches a return statement. But functions can also contain more than one return, which allows us to stop the function and send back a result as soon as we know what that result should be.\nHere’s a simple example:\n\n\n\n\n\n\nThe function stops running the moment it hits a return. To understand why this feature might be useful, consider the below code which computes the length of each string in a list.\n\n\n\n\n\n\nThis works, but it’s a bit cumbersome as we are keeping track of the result variable throughout. We can simplify this code substantially using multiple return statements:\n\n\n\n\n\n\nNow the logic is much cleaner:\n\nIf the list is empty, return immediately.\nIf we find a bad entry, return immediately.\nOtherwise, return the processed list.\n\nThe key idea here is that a return statement ends the function immediately. Everything after it is skipped. You can think of it as if Python is automatically wrapping everything after a return in an invisible else.\nThis often makes your functions shorter, easier to read, and can help spot errors and bugs.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Intermediate: Flexible Inputs and Outputs"
    ]
  },
  {
    "objectID": "04/week_04_functions_intermediate.html#recursion",
    "href": "04/week_04_functions_intermediate.html#recursion",
    "title": "Intermediate: Flexible Inputs and Outputs",
    "section": "Recursion",
    "text": "Recursion\nAnother useful feature of the Python programming language is that it allows recursion. A recursive function is a function that calls itself. For example:\n\n\n\n\n\n\nIn this example, the function countdown calls itself with a smaller number each time. Eventually, it reaches the base case (n == 0) and stops.\n\nTest your Understanding: See if you can modify the above so that, instead of counting down to zero, it counts up to 10 and then prints Blast off!.\n\nRecursion can be useful for problems that can be broken down into smaller versions of the same problem, such as:\n\nsearching through folders and files,\nworking with tree-like data structures,\nor classic mathematical problems like factorials.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Intermediate: Flexible Inputs and Outputs"
    ]
  },
  {
    "objectID": "04/week_04_functions_intermediate.html#exercises",
    "href": "04/week_04_functions_intermediate.html#exercises",
    "title": "Intermediate: Flexible Inputs and Outputs",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Consider the below function.\n\n\n\n\n\n\nWithout running any code, predict what will happen when you run the following function calls:\n\nprinting_function(1, 2)\nprinting_function(1, 2, 3, 4)\nprinting_function(1, 2, x=10, y=20)\nprinting_function(1, 2, 3, 4, x=10, y=20)\n\nDo you think the function will error for any of the above inputs? If so, which? Verify your answers by running the code.\nHint: Consider what would happen if you had instead passed my_tuple and my_dict into the function, like we did in the section on arbitrary positional and keyword arguments.\nQuestion 2: Write a function, sumstrings which takes in an arbitrary number of arguments, each a string which represents an integer between 1 and 10 (e.g. one, two, three,… ten), and returns the sum of the strings in numeric form. e.g. sumstrings('ten', 'five', 'eight') should return the integer 23.\nMake it so that your function inputs are not case sensitive. I.e. an input of ‘ten’ should be treated the same as ‘tEn’, ‘TEn’, ‘TEN’, etc.\n\n\n\n\n\n\nQuestion 3: Below is a function containing an if statement. The function has one input and one output.\n\n\n\n\n\n\nWhat do you think will be printed when you run each of the following commands?\n\nfunction_with_if(-1)\nfunction_with_if(0)\nfunction_with_if(1)\nfunction_with_if()\n\nExplain your answers and verify them by running the code.\nQuestion 4: Consider the following function, which takes in a positive integer:\n\n\n\n\n\n\nBefore running the code, try to work out what this function is supposed to do. You may wish to consider the following questions:\n\nWhat values of i will the loop check?\nWhat does the expression my_integer % i mean?\nUnder what condition does the function return False?\n\nTest the function on several inputs, such as 2, 7, 9, 15, 17. Based on your tests, describe in plain English what this function is trying to check.\nQuestion 5: Consider the following recursive function:\n\n\n\n\n\n\nRun this function on a few different inputs (e.g. \"hello\", \"Python\") and try to work out what the function is doing. Once you understand the logic of the function, try rewriting the function using a loop.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Intermediate: Flexible Inputs and Outputs"
    ]
  },
  {
    "objectID": "04/week_04_functions_advanced.html",
    "href": "04/week_04_functions_advanced.html",
    "title": "",
    "section": "",
    "text": "Code",
    "crumbs": [
      "Home",
      "04 Functions",
      "Advanced: Lambda Functions and Functional Programming"
    ]
  },
  {
    "objectID": "04/week_04_functions_advanced.html#lambda-functions",
    "href": "04/week_04_functions_advanced.html#lambda-functions",
    "title": "",
    "section": "lambda Functions",
    "text": "lambda Functions\nWe’ll begin today by considering a new kind of function: the lambda function. A lambda function is a way to create a function “on the fly” without using the def keyword. Because of this, they are sometimes called anonymous functions.\nThe general syntax is:\n\nlambda arguments: expression\n\nFor instance, consider the below function.\n\n\n\n\n\n\nWe can write exactly the same code using a lambda function as follows:\n\n\n\n\n\n\nNotice a few things:\n\nThere is no def or return here.\nThe return is implicit: the result of the expression is what gets returned.\nTo use the function, we assigned it to a variable (here, my_function).\n\nAlthough we assigned the function to a variable here, we could have used it directly, like so:\n\n\n\n\n\n\nAt first sight, this might not look very different from a normal function. The main reason to use lambda is when you want a small, throwaway function that you do not plan to reuse elsewhere.\nFor example, instead of writing:\n\n\n\n\n\n\nWe can instead write:\n\n\n\n\n\n\nHere we created the function and used it immediately, all in one line.\nThere are, of course, limitations to the lambda syntax. - A lambda can only contain a single expression. - You cannot put multiple lines of logic, loops, or assignments inside.\nAs a result, for more complicated computations, it is often preferable to use normal def functions. Nevertheless, the lambda syntax, and more broadly the Lambda calculus upon which it’s based, is a useful tool for writing quick and interpretable code.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Advanced: Lambda Functions and Functional Programming"
    ]
  },
  {
    "objectID": "04/week_04_functions_advanced.html#functions-as-objects",
    "href": "04/week_04_functions_advanced.html#functions-as-objects",
    "title": "",
    "section": "Functions as Objects",
    "text": "Functions as Objects\nIn the previous section, we wrote:\n\n\n\n\n\n\nAt first this might seem unusual… we’ve taken a function and saved it into a variable! But in fact, behind the scenes, this is what we are always doing whenever we define a function. For example:\n\n\n\n\n\n\nIn both cases, we have created an object called my_function. That object happens to be a function, but it can still be treated like any other variable: it can be passed around, stored in data structures, or even overwritten.\nBecause functions are objects, we can pass them into other functions. For instance, consider the below:\n\n\n\n\n\n\nHere, we have defined two functions, f and g, but passed them into run_on_input_of_five as though they are variables.\nNote that run_on_input_of_five doesn’t know in advance which function it will be given. It just accepts a function object as input and calls it with the argument 5.\n\nTest your Understanding: Write a function h such that:\n\nIf it is given the input 5, it returns the string \"example output\".\nFor any other input, it returns the string \"not 5\".\n\nWhat do you think will happen when you run run_on_input_of_five(h)? Verify your answer by running the command yourself.\n\nSometimes it is useful to refer to a function that takes other functions as input as a higher-order function (if you study category theory later on in other modules, you may also hear these referred to as functionals). Higher-order functions are extremely powerful, because they let us build general tools that work with any function we choose to give them.\nIn the following sections, we will look at some commonly used built-in higher-order functions in Python: map, filter, and reduce.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Advanced: Lambda Functions and Functional Programming"
    ]
  },
  {
    "objectID": "04/week_04_functions_advanced.html#map",
    "href": "04/week_04_functions_advanced.html#map",
    "title": "",
    "section": "map",
    "text": "map\nIn the previous section, we saw that functions are objects, which means we can pass them as inputs to other functions. One popular higher-order function in Python is map.\nmap takes as input a function and an iterable object (like a list), and applies the function to every element of the iterable. Its general form is:\n\nmap(function, iterable)\n\nFor example, suppose we want to square every number in a list. Normally we might write a loop:\n\n\n\n\n\n\nWith map, we can do this more directly:\n\n\n\n\n\n\nNote that map returns a special object, so we usually convert it into a list to see the results.\nSince map only needs a function once, it is common to use a lambda instead of defining a full function. For instance, we can rewrite our above code like so:\n\n\n\n\n\n\nThis is much shorter than the for loop approach and avoids wastefully creating a named function square.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Advanced: Lambda Functions and Functional Programming"
    ]
  },
  {
    "objectID": "04/week_04_functions_advanced.html#filter",
    "href": "04/week_04_functions_advanced.html#filter",
    "title": "",
    "section": "filter",
    "text": "filter\nAnother very common higher-order function in Python is filter. The filter function takes two inputs:\n\na function that decides whether to keep an item,\nand an iterable (like a list).\n\nIts general form is:\n\nfilter(function, iterable)\n\nThe function we pass to filter must return either True or False for each item. If it returns True, the item is kept. If it returns False, the item is removed.\nLet’s look at an example. Suppose we want to keep only even numbers from a list. Using a loop, we might write:\n\n\n\n\n\n\nWith filter, we can do this more directly:\n\n\n\n\n\n\nAs with map, we can make this code even more concise by using a lambda function as follows:",
    "crumbs": [
      "Home",
      "04 Functions",
      "Advanced: Lambda Functions and Functional Programming"
    ]
  },
  {
    "objectID": "04/week_04_functions_advanced.html#reduce",
    "href": "04/week_04_functions_advanced.html#reduce",
    "title": "",
    "section": "reduce",
    "text": "reduce\nWe have now seen two useful higher-order functions. map applied a function to every element of an iterable and returned the transformed results. filter applied a function to every element of an iterable and kept only those where the function returned True.\nThe third higher-order function we will look at is reduce. Instead of working on elements one by one and producing a list, reduce applies a function over and over again to the elements of an iterable, each time using the previous result as one of the inputs. In this way, the entire iterable is “reduced” to a single value.\nUnlike map and filter, reduce is not an in-built Python function. To use reduce, we must import it from Python’s functools module:\n\n\n\n\n\n\n\nNote: This is the first time in this course that we have used an import statement. Do not worry too much if you are not sure what this means yet. We will use this syntax a lot later on in the course.\n\nThe general form of the reduce function is:\n\nreduce(function, iterable)\n\nHere, the function must take two arguments. reduce will apply the function it step by step through the iterable. To understand this, let’s look at an example.\nSuppose we have a list of words and we want to join them into a single string with spaces in between. Using a for loop we might write:\n\n\n\n\n\n\nWith reduce, we can write the same loop as follows:\n\n\n\n\n\n\nBehind the scenes, reduce is doing the following:\n\nIt first takes the first two elements, words[0] and words[1], and applies my_concatenate to produce a new string (let’s call this result1).\nNext, it takes result1 together with the third element, words[2], and applies my_concatenate again to produce result2.\nIt then repeats this process, each time combining the current result with the next element of the list, until there are no elements left.\nThe final value produced is returned as the overall output of reduce.\n\nIn other words, it is doing the following:\n\n\n\n\n\n\nAs with the previous examples, we can simplify the above code using lambda functions. In this case, the code would become:",
    "crumbs": [
      "Home",
      "04 Functions",
      "Advanced: Lambda Functions and Functional Programming"
    ]
  },
  {
    "objectID": "04/week_04_functions_advanced.html#exercises",
    "href": "04/week_04_functions_advanced.html#exercises",
    "title": "",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Below you are given a very long list of strings. Using the filter function and a lambda expression, print all of the strings that contain between three and eight characters (inclusive).\n\n\n\n\n\n\nQuestion 2: Below, you are given a list of dictionaries representing demographic data for several individuals:\n\n\n\n\n\n\nUsing the map function and an appropriate choice of lambda function, extract the \"name\" from each dictionary and return the result as a list.\n\n\n\n\n\n\nBonus: Using material from the recent advanced notebooks, can you think of an alternative way of extracting the same list of names from the people variable?\nQuestion 3: Write a function my_filter that takes as input two functions, f and g and an iterable my_iterable. Your function must return a list of all values in my_iterable for which exactly one of the functions f or g returns True.\n\n\n\n\n\n\nQuestion 4: Suppose the variable function_list is a list of lambda expressions, each of which takes a float as input and produces a float as output. For example:\n\n\n\n\n\n\nYou are given the following line of code. Run this code and explain mathematically how the result was generated from the functions in function_list\n\n\n\n\n\n\nQuestion 5: lambda functions can also be combined with the conditional statement syntax we met in the Week 2 advanced notebook. By performing your own research, see if you can understand what the below code is doing.\n\n\n\n\n\n\nOnce you understand what the code is outputting, try to explain how it works.\nHint: Start by considering the lambda function lambda x, y: x if x &gt; y else y - what does this return?",
    "crumbs": [
      "Home",
      "04 Functions",
      "Advanced: Lambda Functions and Functional Programming"
    ]
  },
  {
    "objectID": "03/week_03_home.html",
    "href": "03/week_03_home.html",
    "title": "Loops",
    "section": "",
    "text": "Welcome to the third week of the 2025 SCIF10002 Introduction to Coding and Data Analysis for Scientists course! This week we shall be looking at for and while loops!",
    "crumbs": [
      "Home",
      "03 Loops",
      "Loops"
    ]
  },
  {
    "objectID": "03/week_03_home.html#todays-material",
    "href": "03/week_03_home.html#todays-material",
    "title": "Loops",
    "section": "Today’s Material",
    "text": "Today’s Material\nIn today’s class, we shall focus on loops. As in the previous two classes, this week you have a choice of working through one of three notebooks.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\nOption 1: Beginner\nIf you have not spent much time coding in Python prior to taking this course, today you should work through the for and while loops notebook linked below:\n\nBeginner: For and While Loops\n\nThis notebook will talk you through the basics of loops in Python. Please read through the text carefully and attempt all exercises!\n\n\nOption 2: Intermediate\nThis weeks intermediate notebook should only be taken by those who are very comfortable with the material in the beginner notebook. Please ensure that you are able to complete the exercises in the beginner notebook before attempting this option. The intermediate material for this week is given below:\n\nIntermediate: Advanced Iteration\n\nThis notebook will guide you through more advanced loop syntax such as iteration over dictionaries and the zip function.\n\n\nOption 3: Advanced\nIf you are an experienced programmer with a strong grasp of Python, begin by reviewing the exercises in the notebooks below to ensure you are fully comfortable with the material:\n\nBeginner: For and While Loops\n\nIntermediate: Advanced Iteration\n\nOnce you are confident in your understanding, move on to the following notebook:\n\nAdvanced: Comprehensions\n\nThis will introduce you to list, set, dict and generator comprehensions, and explain how they can be combined with conditional expressions. Please only attempt this notebook if you have a strong background in Python programming.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Loops"
    ]
  },
  {
    "objectID": "03/week_03_home.html#getting-help",
    "href": "03/week_03_home.html#getting-help",
    "title": "Loops",
    "section": "Getting Help",
    "text": "Getting Help\nThere is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\n\n\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_advanced.html",
    "href": "03/week_03_loops_advanced.html",
    "title": "Advanced: Comprehensions",
    "section": "",
    "text": "Welcome to the Week 3 Advanced Python Notebook. This notebook is designed for students who already have substantial experience with writing loops in Python and are confidence on the material from the Beginner and Intermediate material.\nYour task today is to carefully read through the content and complete the exercises at the end. These exercises are more challenging and are intended to deepen your understanding of how Python handles data behind the scenes.\nIn this notebook, you will explore comprehensions. Comprehensions are a short-hand syntax for creating collections from for loops and are extremely useful for condensing long code and improving readbility.\nWork through the examples carefully, and take your time with the exercises. They are designed to stretch your understanding and prepare you for advanced applications of Python.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Advanced: Comprehensions"
    ]
  },
  {
    "objectID": "03/week_03_loops_advanced.html#list-comprehensions",
    "href": "03/week_03_loops_advanced.html#list-comprehensions",
    "title": "Advanced: Comprehensions",
    "section": "List Comprehensions",
    "text": "List Comprehensions\nIn this section, we shall look at a nice short-hand for creating a list using a for loop known as a list comprehension. To get started let’s consider the following for loop:\n\n\n\n\n\n\nGiven a list of numbers, numbers, this code looks through the list one-by-one, squaring each element and saving it in the numbers_squared list. This code is nice, but quite long for a fairly simple operation.\nThe same logic can be written more concisely with a list comprehension as follows:\n\n\n\n\n\n\nAs can be seen, we still have a lot of the syntax from the original for loop (we keep the keywords for and in for instance), but the code is now much shorter and potentially more readable.\nIn general the syntax for a list comprehension is as follows:\n\nresult = [expression for item in iterable]\n\nLet’s break this down a little. In this syntax, we have: - iterable: The sequence we loop over (e.g. a list, string, range,… etc). - item: The variable representing the current element from the iterable. - expression: What we want to calculate using item. - for... in: These express the for loop itself. - []: This indicates that we are building a list. - result: The variable we save the output to.\nHere are two more examples of a list comprehensions:\n\n\n\n\n\n\n\nTest your understanding: Using your knowledge of list comprehensions, explain what the above code is doing. What are the list_comprehension1 and list_comprehension2 lists counting? Why is the last element of list_comprehension2 equal to zero?\n\nList comprehensions are not the only type of comprehension in Python. The same concise syntax can be used to build sets and dictionaries.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Advanced: Comprehensions"
    ]
  },
  {
    "objectID": "03/week_03_loops_advanced.html#set-comprehensions",
    "href": "03/week_03_loops_advanced.html#set-comprehensions",
    "title": "Advanced: Comprehensions",
    "section": "Set Comprehensions",
    "text": "Set Comprehensions\nA set comprehension looks almost identical to a list comprehension, except that it uses curly braces {} instead of square brackets [].\n\n\n\n\n\n\nNotice that sets automatically remove duplicates. For instance, even both \\(-2\\) and \\(2\\) appear in the list, \\(4=2^2=(-2)^2\\) appears only once in the set.\nThe general syntax for a set comprehension is given by:\n\nresult = {expression for item in iterable}\n\nThis is identical to the expression for list comprehensions, except the square brackets have been replaced by curley braces.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Advanced: Comprehensions"
    ]
  },
  {
    "objectID": "03/week_03_loops_advanced.html#dictionary-comprehensions",
    "href": "03/week_03_loops_advanced.html#dictionary-comprehensions",
    "title": "Advanced: Comprehensions",
    "section": "Dictionary Comprehensions",
    "text": "Dictionary Comprehensions\nA dictionary comprehension allows us to generate key–value pairs in a single line. The syntax is very similar to list and set comprehensions, but instead of just an expression, we provide a key: value pair for each item.\n\n\n\n\n\n\nTo see what’s happening under the hood, here’s the same example written using a standard for loop:\n\n\n\n\n\n\nBoth versions create a dictionary that stores the fruit name as the key and its length as the value. The comprehension just combines the loop and assignment into a single, concise expression.\nAgain the syntax is similar here, but this time we have:\n\nresult = {key_expression: value_expression for item in iterable}\n\nNotice that we are still using curly braces {}, just like in a set comprehension. The difference here is the colon (:) inside the braces. The colon tells Python we are building key-value pairs for a dictionary rather than a values for a set.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Advanced: Comprehensions"
    ]
  },
  {
    "objectID": "03/week_03_loops_advanced.html#combining-conditionals-and-comprehensions",
    "href": "03/week_03_loops_advanced.html#combining-conditionals-and-comprehensions",
    "title": "Advanced: Comprehensions",
    "section": "Combining Conditionals and Comprehensions",
    "text": "Combining Conditionals and Comprehensions\nSo far, we’ve seen comprehensions that apply the same operation to every element of an iterable. But often we want to be more selective. We might instead want to:\n\nOnly include items that meet some condition.\nOr transform items differently depending on a condition.\n\nComprehensions let us do both of these by combining them with conditional expressions.\nFiltering Items: A conditional at the end of a comprehension can be keep items which satisfy a certain criteria and disregard others. For instance, the below list comprehension keeps only the even numbers:\n\n\n\n\n\n\nThis comprehension says:\n\nloop through the numbers 0–9,\ncheck if each one is divisible by 2,\nand only keep those which are divisible by 2.\n\nThe equivalent for loop looks like this:\n\n\n\n\n\n\nThis same idea also works for sets and dictionaries:\n\n\n\n\n\n\n\nTest your understanding: Make sure you understand the above code before moving on. How would you modify the set comprehension to select odd numbers instead?\n\nConditional Expressions Inside a Comprehension: Instead of filtering, you can also use a conditional expression inside the comprehension to decide how to transform each item. Here every element is included, but its value depends on the condition.\n\n\n\n\n\n\nThis comprehension says:\n\nloop through the numbers 0–5,\nuse the number as the key,\nand store \"even\" or \"odd\" as the value depending on whether it divides by 2.\n\nThe equivalent for loop is given by:\n\n\n\n\n\n\n\nNote: Further information on conditional expressions can be found in the week 2 advanced notebook.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Advanced: Comprehensions"
    ]
  },
  {
    "objectID": "03/week_03_loops_advanced.html#generator-comprehensions",
    "href": "03/week_03_loops_advanced.html#generator-comprehensions",
    "title": "Advanced: Comprehensions",
    "section": "Generator Comprehensions",
    "text": "Generator Comprehensions\nAll the comprehensions we have seen so far (lists, sets, and dictionaries) build the entire collection as soon as you define them. Python loops through the iterable right away, computes every result, and stores them in memory.\nThat is fine for small data, but if the sequence is very large the computation can use a lot of memory. Often we do not need to keep everything at once. Instead, it is better to produce values only when they are actually needed.\nA generator comprehension allows us to do exactly that. It looks just like a list comprehension, but uses round parentheses () instead of square brackets [].\n\n\n\n\n\n\nHere, squares is not a list. It is a generator object. Instead of computing and storing all the values at once, it creates them one at a time as you iterate over it. This makes generator comprehensions memory efficient, since nothing is stored unnecessarily. They only ever evaluate on demand, producing values when the program asks for them.\nFor example:\n\n\n\n\n\n\nThis calculates the sum of a million squares efficiently because Python generates each square only when the sum() function requests it, and then discards it right away.\nGenerator comprehensions are preferable when you need to perform computations that are larger than you can fit in memory. However, generator comprehensions can also be slower than list comprehensions, as they require more access to physical memory. In practice, which tool is best will depend upon the task you are doing.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Advanced: Comprehensions"
    ]
  },
  {
    "objectID": "03/week_03_loops_advanced.html#exercises",
    "href": "03/week_03_loops_advanced.html#exercises",
    "title": "Advanced: Comprehensions",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: From range(1, 21), use a comprehension to create a set of the squares of the even numbers only.\n\n\n\n\n\n\nQuestion 2: Below is a large integer.\n\n\n\n\n\n\nUsing a list comprehension and the sum function, work out the sum of the digits of my_integer.\n\n\n\n\n\n\nHint: Convert the integer to a string first and recall that strings are iterable!\nQuestion 3: In this question we shall call an integer that equals the sum of the cubes of it’s digits “pluriperfect”. For example \\(153\\) is pluriperfect as \\(153=1^3+5^3+3^3\\). Using the range function together with list comprehensions, compute all pluriperfect numbers between \\(0\\) and \\(999\\).\n\n\n\n\n\n\nHint: For this question, you can use the sum function, which sums the items in a list. You may find that you need more than one list comprehension for this task!\nQuestion 4: Below is a long string:\n\n\n\n\n\n\nUsing an appropriate choice of comprehension and conditional statements, compute and print the unique vowels in my_string. Your code should account for spaces, punctuation, numbers and case.\n\n\n\n\n\n\nHint: You might want to consider the lower function from week 1 and the membership test in \"aeiou\".\nQuestion 5: The built-in function max() can be applied to any generator or iterable covered in this notebook. It returns the largest value in a numerical collection. Suppose you want to modify your code from question 3 to find the largest pluriperfect number less than 10000000000. Which comprehension would be most appropriate for this task, and why? You do not need to implement your answer for this question.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Advanced: Comprehensions"
    ]
  },
  {
    "objectID": "03/week_03_solutions.html",
    "href": "03/week_03_solutions.html",
    "title": "Week 3: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 3 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "03/week_03_solutions.html#beginner-for-and-while-loops",
    "href": "03/week_03_solutions.html#beginner-for-and-while-loops",
    "title": "Week 3: Solutions",
    "section": "Beginner: For and While Loops",
    "text": "Beginner: For and While Loops\nQuestion 1: The below code box contains an answer to this question.\n\n\n\n\n\n\nQuestion 2: A solution is given below.\n\n\n\n\n\n\nQuestion 3: The below code computes the factorial with a while loop.\n\n\n\n\n\n\nQuestion 4: An answer to this question is given below:\n\n\n\n\n\n\nQuestion 5: The code will print \"Python\" four times, one for each power of two.\nQuestion 6: The problem here is that the position = position + 1 is incorrectly indented and thus the position only changes when we encounter vowels. Once we encounter a consonant, we get stuck at that position indefinitely, never updating. The solution is as follows:\n\n\n\n\n\n\nQuestion 7: An example answer is given below.\n\n\n\n\n\n\nQuestion 8: A solution to this question is given below:\n\n\n\n\n\n\nQuestion 9: One possible solution is provided below:\n\n\n\n\n\n\nQuestion 10: Here is an example solution."
  },
  {
    "objectID": "03/week_03_solutions.html#intermediate-advanced-iteration",
    "href": "03/week_03_solutions.html#intermediate-advanced-iteration",
    "title": "Week 3: Solutions",
    "section": "Intermediate: Advanced Iteration",
    "text": "Intermediate: Advanced Iteration\nQuestion 1: Here is the solution:\n\n\n\n\n\n\nQuestion 2: Below is a solution for this question.\n\n\n\n\n\n\nQuestion 3: The answer to this question is to change the break to a continue. This is as the break ends the loop prematurely, whilst continue just skips to the next iteration. The current code gets to num=1 and then executes the break statement, thus terminating the loop early.\n\n\n\n\n\n\nQuestion 4: Solution code is provided below:\n\n\n\n\n\n\nQuestion 5: The error in this code is the indentation of the else block. Here else should be at the same level as the if to make an if... else. However, it is at the level of the for creating a for...else. This means that it will always be executed for the last day so long as a break is not encountered in the loop. To rectify this, we just indent like so:"
  },
  {
    "objectID": "03/week_03_solutions.html#advanced-comprehensions",
    "href": "03/week_03_solutions.html#advanced-comprehensions",
    "title": "Week 3: Solutions",
    "section": "Advanced: Comprehensions",
    "text": "Advanced: Comprehensions\nQuestion 1: The solution is below:\n\n\n\n\n\n\nQuestion 2: The answer to this question is as follows:\n\n\n\n\n\n\nQuestion 3: Below is list comprehension for this question.\n\n\n\n\n\n\nQuestion 4: The solution is given below:\n\n\n\n\n\n\nQuestion 5: The correct answer to this question is to use a generator comprehension, so that the values inside the comprehension are computed lazily (only when needed). If we use a list comprehension for this task, we will end up trying to compute 10000000000 values instantly and crash the memory."
  },
  {
    "objectID": "03/week_03_slides.html#todays-lecture",
    "href": "03/week_03_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 3: Loops\n\nRecap: Accessing Noteable\nRecap: If Statements\nFor Loops\nWhile Loops\nPractical"
  },
  {
    "objectID": "03/week_03_slides.html#recap-accessing-noteable",
    "href": "03/week_03_slides.html#recap-accessing-noteable",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: Accessing Noteable",
    "text": "Recap: Accessing Noteable\n\nOpen Blackboard\nGo to Introduction to Coding and Data Analysis for Scientists 2025\nClick Unit Information and Resources\nOpen Noteable\n\nMake sure Jupyter Classic (Legacy) is selected.\nClick Start\n\nClick +GitRepo\nPaste into Git Repository URL: git@github.com:TomMaullin/SCIF10002-2025.git\nPress clone"
  },
  {
    "objectID": "03/week_03_slides.html#important-assessed-coursework-1",
    "href": "03/week_03_slides.html#important-assessed-coursework-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Important: Assessed Coursework 1",
    "text": "Important: Assessed Coursework 1\n\nThe first assignment will be released this week!\n\nReleased Wednesday 8th October at 12:00PM\nDue Wednesday 22nd October at 12:00PM\n\nThis is assessed (15% of your grade!)\nSubmission is via Noteable\nYou can submit as many times as you like up until the submission date"
  },
  {
    "objectID": "03/week_03_slides.html#noteable-submission",
    "href": "03/week_03_slides.html#noteable-submission",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Noteable Submission",
    "text": "Noteable Submission\n\nDownload using the Assignments tab on noteable\nPress Fetch and click on the assignment\nFill your answers in and Validate\nOnce done, save your answers and Submit\nFeedback will be available when you see the (view feedback) option"
  },
  {
    "objectID": "03/week_03_slides.html#recap-if-statements",
    "href": "03/week_03_slides.html#recap-if-statements",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: If Statements",
    "text": "Recap: If Statements\n\nLast week, we looked at the if statement\nif statements allow us run code only when a specific condition is True\nWe can add elif and else statements to give us finer control over when code is executed\n\nAn elif runs if it’s Boolean is True and all previous clauses (ifs and elifs) did not execute\nAn else runs if all other clauses did not execute\n\nToday, we will look at another feature of Python that gives us finer control over our code - loops"
  },
  {
    "objectID": "03/week_03_slides.html#motivation",
    "href": "03/week_03_slides.html#motivation",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Motivation",
    "text": "Motivation\n\nSuppose we want to do a very repetitive computation\nFor instance, suppose we want to print the square of each item in this list\n\n\n\n\n\n\n\n\nWe could just write something like this…"
  },
  {
    "objectID": "03/week_03_slides.html#motivation-1",
    "href": "03/week_03_slides.html#motivation-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Motivation",
    "text": "Motivation\n\nBut it would be nice to be able to do this automatically!\nThis is what loops do!"
  },
  {
    "objectID": "03/week_03_slides.html#iterable-objects",
    "href": "03/week_03_slides.html#iterable-objects",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Iterable Objects",
    "text": "Iterable Objects\n\nAn iterable object is an object which contains lots of elements that we could list one by one\nWe’ve already seen an example - the list\nOther examples include:\n\nTuples - like lists but use round brackets and can’t be changed\nDictionaries - records “keys” and “values” so that we can look up data using labels of our choosing\nA range object - a python object that represents a sequence of numbers, saved in a useful, memory-efficient way\n\nA for loop performs an operation on each element in an iterable object"
  },
  {
    "objectID": "03/week_03_slides.html#for-loops",
    "href": "03/week_03_slides.html#for-loops",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "For Loops",
    "text": "For Loops\n\nA for loop lets you run code for every element in an iterable object\nLet’s look at an example:\n\n\n\n\n\n\n\nTranslation:\n\n“For every number in the list, print that number”"
  },
  {
    "objectID": "03/week_03_slides.html#while-loops",
    "href": "03/week_03_slides.html#while-loops",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "While Loops",
    "text": "While Loops\n\nA while loop lets you run code repeatedly so long as a Boolean statement is True\n\n\n\n\n\n\n\nLet’s compare this to an if statement - An if statement executes once if the Boolean is True - An while loop executes repeatedly until the Boolean is False"
  },
  {
    "objectID": "03/week_03_slides.html#practical",
    "href": "03/week_03_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_03_home.ipynb\nFor the rest of today, you must work through a Python notebook\nYou have a choice of one of three options\n\nOption 1: Beginner - For and While Loops\nOption 2: Intermediate - Advanced Iteration\nOption 3: Advanced - Comprehensions"
  },
  {
    "objectID": "03/week_03_solutions_demonstrator_version.html",
    "href": "03/week_03_solutions_demonstrator_version.html",
    "title": "Loops - Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 3 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "03/week_03_solutions_demonstrator_version.html#beginner-for-and-while-loops",
    "href": "03/week_03_solutions_demonstrator_version.html#beginner-for-and-while-loops",
    "title": "Loops - Solutions",
    "section": "Beginner: For and While Loops",
    "text": "Beginner: For and While Loops\nQuestion 1: The below code box contains an answer to this question.\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to give students some practice thinking about while loops, and in particular, when they should terminate. If students are struggling, emphasize the fact that, if we were doing this task by hand, we would look at the words one by one, and that we only stop writing when there are no more words left. Try to get the students to translate this natural language into code.\n\nQuestion 2: A solution is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to encourage students to form a habit of looking up documentation for themselves. Please do not give them the answer straight away, but instead encourage them to look up online resources.\n\nQuestion 3: The below code computes the factorial with a while loop.\n\n\n\n\n\n\n\nDemonstrator Notes: Like Question 1, this question aims to get students thinking about while loops and when they should terminate. If the students are struggling, have them perform the computation by hand on paper. They will likely compute \\(6 \\times 5\\) first, then multiply that by \\(4\\) and so on, stopping only when they hit \\(1\\). Try to relate the steps they perform to the process of coding the while loop.\n\nQuestion 4: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to give students practice combining conditional logic with loops. For many students, this may also be the first time they are encountering the idea of appending value to a list inside each iteration of a for loop. A common error in this question is AttributeError: 'NoneType' object has no attribute 'append'. If you see this error, the chances are the student has written output_list = output_list.append(i**2) when they should just have output_list.append(i**2). The append function does not return anything, it just adds the element to the list, so writing output_list = ... just sets output_list to None.\n\nQuestion 5: The code will print \"Python\" four times, one for each power of two.\n\nDemonstrator Notes: Encourage students to write this one out on paper if they are stuck. Again, this question is mainly for practice so try to avoid giving them the answer directly where possible.\n\nQuestion 6: The problem here is that the position = position + 1 is incorrectly indented and thus the position only changes when we encounter vowels. Once we encounter a consonant, we get stuck at that position indefinitely, never updating. The solution is as follows:\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to give students practice debugging code. Encourage them to use the print function to help them understand what is happening on each iteration of the while loop.\n\nQuestion 7: An example answer is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: The correct output for this question is: Difference between highest and lowest scores: 61 Highest score: Ava Brooks with 99 Lowest score: Noah Murphy with 38 This is the first time students have been asked to compute a maximum/minimum using loops. If students are struggling with this, simplify the problem and ask them to work out only the maximum of a single list using a for loop, working through the solution with them on paper first if you need to.\n\nQuestion 8: A solution to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is tough, so reassure students if they are struggling with it. Also, be aware that many students may not have studied Pascal’s triangl and be unaware of it’s construction. Make sure the student understands the context of the question (i.e. what Pascal’s triangle actually is), before offering to help them solve it.\n\nQuestion 9: One possible solution is provided below:\n\n\n\n\n\n\n\nDemonstrator Notes: A common stumbling point is that students don’t realize they must convert the integer to a string to reverse its digits. To help them see this, suggest working through a simple example like n=102 (ignoring the loop for now): guide them step-by-step on converting to a string, reversing it, and checking if it’s a palindrome.\n\nQuestion 10: Here is an example solution.\n\n\n\n\n\n\n\nDemonstrator Notes: The expected solution is \\(840\\). If a student is struggling, provide them with a candidate number (e.g. candidate=480) and have them write some code to check whether this candidate is divisibly by \\(1,...,8\\). Then ask them how they might expand on this code by looping over all possible candidates."
  },
  {
    "objectID": "03/week_03_solutions_demonstrator_version.html#intermediate-advanced-iteration",
    "href": "03/week_03_solutions_demonstrator_version.html#intermediate-advanced-iteration",
    "title": "Loops - Solutions",
    "section": "Intermediate: Advanced Iteration",
    "text": "Intermediate: Advanced Iteration\nQuestion 1: Here is the solution:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is fairly straightforward and just involves using the zip function. If students need help on this question, advise them to read over the section on enumerate and zip. If they are still struggling, advise them to drop a level and attempt the beginner notebook.\n\nQuestion 2: Below is a solution for this question.\n\n\n\n\n\n\n\nDemonstrator Notes: Many students may still be fairly new to the idea of an index, so it is worth checking they understand the question correctly before helping with the code on this question. It is also expected that many will forget that Python is zero-indexed, but will not voice their confusion. Make sure they understand which index corresponds to which element in the list. The expected output for this question is:\n[0, 2, 3, 5, 7, 8, 10, 12, 13, 15, 17, 19]\n\nQuestion 3: The answer to this question is to change the break to a continue. This is as the break ends the loop prematurely, whilst continue just skips to the next iteration. The current code gets to num=1 and then executes the break statement, thus terminating the loop early.\n\n\n\n\n\n\n\nDemonstrator Notes: Encourage students who are struggling to consider what the break statement is doing in this code. If necessary, advise them to revisit the break, continue and pass section. The hope is that this will prompt them to consider the differences between these keywords.\n\nQuestion 4: Solution code is provided below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is drawing on several concepts and is technically challenging. It is expected that some students will have forgotten how to append to a list. If a student is struggling with this, prompt them to attempt question 4 from the beginner notebook as a warmup for this question. This should hopefully encourage them to think about building collections one item at a time using append.\n\nQuestion 5: The error in this code is the indentation of the else block. Here else should be at the same level as the if to make an if... else. However, it is at the level of the for creating a for...else. This means that it will always be executed for the last day so long as a break is not encountered in the loop. To rectify this, we just indent like so:\n\n\n\n\n\n\n\nDemonstrator Notes: Encourage students who are struggling with this to revisit the for and else section."
  },
  {
    "objectID": "03/week_03_solutions_demonstrator_version.html#advanced-comprehensions",
    "href": "03/week_03_solutions_demonstrator_version.html#advanced-comprehensions",
    "title": "Loops - Solutions",
    "section": "Advanced: Comprehensions",
    "text": "Advanced: Comprehensions\nQuestion 1: The solution is below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is reasonably straightforward and designed to give students practice with the syntax of comprehensions. If, even with help, a student is really struggling with this, suggest that they drop a difficulty level and look at the intermediate material.\n\nQuestion 2: The answer to this question is as follows:\n\n\n\n\n\n\n\nDemonstrator Notes: The “trick” to this question is to convert the integer to a string and loop over the characters of the string. A student who doesn’t spot this immediately is unlikely to realise this is how to solve the problem later. So, for this question, it is fine to give them a guided solution rather than trying to give prompts.\n\nQuestion 3: Below is list comprehension for this question.\n\n\n\n\n\n\n\nDemonstrator Notes: This question is challenging and it is expected that many students will struggle with the inner list comprehension. If a student is struggling, focus on a single value of n and talk them through how you might check that n is pluriperfect.\n\nQuestion 4: The solution is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The main objective of this question is for students to recognise that the set comprehension is the most appropriate choice when you need to list unique values. If they are using some other form of comprehension, please prompt them to reconsider this decision.\n\nQuestion 5: The correct answer to this question is to use a generator comprehension, so that the values inside the comprehension are computed lazily (only when needed). If we use a list comprehension for this task, we will end up trying to compute 10000000000 values instantly and crash the memory.\n\nDemonstrator Notes: The actual code for this answer would be very slow, as it is performing a very large computation. This is why the students have been told not to implement any code. However, the equivalent computation, when performed with a list comprehension, would consume too much memory and could crash the notebook entirely, so the generator comprehension is still preferable. If the students ask, tell them that we will cover more efficient tools for this task later in the course when we look at numpy."
  },
  {
    "objectID": "03/week_03_loops_beginner.html",
    "href": "03/week_03_loops_beginner.html",
    "title": "Beginner: For and While Loops",
    "section": "",
    "text": "Welcome to the Week 3 Beginner Python Notebook. This notebook is designed for students who are just starting out with the Python programming language.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.\nIn this notebook, you will be introduced to loops. In particular, you will learn what an iterator, iterable, for loop and while loop are. Loops are fundamental to coding as they allow you to automatically repeat computations on a large scale.\nBe sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Beginner: For and While Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_beginner.html#motivation",
    "href": "03/week_03_loops_beginner.html#motivation",
    "title": "Beginner: For and While Loops",
    "section": "Motivation",
    "text": "Motivation\nOver the past two weeks, we have looked at some basic data types and conditional logic in Python. This week it is time to start scaling up our computation!\nTo begin today, let’s consider a simple coding task. Suppose you are asked to print the first 10 Triangle Numbers. With only what we know so far, the code might look something like this:\n\n\n\n\n\n\nThis code is already long and repetitive, but imagine if I’d instead asked you to go up to \\(100\\), or \\(1,000\\)! This task would be impossible!\nLoops give us a way to automate repetition. Instead of writing the same line of code again and again, we’ll learn how to tell Python: “Do this thing repeatedly until I say stop.”\nBy the end of today, you’ll be able to write the same task in just one or two lines of code.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Beginner: For and While Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_beginner.html#iterators-and-iterables",
    "href": "03/week_03_loops_beginner.html#iterators-and-iterables",
    "title": "Beginner: For and While Loops",
    "section": "Iterators and Iterables",
    "text": "Iterators and Iterables\nSo far we’ve seen several basic data types in Python:\n\nNumeric data types: 3, -10, 4.5\nStrings: \"hello\", \"Python\"\nBooleans: True, False\n\nBut often, we want to work with more than one piece of data at once. For example: a list of students in a class, a list of prices in a shop, or a list of daily temperatures.\nIn Python, a list is a collection of values, written inside square brackets []:\n\n\n\n\n\n\nIn the same way that floats, ints, strings and booleans are data types in Python, so is a list. For example:\n\n\n\n\n\n\nA list can contain as many elements as you want, and they don’t all have to be the same type.\nYou can also ask for one item at a time using its index (position in the list). Python uses zero-indexing, which means it starts counting from 0:\n\n\n\n\n\n\nA list is an example of an iterable object.\nAn iterable object is any Python object that contains a countable number of elements; in other words, it’s an object that can give you it’s elements one by one.\nWe’ve already seen two examples of iterables:\n\nlists are iterables: [10,20,30,40] can give you 10, 20, 30, 40.\nstrings are also iterables: \"hello\" can give you \"h\", \"e\", \"l\", \"l\", \"o\".\n\nGiven an iterable object, you can create something known as an iterator.\nAn iterator is a special object that lets you step through the elements of an iterable, one at a time, and remembers where you are in the process. In Python, you can create an iterator from an iterable using the built-in function iter():\n\n\n\n\n\n\nThe useful thing about an iterator is that it lets us print elements out one by one, always remembering where we were up to. Specifically, we can use the built-in next function to get each element in turn:\n\n\n\n\n\n\nA particularly useful example of an iterable object is the output of the range function. You can think of range(n) as a compact way of representing the numbers 0, 1, 2, ..., n-1. In other words, it produces an iterable containing the first n non-negative integers, ready to be used in computations.\n\n\n\n\n\n\n\nTest your understanding: By modifying the above code, work out what happens if you give range two inputs instead of one. e.g. what does range(2,4) do?\n\nRecap: In this section, we introduced a new data type, the list, and saw that lists (as well as strings) are examples of iterables. We also learned about iterators, which are the tools Python uses to step through those iterables one element at a time.\nTo summarize, here are the definitions of iterable and iterator:\n\nIterable: an object that multiple elements (like a list or string) that can be listed off one at a time.\nIterator: an object that remembers a position within an iterable and produces the next element each time you ask for it.\n\nIn the next section, we will see how you can move through values of an iterable object automatically using a for loop.\n\nNote: If you would like to learn more about lists, have a look at the week 1 intermediate notebook on collections. This will show you various operations that can be performed on lists, as well as introduce you to other iterable data types such as tuples, sets and dictionaries.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Beginner: For and While Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_beginner.html#for-loops",
    "href": "03/week_03_loops_beginner.html#for-loops",
    "title": "Beginner: For and While Loops",
    "section": "for loops",
    "text": "for loops\nIn the last section, we saw how an iterator can give us the elements of an iterable one at a time using the next() function. But having to write next() repeatedly is a bit repetitive and clunky…\nPython gives us a much simpler way to go through all the elements of an iterable: the for loop.\n\n\n\n\n\n\nIn this code:\n\nnumbers is the iterable.\nnum is a variable that takes on the value of each element, one at a time.\n\nThe indented block of code under the loop (print(num)) runs once for each element.\nLet’s break down the general syntax of the for loop. The first line must contain the for keyword and a colon, :. These tell us where the for loop starts.\n\n`for` keyword                colon\n  ↓                           ↓\nfor my_variable in my_iterable:\n    print(\"My variable now equals\", my_variable)\n\n\nThen, after the for, we must name a variable. Here my_variable is just a name you are choosing to represent an arbitrary element in the iterable object. &gt;\n &gt;   variable name  \n &gt;         ↓                    \n &gt; for my_variable in my_iterable:\n &gt;     print(\"My variable now equals\", my_variable)\n &gt; \nAfter the variable is named we write the the in keyword followed by my_iterable. Here my_iterable is the iterable variable you want to loop through (for instance, a list or string) and the in keyword tells us that we are looking at values in that iterable. &gt;\n &gt;      `in` keyword    iterable object  \n &gt;                 ↓        ↓\n &gt; for my_variable in my_iterable:\n &gt;     print(\"My variable now equals\", my_variable)\n &gt; \nFinally, inside the loop, we provide the code we want to run for every value of my_variable. In this case we are just printing it’s value.\n\nfor my_variable in my_iterable:\n    print(\"My variable now equals\", my_variable)  ← body of the for loop\n\n\nLet’s see some examples.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest your understanding: Make sure you understand this last example. How would you modify it to print the length of each word in the sentence? Hint: You might need the len() function from the week 1 beginner notebook.\n\nWarning: Just like with an if statement, the body of a for loop must be indented. If you forget to indent, or if the indentation is inconsistent, Python will raise an error.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Beginner: For and While Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_beginner.html#while-loops",
    "href": "03/week_03_loops_beginner.html#while-loops",
    "title": "Beginner: For and While Loops",
    "section": "while loops",
    "text": "while loops\nA for loop is useful when we want to repeat a computation once for every element in an iterable. But sometimes, instead of looping over a collection, we want to keep running a computation until a certain condition is met.\nFor example, we might want to:\n\nkeep rolling a die (generating random integers between \\(1\\) and \\(6\\)) until we get a six, or\nkeep doubling a value until it becomes larger than 100.\n\nTo handle situations like these, Python provides the while loop.\nA while loop repeatedly runs a block of code so long as a given Boolean statement is True. For example, in the below, the block of code is run while the statement n &lt; 10 is True.\n\n\n\n\n\n\nThe syntax for a while loop looks very similar to an if statement. A while loop is introduced using the keyword while and a colon ::\n\nwhile keyword  colon\n  ↓             ↓\nwhile my_boolean:\n    # Run some code\n\n\nIn-between these, we must include a booean statement, e.g. my_boolean.\n\nBoolean statement\n          ↓\nwhile my_boolean:\n    # Run some code\n\n\nFinally, the indented lines underneath form the body of the loop. This is the part that runs repeatedly:\n\nwhile my_boolean:\n    # Run some code  ← body of the while loop\n\n\nThe body will keep running again and again as long as the boolean expression evaluates to True. It is worth making the comparison between if statements and while loops explicit:\n\nAn if statement checks its condition once and runs the body a single time (if True).\nA while loop keeps checking the condition and repeats the body until the condition becomes False.\n\nLet’s look at a small worked example to make the while loop syntax clearer.\n\n\n\n\n\n\nIn this example, we can imagine the while loop as if Python were repeating the indented code over and over:\n\n\n\n\n\n\nAfter every repetition, the loop is checking whether the boolean i &lt; 3 is True. Since, on the last repetition i is now equal to 3, the condition is False, so the loop does not run another time. That is, the while loop ends there.\n\nWarning: A while loop will keep running as long as its boolean condition is True. If the condition never becomes False, the loop will never end. This is called an infinite loop.\nFor example, the following code never terminates because i is never updated (run this at your peril!):\n\n\n\n\n\n\n\n\nTo avoid infinite loops, you must ensure that the boolean eventaully becomes False.\nOf course, mistakes are inevitable. In a Jupyter notebook, an infinite loop can freeze the cell. If this happens, do one of the following:\n\nClick the \"stop\" button (■) in the toolbar, or\nUse the menu: Kernel -&gt; Interrupt.\nUse the menu: Kernel -&gt; Restart.\n\nThe last option completely restarts the Python notebook and clears everything from memory, so use it only as a last resort.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Beginner: For and While Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_beginner.html#nested-loops",
    "href": "03/week_03_loops_beginner.html#nested-loops",
    "title": "Beginner: For and While Loops",
    "section": "Nested Loops",
    "text": "Nested Loops\nOne of the most useful features of loops is that you can nest them inside one another.\nThat means you can put a for loop inside a while loop, a while loop inside a for loop, or even nest loops of the same kind. This is powerful as it lets us perform tasks that require multiple layers of repetition. Here are some examples:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest your understanding: If you have already run the three code boxes above, clear the output from each. On paper, use your understanding of loops to predict exactly what each example will print. Rerun the code to check your answers.\n\nTo see why nested loops are useful, let’s work through an example.\nSuppose we want to list all prime numbers up to a given number n.\nIntuitively we need to check whether each number between \\(1\\) and \\(n\\) is prime. We can visualise this like so:\n\n\n\n\n\n\nBut how do we do the check inside the loop? Well, let’s take an example value of i, say i = 7. If we were doing this task by hand, we’d check if 7 is divisible by 2, then by 3, then by 4, and so on until we reach 7. This can be done with a loop too:\n\n\n\n\n\n\n\nTest your understanding: Why does the above code work? If you are unsure, ask one of the demonstrators for help!\n\nThis code tells us if one value (here i=7) is prime. But, how can we relate this to our original problem, checking if all values between 1 and n are prime? The answer is simply that we can place this code inside our larger loop from earlier:",
    "crumbs": [
      "Home",
      "03 Loops",
      "Beginner: For and While Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_beginner.html#exercises",
    "href": "03/week_03_loops_beginner.html#exercises",
    "title": "Beginner: For and While Loops",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Given the two strings in the code block below, use a while loop and the split function to make a new string which contains: - the 1st word from the 1st string - the 1st word from the 2nd string - the 2nd word from the 1st string - the 2nd word from the 2nd string - the 3rd word from the 1st string - … and so on\nEach word must be seperated from the last with a space.\n\n\n\n\n\n\nHint: You may wish to look up the split function in the Week 1 beginner notebook.\nQuestion 2: By looking up the documentation for the range function. Write some code which prints the numbers 1 to 100 in reverse order. That is, 100 should be printed first, then 99 and so on…\n\n\n\n\n\n\nQuestion 3: Below is an integer n. Using a while loop, compute the factorial of \\(n\\) given by \\(n!=n\\times (n-1)\\times... \\times 2 \\times 1\\).\n\n\n\n\n\n\nQuestion 4: Using a for loop, print the square of all of the elements in the list below which are greater than \\(2\\) or less than \\(-2.5\\).\n\n\n\n\n\n\nNow do the same, but saving the elements in a new list named output_list.\n\n\n\n\n\n\nHint: You can add a new element to a list by using the append method. An example of this is given in the below code block.\n\n\n\n\n\n\nQuestion 5: Without running the below code, predict how many times the word \"Python\" will be printed. Explain your answer, and then verify it by running the below code.\n\n\n\n\n\n\nQuestion 6: The below code uses a while loop to count the number of vowels in the word word. However, something has gone wrong! The below code will never terminate when run. Explain why this has happened and implement a fix.\n\n\n\n\n\n\n\nNote: Be careful running this code! As mentioned above, in it’s current form, the code will never terminate.\n\nQuestion 7: Using a loop, work through the dictionary of exam results below to find the difference between the highest and lowest scores. Print the names of the students who achieved those scores. You may assume that all scores like between \\(0\\) and \\(100\\).\n\n\n\n\n\n\n\nNote: In this question, we are using the dictionary datatype. Dictionaries in Python allow us to store data as key-value pairs. In this case, the key is a student’s name, and the value is their exam score. For this question, you need to know that you can access individual items like print(exam_results['Liam Turner']) and you can obtain a list of all the keys (student names) using names_in_dict = exam_results.keys(). If you would like to learn more about the dictionary datatype, please have a look at the week 1 intermediate notebook.\n\nQuestion 8: Use two nested for loops to print the first n lines of Pascal’s Triangle. For instance, if \\(n=5\\) your code should print:\n1 \n1 1 \n1 2 1 \n1 3 3 1 \n1 4 6 4 1 \n1 5 10 10 5 1 \n\n\n\n\n\n\nQuestion 9: A palendromic number is an integer that reads the same when its digits are reversed.\nFor example:\n\n\\(124\\) is not palindromic, because reversing the digits gives \\(421\\neq 124\\).\n\\(121\\) is palindromic, because reversing the digits gives \\(121=121\\).\n\nUsing the range function together with a for loop, compute all palindromic numbers between \\(0\\) and \\(1000\\).\n\n\n\n\n\n\nHint: You can reverse a string using [::-1] as shown below:\n\n\n\n\n\n\nThis is an example of slicing. If you would like to learn more about slicing lists see the Week 1 (Intermediate) notebook.\nQuestion 10: Using a while loop and a for loop, compute the smallest positive number that is evenly divisible by all of the numbers from \\(1\\) to \\(8\\).\n\n\n\n\n\n\nHint: These loops may need to be nested inside one another!",
    "crumbs": [
      "Home",
      "03 Loops",
      "Beginner: For and While Loops"
    ]
  },
  {
    "objectID": "03/week_03_loops_intermediate.html",
    "href": "03/week_03_loops_intermediate.html",
    "title": "Intermediate: Advanced Iteration",
    "section": "",
    "text": "Welcome to the Week 3 Intermediate Python Notebook. This notebook is designed for students who already have some experience with Python and are ready to build on the basics.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.\nThis notebook builds on basic for and while loops by exploring advanced iteration techniques in Python. It covers sequence unpacking in for loops, the continue, break and pass statements and the lesser-known else clause for for loops.\nBe sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Intermediate: Advanced Iteration"
    ]
  },
  {
    "objectID": "03/week_03_loops_intermediate.html#dicts-as-iterables.",
    "href": "03/week_03_loops_intermediate.html#dicts-as-iterables.",
    "title": "Intermediate: Advanced Iteration",
    "section": "dicts as iterables.",
    "text": "dicts as iterables.\nThe Beginner notebook for this weeks class introduces the notions of iterators and iterables, and shows how you can iterate over lists and strings. In this notebook, we will start by looking at a slightly more complex example; dictionaries.\nDictionaries (dicts) are also iterable in Python, but what exactly does that mean? When you iterate over a dictionary directly, you get its keys:\n\n\n\n\n\n\n\nNote: If you are unfamiliar with the dict datatype, take a look at the intermediate collections notebook for week 1 of this course.\n\nBy default, iterating over a dict gives you its keys. However, you can also access values or key-value pairs using methods like .keys(), .values(), and .items(). Let’s have a look at these, using the above dictionary:\n\n\n\n\n\n\nLet’s take a closer look at this last example. In this case, the iterable student_grades.items() seems to be giving us two values, name and grade, rather than one. What is happening here?\nLet’s make student_grades.items() into an iterator using the iter keyword and print off it’s items one-by-one using the next keyword (further detail on iter and next can be found in the beginner notebook).\n\n\n\n\n\n\nWe can now see what is happening, the items() iterable object is giving us a sequence of tuples and when we write for name, grade in student_grades.items(), Python is treating the first element of each tuple as name and teh second element as grade. This is an example of sequence unpacking and is a bit like how you can write the following for tuples.\n\n\n\n\n\n\nWe’ll see more examples of tuple unpacking in for loops in the next section when we look at the zip and enumerate functions.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Intermediate: Advanced Iteration"
    ]
  },
  {
    "objectID": "03/week_03_loops_intermediate.html#enumerate-and-zip",
    "href": "03/week_03_loops_intermediate.html#enumerate-and-zip",
    "title": "Intermediate: Advanced Iteration",
    "section": "enumerate and zip",
    "text": "enumerate and zip\nIn the last section, we saw how unpacking items from a dictionary was an example of sequence unpacking in a for loop. In this section, we’ll explore two more convenient tools that use sequence unpacking: the enumerate and zip functions. To understand why these are useful, let’s start with a motivating example.\nHere we have three lists of equal length and we want to loop over them all at the same time.\n\n\n\n\n\n\nWhile this works, it’s a bit cumbersome. We’ve we spent several lines just defining variables inside the for loop. This is where the zip function comes in handy. zip takes multiple iterables (like lists) and pairs their elements together, allowing you to iterate over them in a single loop:\n\n\n\n\n\n\nThis code achieves the same result but is much cleaner. Here, zip(list_a, list_b, list_c) creates an iterable that yields tuples like ('Happy', 'dog', 'runs'), ('Sad', 'cat', 'sleeps'), and so on. We’re then using sequence unpacking inside the for loop to assign each part of the tuple to a, b, and c. This works for any number of lists (as long as they’re iterable), and it automatically stops at the end of the shortest one if they’re not all the same length.\nNow, let’s look at another common situation where sequence unpacking is very useful: when you need both the value from a list and its index (position) during iteration. For example, suppose you have a list of exam scores and want to flag any that are below a passing mark, reporting the student’s position in the list (say, the student_number) in the process. One approach might be to write:\n\n\n\n\n\n\nAgain this is a little cumbersome; we have an extra line of code defining score inside the loop. It would be nice to use sequence unpacking to remove this. This is where we can use the enumerate function, like so:\n\n\n\n\n\n\nIn this case, enumerate(scores) yields tuples like (0, 85), (1, 92), etc and we unpack them directly into student_number and score in the for loop.\nSummary: - zip lets you loop over several lists at once by pairing their elements into tuples - enumerate gives you both the index and the value while you loop, so you don’t have to count manually",
    "crumbs": [
      "Home",
      "03 Loops",
      "Intermediate: Advanced Iteration"
    ]
  },
  {
    "objectID": "03/week_03_loops_intermediate.html#continue-break-and-pass-statements",
    "href": "03/week_03_loops_intermediate.html#continue-break-and-pass-statements",
    "title": "Intermediate: Advanced Iteration",
    "section": "continue, break and pass Statements",
    "text": "continue, break and pass Statements\nIn the last few sections, we explored how you can use sequence unpacking to improve your loops readability. In this section, we’re going to investigate a different set of Python tools, which can also give you finer control and improve readability when it comes to writing loops; these are the continue, break, and pass statements. We’ll now look at each of these in turn.\nLet’s start with continue. The continue statement allows you to skip the rest of the current loop’s code block and immediately jump to the next iteration. For instance, in the below code, when i==2 we skip over the print statement and move to the next iteration of the loop.\n\n\n\n\n\n\nThe above code is equivalent to running:\n\n\n\n\n\n\nWhether or not to use the continue statement often comes down to personal preference. In some cases, however, it can make code more readable by reducing indentation - for example, notice how print(i) is less indented in the version of the above code that uses continue.\nThe break statement is similar to continue - both give you control over the flow of a loop. But while continue lets you skip ahead to the next iteration, break lets you end the whole thing right then and there.\nFor example, the following loop will “break” when i==2 and terminate completely:\n\n\n\n\n\n\nThis prints only 0 and 1, because as soon as i hits 2, the break kicks in and the loop stops dead. There are no more iterations, and no more printing.\nThis kind of early exit can be very useful when you know you might not need to go through the entire sequence. For instance, imagine you have a list of numbers and you’re just looking for the first duplicate - you don’t care about any others after that. In such a case, you might want to use a break as shown below:\n\n\n\n\n\n\nFinally, there’s the pass statement. This statement doesn’t change the flow of your loop at all. It’s just there to keep Python happy when you need a statement syntactically but don’t want to do anything yet. Think of it like a sticky note saying “I’ll fill this in later.” For example, the below code will throw an error if we try to run it.\n\n\n\n\n\n\nHowever, if we put a pass inside the loop, then the code will ignore the incomplete body, like so:\n\n\n\n\n\n\nThis is a handy statement to know when you are working on large complex coding projects with lots going on!",
    "crumbs": [
      "Home",
      "03 Loops",
      "Intermediate: Advanced Iteration"
    ]
  },
  {
    "objectID": "03/week_03_loops_intermediate.html#for-and-else",
    "href": "03/week_03_loops_intermediate.html#for-and-else",
    "title": "Intermediate: Advanced Iteration",
    "section": "for and else",
    "text": "for and else\nYou might be surprised to learn that Python’s for loops can have an else clause! It’s a somewhat unusual feature, but can be very useful in specific situations.\nThe else block associated with a for loop is executed if and only if the loop completes normally. In other words, the else is executed if the loop completes it’s iteration without encountering a break statement. If a break statement is executed inside the loop, the else block is skipped.\nHere’s an example to illustrate:\n\n\n\n\n\n\nIn this case, the loop completes without finding the number 6, so the else block is executed, printing \"Did not find 6 in the list.\".\nNow, let’s change the list:\n\n\n\n\n\n\nThis time, the loop encounters the number 6 and executes the break statement. As a result, the else block is not executed.\nYou’ll most often see for...else in search scenarios where you need to take action if an item isn’t found. The else block serves as your “search failed” handler, making the code’s logic more explicit and self-contained without requiring additional variables to whether the item was found or not.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Intermediate: Advanced Iteration"
    ]
  },
  {
    "objectID": "03/week_03_loops_intermediate.html#exercises",
    "href": "03/week_03_loops_intermediate.html#exercises",
    "title": "Intermediate: Advanced Iteration",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: You are given two lists. One contains students’ names, and the other contains their exam scores in the same order:\n\n\n\n\n\n\nWrite a for loop using the zip() function that prints each student’s name along with their score in the following format:\nAlice scored 85\nBob scored 92\nCharlie scored 78\n\n\n\n\n\n\nQuestion 2: Below is a list of strings. Using a for loop and the enumerate function create a list of indices of the strings containing the letter \"t\". For instance if the list was [\"bat\", \"dog\", \"rat\"] your code should return [0, 2].\n\n\n\n\n\n\nQuestion 3: The following code was intended to print every odd number from the list numbers. However, in the example below it only prints the number 1. Explain why the code does not work as intended, and then fix the error by changing only one line of code.\n\n\n\n\n\n\nQuestion 4: You are given a dictionary where the keys are unique, but the values may repeat. Write a for loop that creates a new dictionary by swapping the keys and values from the original dictionary. This means that:\n\nThe new keys should be the old values.\nThe new values should be lists containing all the old keys that had that value.\n\nFor instance, if the original_dict was given by:\noriginal_dict = {\n    'a': 1,\n    'b': 2,\n    'c': 1,\n    'd': 3,\n    'e': 2\n}\nThen your code should output:\ninverted_dict = {\n    1: ['a', 'c'],\n    2: ['b', 'e'],\n    3: ['d']\n}\nIn your solution, you must use sequence unpacking in the for loop (i.e., unpack the key and value directly in the loop header).\n\n\n\n\n\n\nQuestion 5: The following program is supposed to check each day in the list days and print whether it is a weekday or at the weekend. However, something has gone wrong! In the below code the day Monday is skipped entirely. Explain what has gone wrong here and fix the error.",
    "crumbs": [
      "Home",
      "03 Loops",
      "Intermediate: Advanced Iteration"
    ]
  },
  {
    "objectID": "03/exercises_loop.html",
    "href": "03/exercises_loop.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nLoops - Exercises\nThe following exercises allow to progress at your pace discovering Python loops.\n\nBeginner\nIntermediate\nAdvanced\n\nThere is no requirement to succeed at all of them. Come back to these over time to check the progression of your understanding."
  },
  {
    "objectID": "04/exercises_function.html",
    "href": "04/exercises_function.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nFunctions - Exercises\nThe following exercises allow to progress at your pace discovering Python functions.\n\nBeginner\nIntermediate\nAdvanced\n\nThere is no requirement to succeed at all of them. Come back to these over time to check the progression of your understanding."
  },
  {
    "objectID": "04/week_04_slides.html#todays-lecture",
    "href": "04/week_04_slides.html#todays-lecture",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Today’s Lecture",
    "text": "Today’s Lecture\n\nLecture 4: Functions\n\nRecap: For and While Loops\nFunctions\nInputs and Outputs\nPractical"
  },
  {
    "objectID": "04/week_04_slides.html#important-assessed-coursework-1",
    "href": "04/week_04_slides.html#important-assessed-coursework-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Important: Assessed Coursework 1",
    "text": "Important: Assessed Coursework 1\n\nThe first assignment has been released!\n\nReleased Wednesday 8th October at 12:00PM\nDue Wednesday 22nd October at 12:00PM\n\nThis is assessed (15% of your grade!)\nSubmission is via Noteable\nYou can submit as many times as you like up until the submission date"
  },
  {
    "objectID": "04/week_04_slides.html#noteable-submission",
    "href": "04/week_04_slides.html#noteable-submission",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Noteable Submission",
    "text": "Noteable Submission\n\nDownload using the Assignments tab on noteable\nPress Fetch and click on the assignment\nFill your answers in and Validate\nOnce done, save your answers and Submit\nFeedback will be available when you see the (view feedback) option"
  },
  {
    "objectID": "04/week_04_slides.html#recap-for-and-while-loops",
    "href": "04/week_04_slides.html#recap-for-and-while-loops",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: for and while loops",
    "text": "Recap: for and while loops\n\nLoops can be used to simplify repetitive computation\n\nLast week, we saw an example where we wanted to print the square of each item in this list\n\n\n\n\n\n\n\n\n\nWe could write code like this…"
  },
  {
    "objectID": "04/week_04_slides.html#recap-for-and-while-loops-1",
    "href": "04/week_04_slides.html#recap-for-and-while-loops-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Recap: for and while loops",
    "text": "Recap: for and while loops\n\nLoops let us do all this automatically!"
  },
  {
    "objectID": "04/week_04_slides.html#motivation",
    "href": "04/week_04_slides.html#motivation",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Motivation",
    "text": "Motivation\n\nLoops let you simplify code which repeats over and over again.\nHowever, sometimes you have code that repeats itself in a less straightforward manner…\n\nDo some computation\nRun some other code\nDo the same computation again\n\n\n\n\n\n\n\n\n\nIn such cases, you might want to use a function\nYou can think of a function as a block of pre-prepared code that you might want to run over and over again."
  },
  {
    "objectID": "04/week_04_slides.html#functions",
    "href": "04/week_04_slides.html#functions",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Functions",
    "text": "Functions\n\nLet’s look at an example.\n\n\n\n\n\n\n\nYou can think of this as a black box\n\nYou put a variable x in\nIt doubles x and adds 1\nThen prints the result"
  },
  {
    "objectID": "04/week_04_slides.html#functions-1",
    "href": "04/week_04_slides.html#functions-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Functions",
    "text": "Functions\n\nSuppose we now run this code after the function.\n\n\n\n\n\n\n\n\nThis will run the code inside the function, but with x replaced by k.\n\nE.g. it will run:\n\n\ny = k * 2 + 1\nprint(y)"
  },
  {
    "objectID": "04/week_04_slides.html#functions-2",
    "href": "04/week_04_slides.html#functions-2",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Functions",
    "text": "Functions\n\nWe can use this function to simplify the code from earlier!"
  },
  {
    "objectID": "04/week_04_slides.html#motivation-1",
    "href": "04/week_04_slides.html#motivation-1",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Motivation",
    "text": "Motivation\n\nFunctions are useful for a number of reasons\n\nReduce repetitiveness in code\nHelp organise code\nEasier to edit, maintain and debug\nMakes code easier to share\nImprove readability"
  },
  {
    "objectID": "04/week_04_slides.html#inputs-and-outputs",
    "href": "04/week_04_slides.html#inputs-and-outputs",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Inputs and Outputs",
    "text": "Inputs and Outputs\n\nInstead of printing the result of our function, we can return it\nThis means that the function will “spit out” the value of y, and we can save it using the = operator\n\n\n\n\n\n\n\n\nFor this example:\n\nx is an input: A variable specified in the function definition\ny is an output: A variable given back using the return statement\n\nYou can have multiple inputs and outputs (we’ll cover this in the practical)"
  },
  {
    "objectID": "04/week_04_slides.html#practical",
    "href": "04/week_04_slides.html#practical",
    "title": "Introduction to Coding and Data Analysis for Scientists",
    "section": "Practical",
    "text": "Practical\n\nWe now move over to Python\nPlease open week_04_home.ipynb\nFor the rest of today, you must work through a Python notebook\nYou have a choice of one of three options\n\nOption 1: Beginner - Defining Functions\nOption 2: Intermediate - Flexible Inputs and Outputs\nOption 3: Advanced - Lambda Functions and Functional Programming"
  },
  {
    "objectID": "04/week_04_solutions_demonstrator_version.html",
    "href": "04/week_04_solutions_demonstrator_version.html",
    "title": "Functions : Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 4 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "04/week_04_solutions_demonstrator_version.html#beginner-defining-functions",
    "href": "04/week_04_solutions_demonstrator_version.html#beginner-defining-functions",
    "title": "Functions : Solutions",
    "section": "Beginner: Defining Functions",
    "text": "Beginner: Defining Functions\nQuestion 1: Running the code gives the following output.\n3 4\n4 3\n2 4\n2 1\n3 1\nIn the first line, the inputs are assigned according to the order they were read in, so that x=3 and y=4. In the second line, they are assigned according to the keyword/variable names given, so that x=4 and y=3. In the third line, x takes the default value of 2 whilst y=4. In the fourth line, both default values x=2 and y=1 are used. And in the final line, y takes the default value of 1 while x=3.\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to get students thinking about how inputs are entered into functions. Please try to prevent students from running the code before they have attempted to answer the question, as the goal is for them to reason it out first.\n\nQuestion 2: An answer to this question is provided below.\n\n\n\n\n\n\n\nDemonstrator Notes: A useful sanity check for this question is to ask students whether their function works correctly on strings that include punctuation. An easy, and subtle, mistake to make here is to write if ch == ch.upper(): instead of if ch != ch.lower():. The difference matters because for non-alphabetic characters (like punctuation), ch.upper() and ch.lower() are both equal to ch itself.\n\nQuestion 3: The functions for this question are given below.\n\n\n\n\n\n\n\nDemonstrator Notes: Please be mindful that many students may not have studied Physics for several years, so might be uncomfortable with the terms kinetic energy and potential energy. Make sure the student is comfortable with the context of the question before moving into the coding explanation.\n\nQuestion 4: A sample answer for this question is given below:\n\n\n\n\n\n\n\n\n\n\n\n\n\nDemonstrator Notes: For many students, this may be their first exposure to the import and from keywords, as well as the os package. They also won’t have encountered plotting yet. If students ask about these topics, you’re welcome to give a brief explanation if you like, but it’s also fine to tell them that these will be covered in detail later in the course if it is easier.\n\nQuestion 5: The time() function gives the number of seconds passed since epoch (the point where time begins, e.g. January 1, 1970, 00:00:00 UTC is epoch on unix systems). Some suggested code to show students for this question is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: See notes on Question 4.\n\nQuestion 6: An example answer for this question is given below.\n\n\n\n\n\n\n\nDemonstrator Notes: It is expected that many students will have forgotten the split function from week 1. Please encourage them to look up documentation where possible, rather than giving the answer directly.\n\nQuestion 7: If you write a function which redefines a global variable, then inside the function, Python makes a new local variable x when you assign x = 20. That local version is separate from the global version x = 10. So inside you see 20, and outside you still see 10.\n\nDemonstrator Advice: One way of explaining what is going on here is to show students the following code, where we have replaced the calls to x outside the function with x_outer and the code inside the function with x_inner.\n\n\n\n\n\n\n\n\nIn this code it is pretty easy to predict what will be printed. Because the variables have different names, there is no ambiguity. Behind the scenes, this renaming is exactly what Python is doing when you redefine a global variable inside a function.\nHowever, it must be stressed that this will only happen when you redefine the variable (e.g. write x=...) somewhere inside the function. For instance, if we comment out the x=20 line from the original code, then the function will treat x as though it is x_outer, not x_inner!\n\n\n\n\n\n\n\nQuestion 8: Here is an example answer for this question.\n\n\n\n\n\n\n\nDemonstrator Notes: This question is hard, and will be fairly challenging for most students. Please feel free to give them a bit more guidance when answering this one - one good place to start might be to have them compute the \\(n^{th}\\) Fibonnaci number from the \\((n-1)^{th}\\) and \\((n-2)^{th}\\) Fibonacci numbers.\nIt probably isn’t a good idea to discuss code efficiency/making the code faster at this stage of the course. This question will already pose a large conceptual challenge for many students, and showing them how to rewrite the code to improve it further might feel like an extra layer of complexity. (The above code certainly isn’t the most efficient!).\n\nQuestion 9: Example code for this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is difficult and will need more guidance for many students. It is expected that many students will not think to use the str constructor to convert their numerical data into a string and many will not think to loop through the characters of string, treating it as an iterator (e.g. many may not think to write code of the form for character in my_string:). Beyond these syntax hints, try to encourage students who are struggling to first write how they would perform the computation by hand on paper, before they start coding. This is often a good starting point for explaining the logic and working out what they understand of the question.\n\nQuestion 10: Code for this question can be found below\n\n\n\n\n\n\n\nDemonstrator Notes: This question should be a little easier than the previous, but please do check that students are actually using the function from the previous question, rather than rewriting the code from scratch, or copy-pasting large chunks."
  },
  {
    "objectID": "04/week_04_solutions_demonstrator_version.html#intermediate-flexible-inputs-and-outputs",
    "href": "04/week_04_solutions_demonstrator_version.html#intermediate-flexible-inputs-and-outputs",
    "title": "Functions : Solutions",
    "section": "Intermediate: Flexible Inputs and Outputs",
    "text": "Intermediate: Flexible Inputs and Outputs\nQuestion 1: The output of the function calls are as follows:\na: 1\nb: 2\nargs: ()\nkwargs: {}\n---------------\na: 1\nb: 2\nargs: (3, 4)\nkwargs: {}\n---------------\na: 1\nb: 2\nargs: ()\nkwargs: {'x': 10, 'y': 20}\n---------------\na: 1\nb: 2\nargs: (3, 4)\nkwargs: {'x': 10, 'y': 20}\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to build on the intuition students have built through the Arbitrary Positional and Keyword Arguments section of the notebook. Please encourage students to attempt the question before running the code to check their answer. If students are struggling with the conceptual aspects of this question, please do try to refer back to the notebook section where possible.\nWhen discussing the answers to this question, it is worth highlighting that, when we pass no arguments to *args and **kwargs, this is the same as passing in an empty list, (), or empty dictionary, {}, rather than passing no variables at all. This is a good discussion point - asking students why they think this is can help you to check their understanding of *args and **kwargs.\n\nQuestion 2: An example answer for this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is fairly straightforward. We are not expecting answers that are any more complex/streamlined than the above (although students are certainly welcome to try). Given the week 2 intermediate notebook, some students may use a match statement instead of an if-elif-else. This is perfectly fine as well.\n\nQuestion 3: The expected output for this question is:\nHere is another print statement.\n----------------------------\n----------------------------\nHere is a print statement.\n----------------------------\nHere is a print statement.\n----------------------------\n\n\n\n\n\n\n\nDemonstrator Notes: This question is mainly to test the students logic and understanding of how Python handles functions with multiple return statements. A good case to focus on is the case a==0. Useful questions to ask students here include:\n- Why do you think nothing is printed when a==0? - Will print('Here is another print statement.') be printed when a==0? - Will 0 or -1 be returned when a==0?\n\nQuestion 4: The code returns True if the integer is prime and False otherwise. The answers to the listed questions are as follows:\n\nWhat values of i will the loop check?\n\nIt will check all values between 2 and my_integer-1, inclusive. Given no prior knowledge, these are the values which could possibly be factors of my_integer.\n\nWhat does the expression my_integer % i mean?\n\nThis is the modulo operator, which we met in the Week 1 Beginner notebook. It gives the remainder obtained from dividing my_integer by i. If this expression equals zero, then my_integer is divisible by i (i.e. i is a factor of my_integer).\n\nUnder what condition does the function return False?\n\nThe function returns False whenever we find an integer i (lying between 2 and my_integer-1) that is a factor of my_integer. In other words, it returns False when my_integer has a factor, that is when my_integer is not prime.\n\nDemonstrator Notes: The aim of this question is to get students thinking about how return statements can be used to end loops prematurely, a bit like a break statement. They will have met the break statement in the Week 3 intermediate notebook, but might not realise the connection here. When explaining the logic of this question, feel free to reference break statements to highlight the similarity, but make sure to point out that return not only stops the loop but also exits the entire function immediately.\nThis question is also a good opportunity to get students to think about debugging code. It is expected that, when asked to work out what the code is doing, many students will try to dissect the code conceptually from first principles without running it. If you see students attempting to do this and struggling, encourage them to adopt a more pratical approach - e.g. suggest that they run the function for several different values of my_integer and see if they can guess the function’s behaviour from the output.\n\nQuestion 5: The another_mystery_function function takes in a string and reverses the order of the letters. The same thing can be done using, for example, the below loop:\n\n\n\n\n\n\n\nDemonstrator Notes: Recursive functions can be difficult to explain on the spot. If a student asks for help, then by all means, feel free to go through step-by-step explaining what the code is doing if you feel you are able. However, if you do not feel confident doing this, you can instead encourage the student to identify the code’s function by looking at various inputs and outputs and “spotting the pattern”. The latter is still a good exercise in debugging code and a worthwhile use of the student’s time."
  },
  {
    "objectID": "04/week_04_solutions_demonstrator_version.html#advanced-lambda-functions-and-functional-programming",
    "href": "04/week_04_solutions_demonstrator_version.html#advanced-lambda-functions-and-functional-programming",
    "title": "Functions : Solutions",
    "section": "Advanced: Lambda Functions and Functional Programming",
    "text": "Advanced: Lambda Functions and Functional Programming\nQuestion 1: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: It might be useful to break this question down into the following steps: 1. Write a (normal) function which checks if a string has between three and eight characters. If it does, the function should return True, otherwise it should return False. 1. Try to condense this function to only take up a few lines. 1. Convert this function to a lambda function. 1. Insert this lambda function into a filter expression.\nNote it is easy to forget that the end result must be converted back to a list - it is very likely that at least some students will forget to do this and be confused by the object returned by the filter function.\n\nQuestion 2: Example code for this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: As with Question 1, it might be useful to break this question down into the following steps: 1. Write a (normal) function which returns the value of \"name\" from a dictionary. 1. Convert this function to a lambda function. 1. Insert this lambda function into a map expression.\nAgain, it is easy to forget that the end result must be converted back to a list - it is very likely that at least some students will forget to do this and be confused by the object returned by the map function.\n\nQuestion 3: An example answer is provided below.\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to give students practice writing higher-order functions and treating functions themselves as objects. Student’s will likely need reminding that they can write ^ for exclusive or, as they have only briefly seen this operation in the week 1 beginner notebook. It is perfectly fine, and also a good exercise, to have them instead write out f(x) ^ g(x) as (f(x) and not g(x)) or (g(x) and not f(x)) (it may also help to draw a Venn diagram for students who want to adopt this approach).\n\nQuestion 4: The reduce expression here is performing function composition and the new function is being evaluated with 5 as input. In other words, if the expression is given a list of function \\([f_1,...,f_n]\\) then the output will be \\((f_1 \\circ f_2 \\circ ... \\circ f_n)(5)=f_1(f_2(...f_n(5)...))\\).\n\nDemonstrator Notes: For less mathematical students, avoid the phrase “composition”. Instead, explain the idea in plain English. For example: “First, take the last function in the list and run it with the input 5. Then take the result you get and plug it into the second-to-last function. Keep going like this, working backwards through the list.”\n\nQuestion 5: This function computes the maximum value in a list. Behind the scenes, it is doing the following:\n\nIt first takes the first two elements, 3 and 1, and applies the lambda function which returns the maximum of the two.\nNext, it takes the result of the first step, in this case 3, and the next element in the list 4. Again it applies the lambda function which returns the maximum of the two.\nIt then repeats this process, each time comparing the current result with the next element of the list, and choosing the maximum of the two, until there are no elements left.\nThe final value produced is the largest value in the list.\n\nAnother way of thinking about it is as doing the following:\n\n\n\n\n\n\n\nDemonstrator Notes: Although it might not seem like it on first viewing, this example is designed to be extremely similar to the example given in the reduce section of the notebook. If students are struggling with this, please direct them to this section first."
  },
  {
    "objectID": "04/week_04_home.html",
    "href": "04/week_04_home.html",
    "title": "Functions",
    "section": "",
    "text": "Welcome back to the fourth week of the SCIF10002 course. This week we shall be looking at functions!",
    "crumbs": [
      "Home",
      "04 Functions",
      "Functions"
    ]
  },
  {
    "objectID": "04/week_04_home.html#todays-material",
    "href": "04/week_04_home.html#todays-material",
    "title": "Functions",
    "section": "Today’s Material",
    "text": "Today’s Material\nIn this week’s class, you should start to notice how the core skills we’ve been building over the past few weeks begin to come together. Our focus will be on organizing code into well-structured, clearly delineated blocks called functions. As in the previous two classes, this week you have a choice of working through one of three notebooks.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\nOption 1: Beginner\nIf you are not very familiar with functions in Python, or would like some practice, today you should work through the Defining Functions notebook below:\n\nBeginner: Defining Functions\n\nThis notebook introduces what functions are and shows you how to create them in Python. Be sure to read the explanations carefully and try each exercise along the way!\n\n\nOption 2: Intermediate\nThis week’s intermediate notebook is intended only for those who are already confident with the material in the beginner notebook. lease ensure that you are able to complete the exercises in the beginner notebook before attempting this option. The intermediate material for this week is given below:\n\nIntermediate: Flexible Inputs and Outputs\n\nThis notebook will build on your understanding of functions by introducing positional-only and keyword-only arguments, the use of arbitrary arguments, functions with multiple return values, and the concept of a recursive function.\n\n\nOption 3: Advanced\nIf you already have solid experience with Python programming, start by reviewing the exercises in the following notebooks to confirm that you’re fully comfortable with the fundamentals:\n\nBeginner: Defining Functions\n\nIntermediate: Flexible Inputs and Outputs\n\nOnce you feel confident with these concepts, proceed to the advanced material:\n\nAdvanced: Lambda Functions and Functional Programming\n\nIn this notebook, you’ll be introduced to the lambda operator and the idea of a higher-order function - a function that takes other functions as input. You will then explore three widely used higher-order functions: map, filter, and reduce. These functions are especially useful when it comes to writing clear and concise code.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Functions"
    ]
  },
  {
    "objectID": "04/week_04_home.html#getting-help",
    "href": "04/week_04_home.html#getting-help",
    "title": "Functions",
    "section": "Getting Help",
    "text": "Getting Help\nThere is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\n\n\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "04 Functions",
      "Functions"
    ]
  },
  {
    "objectID": "snippets.html",
    "href": "snippets.html",
    "title": "To force rendering in pyodide",
    "section": "",
    "text": "Add the following to quarto\n\n\n\n\n\n\nremember to add\n\nresources:\n    - src"
  },
  {
    "objectID": "05/week_05_solutions.html",
    "href": "05/week_05_solutions.html",
    "title": "Week 5: Solutions",
    "section": "",
    "text": "This notebook presents solutions to the Week 5 challenges in Data Science, Physics and Chemistry. Unlike previous weeks, these challenges are designed to be more open-ended, so the answers provided below are intended only as examples. There are many ways to approach these questions, and it is not our intention to suggest that the given answers are the “best” approaches, or that a “best” approach even exists."
  },
  {
    "objectID": "05/week_05_solutions.html#challenge-1-data-science",
    "href": "05/week_05_solutions.html#challenge-1-data-science",
    "title": "Week 5: Solutions",
    "section": "Challenge 1: Data Science",
    "text": "Challenge 1: Data Science\nTo run the solutions for this challenge, you will first need to run the below import statement.\n\n\n\n\n\n\nTask 1: Getting Started. Code for this task can be found below:\n\n\n\n\n\n\nTask 2: Sensing Danger. Here is an answer to this problem:\n\n\n\n\n\n\nTask 3: End of the Road. The below code provides a solution to this question.\n\n\n\n\n\n\nTask 4: Turning Back. Below is an example solution for this question.\n\n\n\n\n\n\nTask 5: Final Challenge. There are plenty of solutions to this task. Here is just one example:"
  },
  {
    "objectID": "05/week_05_solutions.html#challenge-2-physics",
    "href": "05/week_05_solutions.html#challenge-2-physics",
    "title": "Week 5: Solutions",
    "section": "Challenge 2: Physics",
    "text": "Challenge 2: Physics\nThis code will load in the challenge data.\n\n\n\n\n\n\nTask 1: Clean the Data. Below is an example solution for part (1) of the Physics challenge.\n\n\n\n\n\n\nTask 2: Detect When Each Bar Begins to Block the Beam. Solution code for part (1) of the Physics challenge is given below.\n\n\n\n\n\n\nTask 3: Estimate Average Velocities. Example code for this question is given below.\n\n\n\n\n\n\nTask 4: Estimate Accelerations. An answer to this question is provided below.\n\n\n\n\n\n\nTask 5: Estimate \\(g\\). The below code computes the within-trial averages of the acceleration.\n\n\n\n\n\n\nThe following code averages acceleration across trials."
  },
  {
    "objectID": "05/week_05_solutions.html#challenge-3-chemistry",
    "href": "05/week_05_solutions.html#challenge-3-chemistry",
    "title": "Week 5: Solutions",
    "section": "Challenge 3: Chemistry",
    "text": "Challenge 3: Chemistry\nTo run the solutions for this challenge you must first run the below code.\n\n\n\n\n\n\nTask 1: Verifying Elements. Here is an example solution to this problem.\n\n\n\n\n\n\nTask 2: Verifying the Atomic Number. Here is an example answer to task 2.\n\n\n\n\n\n\nTask 3: Counting Electrons, Protons and Neutrons. Here is some example code for task 3:\n\n\n\n\n\n\nTask 4: Group and Period. Example code for this task is given below.\n\n\n\n\n\n\nTask 5: Isotope Names. An example solution for this is given below:\n\n\n\n\n\n\nTask 6: Categorizing Isotopes. Here is an example solution to this task."
  },
  {
    "objectID": "05/week_05_data_science_quarto.html",
    "href": "05/week_05_data_science_quarto.html",
    "title": "",
    "section": "",
    "text": "Code",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Data Science Challenge"
    ]
  },
  {
    "objectID": "05/week_05_data_science_quarto.html#data-science-challenge",
    "href": "05/week_05_data_science_quarto.html#data-science-challenge",
    "title": "",
    "section": "Data Science Challenge",
    "text": "Data Science Challenge\nThis week we are consolidating the skills we have learned over the past four weeks in order to tackle a practical challenge. In this notebook, you will find the data science challenge, in which you will have to write code that will navigate a small virtual robot around a maze.\n\nPlease Note: These challenges are designed to difficult! Do not worry if you are unable to complete a challenge in the time given. The important thing is that you are building resilience and practicing problem-solving skills - everything else is secondary!\n\nYou’re currently viewing the Quarto version of the Data Science Challenge notebook. Please note that, due to differences in how Quarto and Jupyter render outputs, some functions may behave slightly differently or run more slowly. You’re welcome to use this version for today’s material, but we strongly recommend using the version on Jupyter if possible.\n\nTable of Contents\n\nWelcome Page\nChallenge 1: Data Science\nPreliminaries\nTutorial: The Robot Maze\n\nCreating a Robot Maze\nMoving the Robot\nResetting and Saving the Maze\nAims and Limits\n\nChallenges\n\nTask 1: Getting Started\nTask 2: Sensing Danger\nTask 3: End of the Road\nTask 4: Turning Back\nTask 5: Final Challenge\n\nChallenge 2: Physics\nChallenge 3: Chemistry\nSlides (Powerpoint)",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Data Science Challenge"
    ]
  },
  {
    "objectID": "05/week_05_data_science_quarto.html#preliminaries",
    "href": "05/week_05_data_science_quarto.html#preliminaries",
    "title": "",
    "section": "Preliminaries",
    "text": "Preliminaries\nThis notebook draws on the knowledge you’ve built over the last four weeks. This challenge assumes knowledge of only the material from the beginner notebooks - however, you are welcome to draw upon material from the intermediate and advanced notebooks as well! The tasks are designed to be accessible to everyone.\nBefore getting started, you’ll need to know how to generate random numbers. Here’s a quick primer.\nTo load in a package (collection of functions) that will let you generate random numbers, you must run the below code:\n\n\n\n\n\n\nYou only need to run the above line of code once (unless you restart the notebook, in which case you will have to run it again after restarting). Once you have run the import code you will be able to generate random numbers using the random.random() and random.randint() functions like so:\n\n\n\n\n\n\nTry running the above box a few times and observe how a new value is produced each time you call random or randint. For today’s class, this is all the knowledge we will need concerning random numbers in Python. We’ll explore random number generation in greater depth later on in the course.",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Data Science Challenge"
    ]
  },
  {
    "objectID": "05/week_05_data_science_quarto.html#tutorial-the-robot-maze",
    "href": "05/week_05_data_science_quarto.html#tutorial-the-robot-maze",
    "title": "",
    "section": "Tutorial: The Robot Maze",
    "text": "Tutorial: The Robot Maze\nToday, you will be programming a robot to navigate a small maze. To get started, run the code box below. This will load in the RobotMaze function which we will be working with today.\n\n\n\n\n\n\n\nCreating a Robot Maze\nThe RobotMaze function will create a new randomly generated maze with a robot inside it. Try running the below code:\n\n\n\n\n\n\nWe can view the robot in the maze using robot.render().\n\n\n\n\n\n\nLet’s break down what we can see here. The maze contains:\n\nWhite Squares: Open spaces, which the robot has not yet visited.\nBlack squares: Walls. The robot cannot walk into these.\nGrey squares: These are open spaces that the robot has visited previously.\nA red circle with a white arrow: This is the robot. The arrow tells us which way it is facing.\nA green circle with a T: This is the target. This is where the robot must move to.\n\nAt the top of the maze, we see the title Robot Maze - Run #1. Here, the number #1 refers to the number of times we have attempted to solve the maze.\nAt the bottom of the maze, we see the Robot Console. This is a handy message box, which we shall use to display messages from the robot throughout this task.\n\n\nMoving the Robot\nHere are some instructions you can give the robot:\n\nrobot.move(): Running this will cause the robot to take one step forward in the direction it is currently facing.\nrobot.turn(): This function takes a string as input. It will turn the robot to the left if the string is \"LEFT\", right if the string is \"RIGHT\", behind if the string is \"BEHIND\" and ahead if the string is \"AHEAD\". The robot always turns relative to the direction it is currently facing (that is, where the white arrow is pointing).\n\nRunning the below code will give the robot the instructions.\n\n\n\n\n\n\nThe robot now knows what it is going to do. To execute the instructions, you must now run robot.render().\n\n\n\n\n\n\n\nNote: If the robot bumps into a wall, it will not move forward. Instead, it will print a message to the Robot Console telling you it has bumped into a wall.\n\nIf the robot is moving too fast or slow, you can change the speed at which it moves using the robot.delay parameter. For instance:\n\n\n\n\n\n\n\nNote: Each time you run robot.render(), the robot will begin moving from it’s last location on the previous render. Try re-running the above box a few times (maybe with a smaller delay!) to make sure you understand how this works.\n\n\n\nResetting and Saving the Maze\nIf you want to reset the maze, and send the robot back to the start, you can use the robot.reset() command like so. Notice that the title will now say Robot Maze - Run #2, but the Robot Console will keep the robot’s message history.\n\n\n\n\n\n\nEvery time you run the robot = RobotMaze(), a new random maze is generated. Sometimes you might want to save a particular maze to come back to later. You can do this by running robot.get_maze_id(). For instance, to save the maze you have above, you can run the following:\n\n\n\n\n\n\nYou can then load the same maze again later on using my_maze_id. Try commenting out and uncommenting the below lines of code to test your understanding.\n\n\n\n\n\n\n\nRecall: You can interrupt a cell that is running in Quarto by pressing the Start Over button.\n\n\n\nAims and Limits\nYour aim in this challenge to write code that moves the robot to the target. However, there is a catch - the robot only has a finite amount of fuel!\nThe robot begins with 100 units of fuel. Each call to robot.move() and robot.turn() costs one unit of fuel. Once the robot has no fuel left, it will not be able to move.\nHere are some functions you can use to check on the robot’s status:\n\nrobot.at_target(): This will return True if the robot is on the target square and False otherwise.\nrobot.check_fuel(): This will tell you how much fuel the robot has left. The amount will be returned as an integer between 0 and 100.\nrobot.print(): This will print a message to the robot console.\n\nThe below code uses the above commands. See if you can understand what it is doing.\n\n\n\n\n\n\nFinally, the robot is equipped with a sensor that can detect what type of square is in a given direction.\nTo use the sensor, call the robot.sense() function with one of the following inputs: \"AHEAD\", \"LEFT\", \"RIGHT\", or \"BEHIND\". The function returns a string describing the square in that direction, returning either \"WALL\", \"EMPTY\", or \"BEEN_THERE\" if the robot has already visited it.\nHave a look at the below code for an example:\n\n\n\n\n\n\n\nNote: Using the sensor does not require fuel! That is, it may be better to sense before you move…",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Data Science Challenge"
    ]
  },
  {
    "objectID": "05/week_05_data_science_quarto.html#challenges",
    "href": "05/week_05_data_science_quarto.html#challenges",
    "title": "",
    "section": "Challenges",
    "text": "Challenges\nWe’re now ready to get to grips with the robot environment!\n\nTask 1: Getting Started\nThe below code will load a simple four by four RobotMaze.\n\n\n\n\n\n\nIn the below box, use the robot.move() and robot.turn() functions to navigate the robot to the target.\n\n\n\n\n\n\nTry to write your code as concisely as possible.\nHint: You may want to use for loops like we did in the example in the Aims and Limits section.\n\n\nTask 2: Sensing Danger\nWe’re now going to look at a pre-written robot maze program. In the below code box, you will see there is a function named my_controller. See if you can determine what this controller does before reading ahead.\n\n\n\n\n\n\nThe nice thing about writing our commands for the robot inside a function is that we can now run the entire set of instructions simply by calling the function, like so:\n\n\n\n\n\n\nTry updating the my_controller function so that the robot first checks for a wall in front of it before attempting to move forward. If a wall is detected, the robot should stay in place and not move.\n\n\n\n\n\n\n\n\nTask 3: End of the Road\nContinuing with the my_controller function, modify your code to identify if the robot is:\n\nAt a dead-end (a square surrounded by three walls),\nAt a corner (a square bordering two walls whose corners touch),\nIn a corridor (a square with two walls bordering it on opposing sides),\nNext to a single wall (a square with only one wall bordering it),\nOn an unbordered square (a square sharing no edges with a wall).\n\nUse the robot.print() function to print a message to the console stating which type of square the robot is on.\n\n\n\n\n\n\n\n\nTask 4: Turning Back\nWrite your own controller function which does the following: - Senses the squares around the robot. - If there at least one of the surrounding squares is \"EMPTY\", the robot should choose an \"EMPTY\" square at random and move to it. - If there are no \"EMPTY\" squares, the robot should choose at random from the \"BEEN_THERE\" squares surrounding it and move to the chosen square.\n\n\n\n\n\n\n\n\nTask 5: Final Challenge\nIt is now up to you!\nBy doing your own research on maze solving algorithms, choose a method to solve the maze and try writing it up as a controller function. Can you solve the maze faster than the my_controller robot, or your solution to Task 4?\nGood luck!",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Data Science Challenge"
    ]
  },
  {
    "objectID": "05/week_05_home.html",
    "href": "05/week_05_home.html",
    "title": "Consolidation",
    "section": "",
    "text": "We’ve now reached the fifth week of SCIF10002!\nThis marks the end of the basics section of the course. Over the next few weeks, we’ll begin shifting our focus away from Python’s built-in features and towards powerful external packages, such as numpy, matplotlib and pandas, that will no doubt be invaluable in your future studies and professional work.\nTo wrap up this section of the course, we will apply the skills we’ve learned so far to a set of applied challenges. This will give you an opportunity to consolidate your understanding and get a feel for the kinds of coding tasks you may encounter beyond the classroom.",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Consolidation"
    ]
  },
  {
    "objectID": "05/week_05_home.html#todays-material",
    "href": "05/week_05_home.html#todays-material",
    "title": "Consolidation",
    "section": "Today’s Material",
    "text": "Today’s Material\nFor this week’s class, we’ll be doing something a little different from previous weeks.\nBelow, you’ll find three challenges. The challenges are organised by course; data science, chemistry and physics.\n\nChallenge 1: Data Science\nChallenge 2: Physics\nChallenge 3: Chemistry\n\nYour goal is to attempt at least one challenge. Once you have read the Guidance section below, try the challenge for your own course. If you manage to finish the challenge for your course, move onto the challenges for the other courses. None of the challenge notebooks assume course-specific background knowledge.\n\nImportant: For this task, you may only use material covered in the previous 4 week’s classes. To solve the challenge problems, you may use any content from the beginner, intermediate, or advanced notebooks. However, every challenge can be completed using only the material in the beginner notebooks, so don’t worry if you haven’t looked at the others. The tasks are designed to be accessible to everyone!\n\nPlease Note: These challenges are designed to difficult! Do not worry if you are unable to complete a challenge in the time given. The important thing is that you are building resilience and practicing problem-solving skills - everything else is secondary!",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Consolidation"
    ]
  },
  {
    "objectID": "05/week_05_home.html#guidance",
    "href": "05/week_05_home.html#guidance",
    "title": "Consolidation",
    "section": "Guidance",
    "text": "Guidance\nYou will find that the challenge problems this week are much more open-ended than those you have encountered in previous classes. At first, this might feel a bit intimidating, but please do not fret - you already have all the skills necessary to complete the tasks!\nHere are some general tips to help make the challenges feel less daunting:\n\nPlan before you code: Before writing any code, try taking notes about the background material. Once you understand the background material, think about how you might approach the task by hand, and jot the steps you would perform down on paper.\n\n\nClarify inputs and outputs: When getting started, think about the following questions: - What information do I have before I start coding? (These are likely my inputs.) - What do I want my code to produce? (This is my output.)\n\n\nLook for structure and repetition: When converting your thoughts to code, consider the below: - Which steps of the computation are repetitive? (Think loops!) - Which steps of the computation are self-contained? (Perhaps, I should use a function for these…)\n\n\nDivide and conquer: Try to break the task down into smaller, more manageable chunks, and solve each piece one at a time before putting them together.\n\n\nTalk things through: If you’re struggling to get started, try talking the question through with a peer or class tutor. You might be surprised how much this helps to organise your thoughts!\n\n\nUse resources: Don’t be afraid to use google or Python documentation when you’re thinking about the best way to implement a solution. Sometimes the act of googling alone can help spark new ideas.\n\n\nTrust your own process: Try to avoid using AI when deciding how to structure your code. You will find it much easier to understand and refine your work if the structure comes from your own reasoning.\n\nAbove all, remember that coding can be hard! At times, it might feel like you’re running into the same problem over and over without making much progress. If you feel this way, don’t worry - this is a perfectly normal part of the process. If you keep trying, you will get there!",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Consolidation"
    ]
  },
  {
    "objectID": "05/week_05_home.html#getting-help",
    "href": "05/week_05_home.html#getting-help",
    "title": "Consolidation",
    "section": "Getting Help",
    "text": "Getting Help\nAs always, to get more help you can view the Python API or the W3 schools series on Python. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\n\n\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Consolidation"
    ]
  },
  {
    "objectID": "05/week_05_physics.html",
    "href": "05/week_05_physics.html",
    "title": "",
    "section": "",
    "text": "Code",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Physics Challenge"
    ]
  },
  {
    "objectID": "05/week_05_physics.html#physics-challenge",
    "href": "05/week_05_physics.html#physics-challenge",
    "title": "",
    "section": "Physics Challenge",
    "text": "Physics Challenge\nThis week, we’ll bring together the skills you’ve developed over the past four weeks to tackle a practical challenge. In this notebook, you’ll find a Physics coding challenge. This challenge is designed to consolidate your recent Python learning and give you practice working with strings, loops, and dictionaries.\n\nPlease Note: These challenges are designed to difficult! Do not worry if you are unable to complete a challenge in the time given. The important thing is that you are building resilience and practicing problem-solving skills - everything else is secondary!\n\n\nTable of Contents\n\nWelcome Page\nChallenge 1: Data Science\nChallenge 2: Physics\n\nBackground\n\nMeasuring Gravity with a Picket Fence and Photogate\nThe Data\n\nThe Challenge\n\nTask 1: Clean the Data\nTask 2: Detect When Each Bar Begins to Block the Beam\nTask 3: Estimate Average Velocities\nTask 4: Estimate Accelerations\nTask 5: Estimate \\(g\\)\n\n\nChallenge 3: Chemistry\nSlides (Powerpoint)",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Physics Challenge"
    ]
  },
  {
    "objectID": "05/week_05_physics.html#background",
    "href": "05/week_05_physics.html#background",
    "title": "",
    "section": "Background",
    "text": "Background\n\nMeasuring Gravity with a Picket Fence and Photogate\nA classic experiment in introductory physics is the photogate picket fence experiment. In this setup, a picket fence (a clear plastic strip with evenly spaced opaque bars) is dropped vertically through a photogate sensor.\n\nThe photogate shines an infrared beam across a small gap. A sensor on the other side detects whether the beam makes it through or not. If the beam is blocked (by one of the bars), the sensor records 'x'. If the beam is not blocked, the sensor records 'o'. Every \\(\\Delta t = 0.5\\) milliseconds (\\(=0.0005s\\)) the photogate logs whether the beam is blocked or not.\nBecause the bars on the picket fence are evenly spaced, the vertical distance between the start of one bar and the start of the next is always the same:\n\\[\n\\Delta d = 5 \\text{cm (constant distance between bars).}\n\\]\nAs the picket fence falls through the photogate, each bar successively blocks the beam. By measuring the time between when one bar starts blocking the beam and when the next bar does, we can estimate the velocity of the falling object. From changes in velocity, we can then estimate the acceleration due to gravity.\n\n\nThe Data\n\nNote: Before starting this challenge, if you haven’t already, you may wish to read the sections on dictionaries in the week 1 intermediate notebook. This will be helpful in what follows.\n\nYou are given a Python dictionary that encodes \\(100\\) trials of the photogate picket fence experiment. Each entry:\n\nHas a key like \"Trial 1\", \"Trial 2\", …\nHas a value that is a long string of 'o', 'x', and 'e' characters, representing the sensor state at regular time intervals (recordings are taken \\(\\Delta t\\) seconds apart). We can interpret these as follows:\n\n'x' = beam blocked (bar in photogate)\n'o' = beam unblocked (gap)\n'e' = error (the sensor glitched)\n\n\nFor example, suppose the dictionary contains the entry:\ndata_dict[\"Trial 1\"] = \"oooxxxoooxexo\"\nThis string represents the sensor readings for the first trial. Each character corresponds to a single timepoint, spaced by \\(\\Delta t = 0.0005\\) s. We can interpret this as follows:\n\nThe first three characters (\"ooo\") mean the beam was unblocked at times \\(t = 0 \\text{ms}\\), \\(5 \\text{ms}\\), and \\(10 \\text{ms}\\),\nThe next three characters (\"xxx\") indicate the beam was blocked at \\(t = 15 \\text{ms}\\), \\(20 \\text{ms}\\), and \\(25 \\text{ms}\\),\nThe next three (\"ooo\") show the beam was unblocked again,\nAt \\(t = 50 \\text{ms}\\), the character is 'e', indicating that the sensor glitched,\nThis is followed by 'x' and 'o' at the final two timepoints.\n\nNote: Across the \\(100\\) trials, several different picket fences were used. Some had the same number of bars, while others did not. Consequently, the number of black and white bars varied between trials.",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Physics Challenge"
    ]
  },
  {
    "objectID": "05/week_05_physics.html#the-challenge",
    "href": "05/week_05_physics.html#the-challenge",
    "title": "",
    "section": "The Challenge",
    "text": "The Challenge\nYour challenge is to perform the following tasks:\n\nTask 1: Clean the Data\nMany trials contain one or more 'e' (error) characters due to sensor glitches. Apply the following rules to clean each string:\n\nIf an 'e' (or group of 'e's) is adjacent to at least one 'x', replace all 'e's in that group with 'x',\nOtherwise, replace them with 'o'.\n\nFor example, 'ooxexoeoxeeo' would become 'ooxxxoooxxxo'.\n\n\n\n\n\n\n\n\nTask 2: Detect When Each Bar Begins to Block the Beam\nOnce the data is cleaned, your next task is to identify the exact times at which each bar starts to block the photogate beam.\nThis occurs every time the sensor reading transitions from 'o' (unblocked) to 'x' (blocked). Each from 'o' to 'x' transition corresponds to the leading edge of a bar entering the photogate.\nTo detect these moments:\n\nLoop through the cleaned string from left to right.\nLook for every index i where the character is 'x', and the character just before it (at index i-1) is 'o'.\nFor each such index, compute the time \\(t = i × Δt\\), where \\(\\Delta t =\\) 0.5 milliseconds.\n\nFor each trial, you must save a list of timestamps (in seconds) showing when each bar starts to block the beam. For instance, given this cleaned string:\n\"oooxxxoooxxxooooxxx\"\nYou should detect transitions at indices: 3, 9, and 16 (remember, Python starts counting at 0!). In this case, the corresponding times would be:\n[0.0015, 0.0045, 0.0080] # Computed by doing [3*0.0005,9*0.0005,16*0.0005]\n\n\n\n\n\n\n\n\nTask 3: Estimate Average Velocities\nOnce you’ve computed the times when each bar starts to block the beam, you can use those times to estimate the velocity of the falling picket fence.\nFrom the previous, we have;\n\n\\(\\Delta d = 0.05\\) meters is the constant distance between the leading edges of two consecutive bars.\n\\(t_k\\) and \\(t_{k+1}\\) are the times at which two consecutive bars start to block the beam.\n\nWe can now estimate the average velocity of the picket fence between two successive bar detections using:\n\\[\nv_k = \\frac{\\Delta d}{t_{k+1} - t_k}\n\\]\nThis gives the average velocity of the picket fence between the times \\(t_k\\) (when the \\(k^{th}\\) bar first blocks the sensor) and \\(t_{k+1}\\) (when the \\((k+1)^{th}\\) bar does the same).\nFor each trial, you must now use your list of bar-blocking times to compute a list of velocities between each pair of consecutive bars. For instance, if the bar-blocking times for a single trial are:\n[0.0015, 0.0045, 0.0080]\nThen you must compute the velocities:\n\\[v_0= \\frac{0.05}{0.0045-0.0015} = 16.66...\\quad\\text{and}\\quad v_1= \\frac{0.05}{0.0080-0.0045} = 14.28...\\]\n\n\n\n\n\n\n\n\nTask 4: Estimate Accelerations\nNow that you’ve estimated velocities, you can use them to estimate how the instantaneous velocity of the picket fence changes over time - that is, its acceleration.\nIn step 3, each velocity \\(v_k\\) was calculated as an average over a time interval of the form \\([t_k,t_{k+1}]\\). We can treat this as a velocity recorded at the midpoint of the interval. That is, we treat this velocity as though it were recorded at the time \\(\\tau_k\\), defined as:\n\\[\n\\tau_k := \\frac{t_k + t_{k+1}}{2}\n\\]\nTo estimate the acceleration between two consecutive velocities, we need to look at their differences. That is, we must compute:\n\\[\na_k = \\frac{v_{k+1} - v_k}{\\tau_{k+1} - \\tau_k}\n\\]\nThis gives an estimate of the average acceleration between the times \\(\\tau_k\\) and \\(\\tau_{k+1}\\). For each trial, you must now compute all such acceleration values, and then compute the average acceleration across the trial:\n\\[\\overline{a}^{(j)} = \\frac{1}{M_j} \\sum_{k=1}^{M_j} a_k\\] where \\(M_j\\) is the number of acceleration values in trial \\(j\\) (which is one less than the number of velocities).\n\n\n\n\n\n\n\n\nTask 5: Estimate \\(g\\)\nTo obtain a final estimate of the gravitational acceleration, we must now average the acceleration values computed across all trials.\nAs in Step 4, let \\(\\overline{a}^{(j)}\\) be the average acceleration for trial \\(j\\), and let \\(N\\) be the total number of trials. Then you must compute your final estimate of \\(g\\), given by:\n\\[\n\\hat{g} = \\frac{1}{N} \\sum_{j=1}^{N} \\overline{a}^{(j)}\n\\]\nThis value, \\(\\hat{g}\\), represents your best overall estimate of the acceleration due to gravity based on the experimental data.",
    "crumbs": [
      "Home",
      "05 Consolidation: Python in the field",
      "Physics Challenge"
    ]
  },
  {
    "objectID": "02/exercises_bool.html",
    "href": "02/exercises_bool.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\n\nBooleans and conditionals - Exercises\nThe following exercises allow to progress at your pace discovering boolean variables and conditional statements\n\nBeginner\nIntermediate\nAdvanced\n\nThere is no requirement to succeed at all of them. Come back to these over time to check the progression of your understanding."
  },
  {
    "objectID": "02/week_02_solutions.html",
    "href": "02/week_02_solutions.html",
    "title": "Week 2: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 2 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "02/week_02_solutions.html#beginner-if-statements",
    "href": "02/week_02_solutions.html#beginner-if-statements",
    "title": "Week 2: Solutions",
    "section": "Beginner: If Statements",
    "text": "Beginner: If Statements\nQuestion 1: The answer to this question is given below:\n\n\n\n\n\n\nQuestion 2: The code for this question is below.\n\n\n\n\n\n\nQuestion 3: The problem with this code is that the boolean for the if evaluates as True when the temperature exceeds 100, so the elif is never executed. A simple solution would be to switch the order of the clauses like so:\n\n\n\n\n\n\nQuestion 4: The code for this question is below:\n\n\n\n\n\n\nQuestion 5: One potential solution to this question is given below:\n\n\n\n\n\n\nQuestion 6: An answer to this question is given below.\n\n\n\n\n\n\nQuestion 7: A solution to this question is given below:\n\n\n\n\n\n\n\nQuestion 7: This question may feel daunting to students at first. In reality, the solution only requires adding the first clause (year % 400 == 0). One way to help is to have students test a few example years on paper before coding so the logic becomes clearer. Only encourage them to start coding once you feel they have a strong conceptual grasp of the problem.\n\nQuestion 8: The pass statement is a placeholder which effectively does nothing. If it were not there, we would have a SyntaxError as the if statement must contain code.\nQuestion 9: An answer to this question is given below:\n\n\n\n\n\n\nQuestion 10: The desired answer is below:\n\n\n\n\n\n\nAn alternative is given by:"
  },
  {
    "objectID": "02/week_02_solutions.html#intermediate-match-statements",
    "href": "02/week_02_solutions.html#intermediate-match-statements",
    "title": "Week 2: Solutions",
    "section": "Intermediate: Match Statements",
    "text": "Intermediate: Match Statements\nQuestion 1: The answer to this question is given below:\n\n\n\n\n\n\nQuestion 2: The solution to this question is given below:\n\n\n\n\n\n\nQuestion 3: A model answer is given below:\n\n\n\n\n\n\nQuestion 4: An example solution is provided below:\n\n\n\n\n\n\nQuestion 5: Below is a solution to this exercise:"
  },
  {
    "objectID": "02/week_02_solutions.html#advanced-conditional-expressions-and-lazy-evaluation",
    "href": "02/week_02_solutions.html#advanced-conditional-expressions-and-lazy-evaluation",
    "title": "Week 2: Solutions",
    "section": "Advanced: Conditional Expressions and Lazy Evaluation",
    "text": "Advanced: Conditional Expressions and Lazy Evaluation\nQuestion 1: An answer to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The logic in this question is very similar to the absolute value example in the Conditional Expressions section. If students are unsure what to do here, begin by referring them back to this example.\n\nQuestion 2: The answers to this question, alongside commented code are given below:\n\n\n\n\n\n\nQuestion 3: When Python evaluates an and expression, it checks the left-hand side first.\n\nIf my_boolean is True, the right-hand side (print(...)) must also be evaluated, so the message is printed.\nIf my_boolean is False, Python stops immediately, as it knows the and must be False, and the right-hand side is never run - so nothing is printed.\n\nQuestion 4: An answer to this question is given below:\n\n\n\n\n\n\nQuestion 5: The rule for evaluating x or y is:\n\nIf x is Truthy, return x.\nIf x is Falsy, return y.\n\nThis is the mirror image of how and works. Some example code is given by:"
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html",
    "href": "02/week_02_booleans_and_conditionals_advanced.html",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "",
    "text": "Welcome to the Week 2 Advanced Python Notebook. This notebook is designed for students who already have substantial experience with Python and feel confident working with both the Beginner and Intermediate material.\nYour task today is to carefully read through the content and complete the exercises at the end. These exercises are more challenging and are intended to deepen your understanding of how Python handles data behind the scenes.\nIn this notebook, you will explore one-line if statements, conditional expressions and lazy evaluation. This will deepen your understanding of conditional logic and boolean operators in Python.\nWork through the examples carefully, and take your time with the exercises. They are designed to stretch your understanding and prepare you for advanced applications of Python.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#writing-if-statements-on-one-line",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#writing-if-statements-on-one-line",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Writing if Statements on One Line",
    "text": "Writing if Statements on One Line\nIn Python, the syntax of an if statement appears as follows:\n\n\n\n\n\n\nPython actually allows the if statement above to be condensed to a single line, like so:\n\n\n\n\n\n\nIf the if statement contains multiple lines of code, we can combine them onto a single line using semicolons ;. For instance, the below code:\n\n\n\n\n\n\nis equivalent to:\n\n\n\n\n\n\nWe can also place elif and else statements on a single line in a similar way. For instance, the below code:\n\n\n\n\n\n\ncan be converted to:\n\n\n\n\n\n\nIn general, this sort of syntax is frowned upon, as it isn’t very easy to read. Still, it’s worth pointing out here, since it’s often mistaken for the more readable conditional expression syntax covered in the next section.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#conditional-expressions",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#conditional-expressions",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Conditional Expressions",
    "text": "Conditional Expressions\nWhen you’re writing code, you’ll often want a variable to take on one value in some situations and a different value in others. A straightforward way to do this is with an if–else statement, like this:\n\n\n\n\n\n\nHowever, the above code is quite verbose for quite a simple operation. Sometimes, it is more convenient to represent conditional definitions of this form using a conditional expression.\n\n\n\n\n\n\nHere the conditional expression consists of everything following the equals symbol. The general syntax for a conditional expression is:\n\n&lt;expr1&gt; if &lt;conditional_expr&gt; else &lt;expr2&gt;\n\nWhen you run this, the &lt;conditional_expr&gt; expression in the center is evaluated first. If &lt;conditional_expr&gt; is evaluated as True then &lt;expr1&gt; is evaluated. Otherwise, &lt;expr2&gt; is evaluated.\nNote that this means it is possible that one of &lt;expr1&gt; or &lt;expr2&gt; are never evaluated. For instance, in the below code the first expression should give a division by zero, but because it is never evaluated, no error is thrown.\n\n\n\n\n\n\n\nTest your understanding: How could you modify the above code to throw a division by zero error?\n\nWe can incorporate conditional expressions into larger expressions using round brackets (). For instance, the below code computes \\(x+|x|\\) for an input x.\n\n\n\n\n\n\n\nTest your understanding: Can you think of a way to compute result in the above using a single conditional expression, without adding x?",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#lazy-evaluation",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#lazy-evaluation",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Lazy Evaluation",
    "text": "Lazy Evaluation\nA conditional expression is a good example of lazy evaluation. In general, an evaluation is called lazy if only the values that are actually needed are computed. For instance, in the example from the previous section, the expression 1/0 was never evaluated - it was skipped entirely as it wasn’t needed - which is what makes the evaluation lazy.\nThe and and or operations we met last week are actually examples of lazy operations. We’ve already seen them used with Booleans, but in Python they can be applied to many other data types as well. Let’s start with a few quick examples:\n\n\n\n\n\n\nIn the first line, both operands are Booleans, so the result is False. But in the later examples, the result is not a Boolean - it’s one of the operands themselves. For instance, 5 and 10 returns 10, while 0 and 99 returns 0. To explain what’s going on here, lets consider what happens when x and y are Booleans and we compute x and y.\n\n\n\n\n\n\nIf we were computing x and y by hand, we would naturally start by looking at x. If x is False, then the whole expression must also be False - because in an and both sides need to be true. There’s no reason to even check y; we can just return the value of x (that is, False).\nIf, on the other hand, x is True, then the overall result depends entirely on y. In that case, x and y is true if and only if y is true.\nSo a simple way to describe the evaluation of x and y is:\n\nIf x is False, return x.\nIf x is True, return y.\n\nThe same evaluation rules apply even when the operands are numbers, strings, or other kinds of objects. To make this work, Python treats every value as either truthy or falsy when it’s used in a logical expression:\n\nFalsy values behave like False. These include False itself, numeric zero (0, 0.0, etc.), the empty string \"\", empty containers like [] or {}, and None.\nTruthy values behave like True. Almost everything else falls into this category: non-zero numbers, non-empty strings, non-empty lists, and so on.\n\nYou can check whether a variable is Truthy or Falsy by casting it too a Boolean. For example:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_advanced.html#exercises",
    "href": "02/week_02_booleans_and_conditionals_advanced.html#exercises",
    "title": "Advanced: Conditional Expressions and Lazy Evaluation",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Below are two variables x and y. Use a conditional expression to compute the maximum of x and y.\n\n\n\n\n\n\nQuestion 2: Without running code, describe what you think would happen if you ran each of the following lines of code:\n\nmy_variable = True and 1/0\nmy_variable = False and 1/0\nmy_variable = str(False and 1/0)\nmy_variable = str(False) and 1/0\n\nExplain your answers.\nQuestion 3: The below code prints the statement “This code is printed if my boolean is True.” if my_boolean is True, but doesn’t print anything otherwise. Explain why.\n\n\n\n\n\n\nQuestion 4: Based on your answer to Question 2, use the and and or operators to write code which prints \"A\" if my_boolean is True and \"B\" otherwise. Do not use if statements for this question.\n\n\n\n\n\n\nQuestion 5: In the section on Lazy Evaluation, we explained how the and operator evaluates Truthy and Falsy values by examining one variable at a time. Specifically, we saw that the expression x and y follows this rule:\n\nIf x is Falsy, return x.\nIf x is Truthy, return y.\n\nUsing the same line of reasoning, derive the corresponding rule for the or operator. Write code in the box below to test your result.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Advanced: Conditional Expressions and Lazy Evaluation"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html",
    "href": "02/week_02_booleans_and_conditionals_beginner.html",
    "title": "Beginner: If Statements",
    "section": "",
    "text": "Welcome to the Week 2 Beginner Python Notebook. This notebook is designed for students who are just starting out with the Python programming language.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.\nIn this notebook, you will be introduced to the if statement; a powerful feature of Python that lets you control when certain pieces of code are executed.\nBe sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#recap-booleans",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#recap-booleans",
    "title": "Beginner: If Statements",
    "section": "Recap: Booleans",
    "text": "Recap: Booleans\nLast week, we met Boolean variables. These were variables which can take the values True or False.\n\n\n\n\n\n\nWe often create booleans by comparing other variables to one another:\n\n\n\n\n\n\nWe can save the value of a boolean comparison like so:\n\n\n\n\n\n\nPython has several operators to combine or modify booleans:\n\n\n\n\n\n\nTo summarize: - Booleans are always either True or False. - Comparisons (&gt;, &lt;, ==, !=, in) produce Boolean values. - Boolean operators (not, and, or) let us combine or flip conditions.\nToday, we shall look at using Booleans to perform conditional operations. That is, we shall write code which executes only when certain circumstances hold. To do so, we shall introduce the if statement.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#the-if-statement",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#the-if-statement",
    "title": "Beginner: If Statements",
    "section": "The if Statement",
    "text": "The if Statement\nAn if statement allows you to run a block of code if and only if a boolean expression is True. Take the example in the following block, for instance. In this example, “Positive” is printed if the variable my_number is greater than \\(100\\).\n\n\n\n\n\n\n\nTest your understanding: Try changing the value of my_number in the above code to be negative. Before moving on, think about what might be happening here; How do you think the if statement decides which statements to print?\n\nLet’s break down exactly what is going on in this if statement.\nAn if always follows the same layout. First, it must include the if keyword and a colon :, like so:\n ↓                ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nIn between the if and the :, we must place a boolean variable. The idea here is that we want our code to execute (run) if and only if this boolean is true. In our example the boolean is my_number &gt; 100.\n          ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nWe next need to add a body. The body is the lines of code that will be run if the condition has been met:\nif my_number &gt; 100:\n    print(my_number, \"is large\")  ← body of the if statement\n\nPython will only recognise code as being in the body of the if statement if it is indented. This means that all code in the body must be indented relative to the word if by four spaces. A trick to help remember this is that every time you see a colon in Python you should start a new line and indent:\n                colon\n                  ↓\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n  ↑\nindentation\n\nCode that is not indented will be treated as being outside the if statement and run in the usual manner.\nif my_number &gt; 100:\n    print(my_number, \"is large\")\n\nprint(\"This is always printed\")  ← this code will always run as it is outside the if statement\n\nHere are some more examples of if statements.\n\n\n\n\n\n\nNote that, in the above examples, we have always defined our boolean variable directly between the if and colon :. We didn’t have to do this; we could have instead defined the variable first like so:\n\n\n\n\n\n\nIn practice, it’s often simpler not to define a separate boolean variable explicitly like we did above. Deciding whether to store something like x_is_positive depends partly on whether you’ll need to reuse it later and partly on personal preference.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#else",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#else",
    "title": "Beginner: If Statements",
    "section": "else",
    "text": "else\nWe’ve just seen that the body of an if statement will only run if the boolean is True. But what if we want to do one thing if it’s true, but another if it’s false? We can do this by attaching an else statement to the if statement, like so:\n\n\n\n\n\n\n\nWarning: The else statement must be at the same level of indentation as the if keyword. If not the code will throw an error, like so:",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#elif",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#elif",
    "title": "Beginner: If Statements",
    "section": "elif",
    "text": "elif\nSometimes an if-else statement isn’t enough, because you want to check more than two possibilities. For such situations, we can use the elif keyword.\nelif stands for ‘’else if’’. It lets you add extra conditions to your decision-making. For instance:\n\n\n\n\n\n\nThere are a few rules to keep in mind here:\n\nThe order matters: we start with if, then add as many elif statements as you need, and finish with an optional else.\nYou can only have one if and one else, but you can include any number of elif statements in between.\nIf one of the statements evaluates as True, the remaining code will not be executed, regardless of the truth of the remaining conditions.\n\nHere are some more examples of this concept in action.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWarning: Indentation is crucial for if statements in python. You must indent blocks of code within if statements as this is how the blocks of code are delineated in python.\n\n\nWarning: Make sure to remember the colon on the end of the if, elif and else statements! Without this Python, will throw an error. This error often causes many a headache for new Python users!",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#worked-example-determining-a-leap-year",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#worked-example-determining-a-leap-year",
    "title": "Beginner: If Statements",
    "section": "Worked Example: Determining a Leap Year",
    "text": "Worked Example: Determining a Leap Year\nSay we wanted to determine whether a year is a leap year (a year with 366 days rather than the usual 365).\nThe first thing we know is that a leap year generally happens every 4 years. So to start off we could impose the following condition:\n\n\n\n\n\n\n\nRecall: Last week, we saw that the % operator represents modular arithmetic. This means that a % b gives the remainder when a is divided by b. For example, 10 % 3 gives 1. The above code works as if year % 4 equals 0, then the year must be divisible by 4.\n\nThe rules for determining leap years in the Gregorian calendar are a bit more nuanced than simply being divisible by \\(4\\). In fact, if the year is also divisible by \\(100\\), then it is not a leap year (e.g., \\(1800\\), \\(1900\\), \\(2100\\)).\nWe need to add this new condition to our if statement. This can be done by combining year % 4 == 0 and year % 100 == 0 using an and clause:\n\n\n\n\n\n\nLet’s try adding a new block to account for the situation where even if the year is divisible by \\(4\\), if it is also divisible by \\(100\\) it is not a leap year.\n\n\n\n\n\n\nBut this isn’t right - we saw above that \\(1900\\) is not a leap year so this should say\nIs 1900 a leap year? No\nLet’s go through this line by line. Python checks the first criteria in the if block year % 4 == 0:\n\n\n\n\n\n\nAs this boolean is true, the if statement stops when it is evaluated and exits without checking the other clauses.\nSo how do we make sure Python checks the correct set of conditions first? To do this we have to think about the ordering of the clauses:\n\n\n\n\n\n\nNow Python checks the more strict clause first and then exits when the condition year % 100 == 0 and year % 4 == 0 is true:\n\n\n\n\n\n\nThis updated if statement now gives us the behaviour we desired.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "02/week_02_booleans_and_conditionals_beginner.html#exercises",
    "href": "02/week_02_booleans_and_conditionals_beginner.html#exercises",
    "title": "Beginner: If Statements",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: Create a string containing your last (or first) name. Write an if statement to check if the length of this string is greater than 8. If true, print “The name is long”.\nHint: Recall the len() function can be used to check the length of strings.\n\n\n\n\n\n\nQuestion 2: The pH value of a liquid can be used to determine whether it is acidic, alkaline, or neutral. Write some code which uses the variable ph_level to assign the correct liquid_type (\"acid\", \"alkali\", or \"neutral\").\n\n\n\n\n\n\nNow, modify your code to set liquid_type=\"unknown\" if ph_level does not lie on the pH scale.\nQuestion 3: The following code is intended to classify the state of water based on its temperature in °C:\n\n\n\n\n\n\nHowever, when you run the code with temperature = 120, the output is:\nState of water: liquid\nBut at 120 °C, water should be a gas, not a liquid! Explain why this program gives the wrong result and modify the code to give the correct result.\nQuestion 4: In the code box below, the variable day_number represents the day of the year. For example, if day_number = 8, the date is January 8th, and if day_number = 32, the date is February 1st. Write an if statement that determines the current month based on the value of day_number. You may assume the year is not a leap year and that day_number is an integer strictly greater than 0 and strictly less than 366.\n\n\n\n\n\n\nQuestion 5: Now suppose you want to adapt your code from Question 4 so that day_number can fall outside the usual range of 1 to 365. For example, day_number = 366 should “wrap around” to January 1st, while day_number = 0 should correspond to December 31st. How would you modify your if statement to handle this? Write your code below. For simplicity, you may continue to ignore leap years.\n\n\n\n\n\n\nHint: The % operator might be useful here!\nQuestion 6: The code below has a distance given in kilometres. Assuming 1 mile ≈ 1.60934 km, convert the distance in km to a distance given in miles. Write code which does the following:\n\nIf the distance is greater than 2 miles, print “Distance is more than 2 miles”.\nPrint “Distance is short” if this condition is not met.\nAdd an additional check if distance_in_miles is &gt; 1 mile and print “Distance is more than 1 mile” if true.\n\n\n\n\n\n\n\nQuestion 7: The leap year example given in the worked example section is incomplete. The full definition of a leap year is as follows;\n\nA year is a leap year if it is divisible by \\(4\\) but not by \\(100\\).\n\nUnless…\n\nIf the year is divisible by \\(400\\), then it is a leap year after all (e.g., \\(2000\\), \\(2400\\)).\n\nModify the example of the worked example section to incorporate this final bullet point.\n\n\n\n\n\n\nQuestion 8: By performing your own research online, explain what the keyword pass does in the code below and why you might use it.\n\n\n\n\n\n\nWhat do you think would happen if you removed the line with pass from the code above?\nQuestion 9: FizzBuzz is a children’s counting game played with the following rules:\n\nPlayers take turns counting up from 1.\nIf a number is divisible by 3, say \"Fizz\".\nIf a number is divisible by 5, say \"Buzz\".\nIf a number is divisible by both 3 and 5, say \"FizzBuzz\".\nOtherwise, say the number itself (as a string).\n\nIt’s now your turn. You are given the previous player’s answer, prev_answer, along with the number they just counted, prev_num. Using an if–elif–else statement, print the correct response for your turn.\n\n\n\n\n\n\nModify your code so that if the previous player’s answer was incorrect, your program prints a message pointing out the mistake before giving your own response.\nQuestion 10: The code below contains a horrendous nested if statement. By combining cases using the and and or operators, reduce the long nested if statement to a single if–elif statement.",
    "crumbs": [
      "Home",
      "02 Booleans and Conditionals",
      "Beginner: If Statements"
    ]
  },
  {
    "objectID": "formative/basic_structures.html",
    "href": "formative/basic_structures.html",
    "title": "Variables, lists, dictionaries and branches",
    "section": "",
    "text": "This is a formative test. It is an occasion to practice the course material. It does not contribute to your final grade.\nUsing the topics covered within the workshops (or otherwise), complete the questions below.\nMake sure to use any described variable names exactly and do not change the name of this file. This ensures the nbgrader tool can grade your work correctly.\n\n\n\n\nQuestion 1\n1A) Using the pi variable defined below (representing \\(\\pi\\) to 6 decimal places), calculate the circumference of a circle with radius of 5 and assign to a variable called circum_circle.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nRemember to define the radius and use the formula: circum_circle = 2 * pi * radius.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nradius = 5\ncircum_circle = 2 * pi * radius\n\n\n\n\n\n1B) Calculate the area of a circle with radius 2.5 and assign to area_circle.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse Area = pi * radius**2.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\narea_circle = pi * radius**2\n\n\n\n\n\n\n\nQuestion 2\n\n\n2A) Access the second name in the names list and assign to chemist.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nSecond element has index 1.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nchemist = names[1]\n\n\n\n\n\n2B) Add \"Albert Einstein\" to the names list.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse names.append(\"Albert Einstein\").\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nnames.append(\"Albert Einstein\")\n\n\n\n\n\n\n\nQuestion 3\n\n\n3A) Access the value for quantity = \"temperature\" in quantity_units and assign to units.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nAccess dictionary values with dictionary[key].\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nunits = quantity_units[quantity]\n\n\n\n\n\n3B) For the variable second_quantity defined below, check whether this key is present in the quantity_units dictionary. If this is in the dictionary create a variable called quantity_present and assign this to a value of True, otherwise assign this to a value of False.\nNotes:\n\nYou can use the print function to check the value within your quantity_present variable (boolean). If this produces a NameError, you may need to check that quantity_present has been successfully created.\nCheck your Week 3 notes for examples of how to check membership (i.e. whether a value is contained within a collection like a list or a dictionary).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nUse key in dictionary to check membership.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nif second_quantity in quantity_units:\n    quantity_present = True\nelse:\n    quantity_present = False\n# OR\nquantity_present = second_quantity in quantity_units\n\n\n\n\n\n\n\nQuestion 4\n4A) Two values of heights in units of feet are provided below in a list called height_feet. Convert these values to metres and calculate the difference in metres. Store this difference in a variable called height_difference_m.\nConversion from feet to metres can be done using the equation:\nThe conversion equation is: \\[ \\mathrm{height_{feet}} = \\mathrm{height_{m}} \\times 3.28084\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nConvert each height to metres and subtract: (h2 * conversion - h1 * conversion).\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\nheight_metre = [height_feet[0]/feet_per_metre, height_feet[1]/feet_per_metre]\n# or if you have learnt about loops and list comprehension\nheight_metre = [h/feet_per_metre for h in height_feet]\n\nheight_difference_m = height_metre[1]-height_metre[0]\n\n\n\n\n\n4B) Check whether height_difference_m is:\n\nIf height_difference_m is greater than 0.5 metres (50cm), create a variable called check and set this to 1\nIf height_difference_m is between 0.3 and 0.5 metres (30 to 50cm), create a variable called check and set this to 2\nIf height_difference_m is something else, create a variable called check and set this to 3\n\ndo this by constructing and if–else block.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteHint\n\n\n\n\n\nYou need an if, elif else construct.\n\n\n\n\n\n\n\n\n\n\n\nTipFully worked solution\n\n\n\n\n\ncheck = 0\nif height_difference_m &gt; 0.5:\n    print(f\"{height_difference_m:.3f} is greater than 0.5m\")\n    check=1\nelif height_difference_m &gt; 0.3 and height_difference_m &lt;= 0.5:\n    print(f\"{height_difference_m:.3f} is greater than 0.3m but less than or equal to 0.5m\")\n    check=2\nelse:\n    print(height_difference_m)\n    check=3"
  },
  {
    "objectID": "11/exercises_numpy_riddles_solutions.html",
    "href": "11/exercises_numpy_riddles_solutions.html",
    "title": "Consolidation - numpy riddles",
    "section": "",
    "text": "Solve the following numpy riddles using numpy and its documentation.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\n\n\n\n\n\n\nDiagonal Sum: - Riddle: Write a function that takes a square 2D NumPy array as input and returns the sum of the elements along the main diagonal. - Example: diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) -&gt; 15\n\n\n\n\n\n\nUnique Elements Count: - Riddle: Write a function that takes a 1D NumPy array as input and returns the count of unique elements in the array. - Example: unique_count([1, 2, 3, 2, 4, 1, 5]) -&gt; 5\n\n\n\n\n\n\nRandom sample ands cumulative sum: - Riddle: A fair coin is tossed 20 times, and we win 1£ for every head and lose 1£ for every tail. Assuming that we start with no money at the beginning, and that the seed of teh default random number generator is seed=1234, how much money do we have at every succesive step?\n\n\n\n\n\n\nRolling Window: - Riddle: Write a function that takes a 1D NumPy array and a window size as input, and returns a 2D array where each row is a sliding window of the input array of a given size. - For example, a 1d array with a rolling window of size 3: rolling_window([1, 2, 3, 4, 5], 3) -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\nHint: you can use list comprehension and convert the final list to an array.\n\n\n\n\n\n\nProduct of elements: - Riddle: The geometric mean of a number of observations \\(x_1, x_2,\\dots, x_n\\) is defined as \\(M = \\sqrt{x_1\\times x_2\\times \\dots x_n }\\). Define a custom function to calculate the geometric mean. - Example: geometric_mean([1, 2, 3, 4, 5]) -&gt; 10.954451150103322\n\n\n\n\n\n\nVectorised calculations and visualisation: - Riddle: Draw 100 thousand points uniformly distributed inside a circle of radius 1 centered at (0,0). Plot them using scatplotter() from matplotlibacoording to their radial coordinate: - use the hexadecimal colour \"#76d6ff\" for points at a distance below 0.5 from the origin$. - use the hexadecimal colour \"ffe701\" for points furtehr away.\nHint1: disk point picking is not trivial: https://mathworld.wolfram.com/DiskPointPicking.html\nHint2: For matplotlib’s plot, use the pixel style ',', and remmber to set the axis to be in the same units (\"equal\")"
  },
  {
    "objectID": "11/exercises_python_riddles_solutions.html",
    "href": "11/exercises_python_riddles_solutions.html",
    "title": "Consolidation - Python riddles",
    "section": "",
    "text": "Solve the following using standard Python features and built-in functions.\nIf possible, work in the pair programming paradigm: work in pairs, with one person taking the role of the driver (writing the code) and one taking the role of the navigator (reading and understanding the documentation). Alternate the roles. Try to find solutions that are short (i.e. few line sof code) but easy to understand.\nSum of Digits - Riddle: Write a function sum_digits(n) that takes an integer n and returns the sum of its digits. - Test it with the following test cases: sum_digits(145)--&gt;10 and sum_digits(102)--&gt;3\nHint: remember that you can convert an integer to a string with str(n) and a character c to integer with int(c).\n\n\n\n\n\n\nPalyndrome checker\n\nRiddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function is_palindrome(s) that takes an object s, checks that it is a string and returns True if s is a palindrome and False otherwise.\nTest it with the following test cases: is_palindrome(\"racecar\")--&gt;True , is_palindrome(\"hello\")--&gt;False and is_palindrome(3)--&gt;error\n\nHint: an object is a string if typ(s) returns str.\n\n\n\n\n\n\nThe Peak Finder\n\nRiddle: In a list of numbers, a “peak” is a number that is greater than both its neighbors. The first and last elements can only be peaks if they’re greater than their single neighbor. Write find_peaks(data) that returns a list of all peak values (not their positions, just the values).\nExample: In [1, 3, 2, 5, 4, 6, 1], the peaks are [3, 5, 6] because:\n\n3 &gt; 1 and 3 &gt; 2 ✓\n5 &gt; 2 and 5 &gt; 4 ✓\n6 &gt; 4 and 6 &gt; 1 ✓\n\nTest cases:\n\nfind_peaks([1, 3, 2, 5, 4, 6, 1]) → [3, 5, 6]\nfind_peaks([1, 2, 3, 4, 5]) → [5] (only the last element)\nfind_peaks([5, 4, 3, 2, 1]) → [5] (only the first element)\nfind_peaks([1, 1, 1]) → [] (no peaks - they must be strictly greater!)\n\n\nHint: Loop through indices 0 to len(data)-1 and check neighbors carefully at the boundaries.\n\n\n\n\n\n\n\n\n\n\n\n\nThe Frequency Detective\n\nRiddle: In a dataset, you want to find the value that appears most often (the “mode”). But here’s the twist: if there’s a tie, return the smallest value among the most frequent ones. Write find_mode(data) to solve this mystery.\nExample: In [1, 2, 2, 3, 3, 4], both 2 and 3 appear twice. Return 2 (smallest of the tied values).\nTest cases:\n\nfind_mode([1, 2, 2, 3, 3, 4]) → 2 (2 and 3 tied at 2 occurrences, but 2 is smaller)\nfind_mode([5, 5, 3, 3, 3, 1]) → 3 (appears 3 times, most frequent)\nfind_mode([7, 7, 7, 2, 2, 2]) → 2 (tied at 3 occurrences, 2 is smaller)\nfind_mode([4]) → 4 (single element)\n\n\nHint: Count occurrences with a dictionary, find the maximum count, then among all values with that count, return the minimum."
  },
  {
    "objectID": "11/example.html",
    "href": "11/example.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html",
    "href": "11/slides_beyond_and_riddles.html",
    "title": "Beyond the Notebook and some riddles",
    "section": "",
    "text": "Explore alternative ways to interact with Python code beyond Jupyter Notebooks\nDiscover some basic file management tools\nConsolidate your Python understanding with a few riddles"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#today",
    "href": "11/slides_beyond_and_riddles.html#today",
    "title": "Beyond the Notebook and some riddles",
    "section": "",
    "text": "Explore alternative ways to interact with Python code beyond Jupyter Notebooks\nDiscover some basic file management tools\nConsolidate your Python understanding with a few riddles"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#aims",
    "href": "11/slides_beyond_and_riddles.html#aims",
    "title": "Beyond the Notebook and some riddles",
    "section": "Aims",
    "text": "Aims\nAim: We will explore more advanced ways to use the notebook and to use python beyond the notebook.\nToday’s session will give you pointers on how to interact with the notebook in a more advanced an productive way.\nYou will learn about how to navigate directories and use files called python scripts to store useful code for future re-use.\nThe session will be rely on some live demonstrations."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#jupyter-notebook-vs-jupyter-lab",
    "href": "11/slides_beyond_and_riddles.html#jupyter-notebook-vs-jupyter-lab",
    "title": "Beyond the Notebook and some riddles",
    "section": "Jupyter Notebook vs Jupyter Lab",
    "text": "Jupyter Notebook vs Jupyter Lab\n\nAll previous workshops have used Jupyter Notebooks by selecting Jupyter Classic (Legacy) from teh Noteable interface.\nA richer environment is available by selecting Jupyter Lab from the Noteable interface, selecting Standard Python 3\n\n\n\n\nimage.png"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#jupyter-lab-interface",
    "href": "11/slides_beyond_and_riddles.html#jupyter-lab-interface",
    "title": "Beyond the Notebook and some riddles",
    "section": "Jupyter Lab interface",
    "text": "Jupyter Lab interface\n\nThe interface is more complex, but also more powerful.\nWe have on the left a file browser that allows us to navigate the file system.\nOn the right using the launcher we can create new notebooks, text files, terminals, and other useful items.\n\n(Live demonstration)\n\n\n\nimage.png"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#files-and-folders",
    "href": "11/slides_beyond_and_riddles.html#files-and-folders",
    "title": "Beyond the Notebook and some riddles",
    "section": "Files and folders",
    "text": "Files and folders\nUsing the graphical file manager, you can create, delete, move, and organize files and folders on your computer. Here are some common tasks you can perform:\n\nCreate a new folder: Right-click in the file browser and select “New Folder” to create a new directory.\nUpload files: Click the “Upload” button to upload files from your local machine to the current directory.\nRename files/folders: Right-click on a file or folder and select “Rename\nCreate a new file: Click on File -&gt; New -&gt; Text File or Python File"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#python-files-vs-notebooks",
    "href": "11/slides_beyond_and_riddles.html#python-files-vs-notebooks",
    "title": "Beyond the Notebook and some riddles",
    "section": "Python files vs notebooks",
    "text": "Python files vs notebooks\n\nPython files are pure text files that contain Python code. They have a .py extension.\nNotebooks are interactive documents that can contain code, text, images, and more. They have a .ipynb extension. They are the primary way we have been interacting with Python so far.\nPython files are useful for storing reusable code, while notebooks are great for exploration and documentation."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#interact-with-the-file-systems-from-a-notebook-bash",
    "href": "11/slides_beyond_and_riddles.html#interact-with-the-file-systems-from-a-notebook-bash",
    "title": "Beyond the Notebook and some riddles",
    "section": "Interact with the file systems from a notebook: Bash",
    "text": "Interact with the file systems from a notebook: Bash\nFrom a notebook we can interact with the file system to scan directories, create files and folders, and move files around.\nWe do this by leveraging special commands using the ! character.\nThis allows us to run shell commands from within a notebook cell. These are commands that you would normally run in a terminal or command prompt. They use a special language that is different from Python but is very useful for file management.\nThe language is called Bash.\nBash is important because it allows us to interact with the operating system and perform tasks that are not directly related to Python programming.\nFor example, it is useful when communicating with remote servers, managing files, and automating tasks.\nFrom Jupyter, you can launch a Terminal if you want to explore a purely Bash environment."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#basic-bash-commands-from-a-notebook",
    "href": "11/slides_beyond_and_riddles.html#basic-bash-commands-from-a-notebook",
    "title": "Beyond the Notebook and some riddles",
    "section": "Basic Bash commands from a notebook",
    "text": "Basic Bash commands from a notebook\nIn the next few slides we will explore some basic Bash commands that you can use from within a Jupyter notebook.\nYou can run these commands by prefixing them with the ! character in a notebook cell."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#pathway-to-the-current-directory",
    "href": "11/slides_beyond_and_riddles.html#pathway-to-the-current-directory",
    "title": "Beyond the Notebook and some riddles",
    "section": "Pathway to the current directory",
    "text": "Pathway to the current directory\nFirst, let’s check where we are right now in the file system. To do so, we query the pathway to the working directory with the pwd command.\n\n\n\n\n\n\nThis shows where we currently are, and each of you should have a different path, with a different username."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#listing-the-content-of-the-current-directory",
    "href": "11/slides_beyond_and_riddles.html#listing-the-content-of-the-current-directory",
    "title": "Beyond the Notebook and some riddles",
    "section": "Listing the content of the current directory",
    "text": "Listing the content of the current directory\nThe ls command lists the files and directories in the current directory. The current directory is represented by a . (dot)."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#creating-a-new-directory",
    "href": "11/slides_beyond_and_riddles.html#creating-a-new-directory",
    "title": "Beyond the Notebook and some riddles",
    "section": "Creating a new directory",
    "text": "Creating a new directory\nThe mkdir command creates a new directory in the specified path. For example, to create a new directory in the current directory we can write\n\n\n\n\n\n\nWe can check its existence with ls.\n\n\n\n\n\n\nEqually, we can go back to the jupyter interface and see the new directory in the graphical user interface."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#changing-directory",
    "href": "11/slides_beyond_and_riddles.html#changing-directory",
    "title": "Beyond the Notebook and some riddles",
    "section": "Changing directory",
    "text": "Changing directory\nIt is easy to change the current directory with the cd command. For example, to go to the new_directory with\n\n\n\n\n\n\nAnd we we can go back to the previous directory with the cd command again using .."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#creating-an-empty-file",
    "href": "11/slides_beyond_and_riddles.html#creating-an-empty-file",
    "title": "Beyond the Notebook and some riddles",
    "section": "Creating an empty file",
    "text": "Creating an empty file\nThe touch command creates a new file in the specified path. For example, to create a new file in the current directory we can write\n\n\n\n\n\n\nWe can check its existence with ls.\n\n\n\n\n\n\nWe can open this file in the graphical user interface and edit the contents\n[follows demonstration in Noteable with dummy text in the file new_file.txt]"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#viewing-file-content",
    "href": "11/slides_beyond_and_riddles.html#viewing-file-content",
    "title": "Beyond the Notebook and some riddles",
    "section": "Viewing file content",
    "text": "Viewing file content\nThe cat command prints the content of a file. For example, to view the content of new_file.txt we can write\n\n\n\n\n\n\nSeveral other commands exist to display parts of files, such as head, tail etc. Try them if you like!"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#exercise",
    "href": "11/slides_beyond_and_riddles.html#exercise",
    "title": "Beyond the Notebook and some riddles",
    "section": "Exercise",
    "text": "Exercise\n\nCreate a new jupyter notebook using the graphical user interface.\nFrom the notebook, use the commands above to create:\n\na new directory called src\na new file inside the directory called naive_script.py\nopen it with double click for the files tab in jupyter and write a minimal code\n\nprint(\"Hello, World!\")\n\nsave the file\nuse the cat command from the notebook to view the content of naive_script.py"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#running-scripts-from-the-notebook",
    "href": "11/slides_beyond_and_riddles.html#running-scripts-from-the-notebook",
    "title": "Beyond the Notebook and some riddles",
    "section": "Running scripts: from the notebook",
    "text": "Running scripts: from the notebook\nFor the entire duration of this course, you have been running python codes by typing them inside the notebook cells and executing the code cells.\nThe notebooks are complex files, that contain a lot of information beyond your code: the markdown, images, and a lot of extra data (called metadata).\nA much more essential way to store python code is to use scripts. These are files with the .py extension, like your naive_script.py file. Inside a script you can only have\n\npython code\npython comments to the code (i.e. lines prepended by the #)\n\nThis means that the scripts are simple, portable pure text files containing instructions in the python language.\nCan we execute such instructions? Yes, we run a script in various way. A simple way is to do it directly from a code cell in the notebook. For this we use a special jupyter command called run followed by the path to the script.\n[check that you are in the correct path and the script exist]\n\n\n\n\n\n\nAs you can see, we have executed the instructions of the script and its textual output has been printed in the notebook. No variables are created during the process."
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#the-terminal",
    "href": "11/slides_beyond_and_riddles.html#the-terminal",
    "title": "Beyond the Notebook and some riddles",
    "section": "The Terminal",
    "text": "The Terminal\nAll the commands that we have seen above can be used in a pure-text environment called the terminal. The terminal is a text-based interface to an operating system (local or remote).\nYou do not use the mouse to perform actions. Instead, you write commands. These commands belong to the scripting language called bash (see here for more information). It is different from python, they can interact together in the notebook.\nYou can launch a terminal directly from Noteable (Legacy) by clicking on the New button, then selecting Terminal.\n\n\n\nimage.png"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#exercise-1",
    "href": "11/slides_beyond_and_riddles.html#exercise-1",
    "title": "Beyond the Notebook and some riddles",
    "section": "Exercise",
    "text": "Exercise\n\nWe try to navigate folders from the terminal and create a file\nOpen the terminal and\n\nchange the directory to src (using cd)\ncreate a new file inside the directory called parabola.py (use touch)\ngo back to the Noteable file tab, refresh the web-page and open the parabola.py file\nopen it and write a minimal code to plot a parabola. For example:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\na = 1.\nb =1.\nc = 2\nxlo = 0\nxhi = 10\nnpoints = 100\nx = np.linspace(xlo, xhi, npoints)\ny = a*x**2 + b*x + c\nplt.plot(x,y)\nplt.savefig(\"parabola.png\")\n\n\nsave the file and go back to the Terminal tab\nuse the cat command to check the content"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#exercise-running-scripts-from-the-terminal",
    "href": "11/slides_beyond_and_riddles.html#exercise-running-scripts-from-the-terminal",
    "title": "Beyond the Notebook and some riddles",
    "section": "Exercise: Running scripts from the Terminal",
    "text": "Exercise: Running scripts from the Terminal\nWe have seen that we can run the scripts from the notebook using the run command. In a very similar way, we can run scripts from the terminal, just by using the python command followed by the path to the script.\nDo the following:\n\nfirst run the parabola script from the notebook using run: you should see the plot appear in the notebook.\nthen go back to the Terminal and run the parabola.py script using the python command followed by the path to the script: e.g. python src/parabola.py. Where is the output?"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#reusing-code",
    "href": "11/slides_beyond_and_riddles.html#reusing-code",
    "title": "Beyond the Notebook and some riddles",
    "section": "Reusing code",
    "text": "Reusing code\nThe most useful feature of the scripts is that they can store code for future usage in an organized manner. We do not need to have all of our code in a single notebook: we can split the relvant bits, put them into scripts and use them again and again in different projects.\nWhat allows us to do this is the special python keywork import, that we have already used many times.\nLet’s move our working directory to src and try importing our parabola.py script\n\n\n\n\n\n\nIn python we can only import .py files, so we drop the .py extension when importing.\n\n\n\n\n\n\nNow the variables defined in parabola.py are available in our current notebook.\n\n\n\n\n\n\nCongratulations! You have written your first python module!"
  },
  {
    "objectID": "11/slides_beyond_and_riddles.html#exercises",
    "href": "11/slides_beyond_and_riddles.html#exercises",
    "title": "Beyond the Notebook and some riddles",
    "section": "Exercises",
    "text": "Exercises\n\nIn the lecture_beyond_notebook.ipynbfile you will find some more exercises on how to interact with files and scripts.\nThese topics are important and complementary to your learning, but** not essential** for the rest of the course.\nHence, you can also choose to adapt use this session to do further consolidation work. For this, we have prepared some riddles that you can try to solve using your python knowledge so far.\n\nNumpy riddles in exercises_numpy_riddles.ipynb\nPython riddles in exercises_python_riddles.ipynb"
  },
  {
    "objectID": "16/lecture_pandas_vs_numpy.html",
    "href": "16/lecture_pandas_vs_numpy.html",
    "title": "Pandas vs Numpy",
    "section": "",
    "text": "If we look back at our trajectory in Python, we should see that building from the lementary data structures we have progressed into m,ore complex data types exploited buy varous libraries.\nIn particular, we have seen how the efficient handling of numerical data types is perfomed in Python using the numpy numerical library and how this is further extended to handle tabular data using the pandas library.\npandas is built on top of numpy and provides high-level data structures and functions designed to make data analysis and manipulation easier and more intuitive.\nPandas chiefly operates with tabulated data stuctures called DataFrames, which are essentially 2-dimensional labeled data structures with columns of potentially different types. This makes pandas particularly well-suited for handling structured data, such as CSV files, SQL tables, and Excel spreadsheets.\nOn the other hand the building block of numpy is the ndarray, which is a powerful n-dimensional array, of which tables are just a particular instance (2-dimensional arrays). numpy is optimized for numerical computations and provides a wide range of mathematical functions to operate on these arrays efficiently.\nIn this lecture we will explore similarities and differences between pandas and numpy, and how to make them interoperate effectively.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Pandas vs Numpy"
    ]
  },
  {
    "objectID": "16/lecture_pandas_vs_numpy.html#reading-data-in",
    "href": "16/lecture_pandas_vs_numpy.html#reading-data-in",
    "title": "Pandas vs Numpy",
    "section": "Reading data in",
    "text": "Reading data in\nWe have seen that both pandas and numpy provide functions to read data from various file formats, but they do so in different ways.\nIn numpy we have functions like numpy.loadtxt() and numpy.genfromtxt() to read data from text files, while pandas offers more versatile functions like pandas.read_csv(), pandas.read_excel(), and pandas.read_sql() to read data from a variety of sources.\nConsider a CSV file named sample_data.csv with the following content:\nid,age,score,grade\n1,20,85,4.0\n2,21,,3.0\n3,19,92,4.0\n4,22,88,\n5,20,76,3.0\n6,,91,4.0\n7,21,79,3.0\n8,23,,2.0\n9,20,95,4.0\n10,22,82,\nNotice that it contains some missing values.\n\n\n\n\n\n\nWe can read it in numpy simply with genfromtxt\n\n\n\n\n\n\nnumpy by default reads data directly into ndarrays, which contain homogeneous data types (the same dtype)\n\n\n\n\n\n\nNotice that the headers have been lost and the missing values interpreted as nan which is a value that exists in numpy\n\n\n\n\n\n\nIn pandas, we can read the same file using read_csv()\n\n\n\n\n\n\nThis produces a DataFrame object, whidh is a bit richer: it contains the headers, the explicit indices and the data types of each column are inferred separately.\nCleaning the data from the missing values in numpy requires some ad hoc work: for example, we could decide to remove any row that contains a nan value using numpy.isnan() and boolean indexing:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe same is a bit more immediate in pandas, where we can use the dropna() method to remove rows with any missing values:\n\n\n\n\n\n\nNotice that the resulting DataFrame still retains the column names and indices.\nTo completely forget the indices of the original data, we can reset them using the reset_index() method:\n\n\n\n\n\n\nFrom the pandas DataFrame, we can easily convert it back to a numpy ndarray using the to_numpy() method:\n\n\n\n\n\n\nThis is also equivalent to accessing the values attribute of the DataFrame:\n\n\n\n\n\n\nThe to_numpy() method is preferred as it provides more options for controlling the conversion process. It is also a particular instance of the many to_...() methods that allow you to convert DataFrames in various formats:\n\n\n\n\n\n\nUseful methods that you may immediately recognise in their utility are:\n\nDataFrame.to_dict(): Converts the DataFrame to a dictionary.\nDataFrame.to_json(): Converts the DataFrame to a JSON string.\nDataFrame.to_excel(): Writes the DataFrame to an Excel file.\n\nDataFrame.to_csv(): Writes the DataFrame to a CSV file.\n\nWe can also operate in the opposite direction, converting a numpy ndarray to a pandas DataFrame using the pandas.DataFrame() constructor: for this purpose, we may want to specify the column names explicitly using the columns parameter.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Pandas vs Numpy"
    ]
  },
  {
    "objectID": "16/lecture_pandas_vs_numpy.html#indexing-and-slicing",
    "href": "16/lecture_pandas_vs_numpy.html#indexing-and-slicing",
    "title": "Pandas vs Numpy",
    "section": "Indexing and Slicing",
    "text": "Indexing and Slicing\nnumpy uses the familiar zero-based integer indexing that we have seen in lists and arrays. We can access elements using integer indices, and we can slice arrays using the colon (:) operator.\nFor the given array\n\n\n\n\n\n\nWe can pick various elements and slices:\n\n\n\n\n\n\nPandas dataframes have (as we have seen it) a quite different syntax for indexing and slicing.\nThe closest to numpy’s indexing is the .iloc[] method (integer locator), which allows integer-based indexing similar to numpy arrays.\n\n\n\n\n\n\nMore in general, pandas provides label based indexing using the .loc[] method, which allows us to access data using row and column labels.\nIn this case the index is numerical:\n\n\n\n\n\n\nAnd the columns are labelled with strings:\n\n\n\n\n\n\nSo we we can do the following:\n\n\n\n\n\n\n\nUsing [] in pandas without loc or iloc\nSome care needs to be taken when using the square brackets [] operator in pandas, as it can behave differently based on the context.\nWhen we use [] direftly with a DataFrame, it primarily serves two purposes: selecting columns and filtering rows.\nSelecting columns: When we pass a single string or a list of strings to [], it selects the corresponding columns from the DataFrame.\n\n\n\n\n\n\n\n\n\n\n\n\nFiltering rows: When we pass a boolean array or Series to [], it filters the rows based on the boolean values.\n\n\n\n\n\n\nOddly enough, if we pass an single integer pandas will interpret it as a column selection, not as a row selection as one might expect, and this will raise an error if there is no column with that name.\n\n\n\n\n\n\nImportant. These inconsistencies should motivate you to prefer .loc and .iloc for DataFrame indexing.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Pandas vs Numpy"
    ]
  },
  {
    "objectID": "16/lecture_pandas_vs_numpy.html#mathematical-operations-on-data-tables",
    "href": "16/lecture_pandas_vs_numpy.html#mathematical-operations-on-data-tables",
    "title": "Pandas vs Numpy",
    "section": "Mathematical operations on data tables",
    "text": "Mathematical operations on data tables\n\nBasic statistics\nNumpy arrays readily have a few mathematicla methods that operate element-wise on the array data, such as sum(), mean(), std(), etc.\nThey operate on rows or columns depending on the axis parameter:\n\naxis=0 indicates that the operation is performed column-wise (i.e., along rows).\naxis=1 indicates that the operation is performed row-wise (i.e., along columns).\n\n\n\n\n\n\n\nSimilar operations exist in pandas and work column-wise (default) or row-wise depending on the axis parameter as well.\n\n\n\n\n\n\n\n\n\n\n\n\nWe can also compute standard devations:\n\n\n\n\n\n\nOh, the two appear to provide quantitatively different results! This may come to a surprise, but it is an example of how different libraries may implement similar functions with slightly different conventions, and how important it is to read the documentation carefully.\nFor numpy this is\n\n\n\n\n\n\nIf you read the documentation correctl you will find that numpy.std() by default computes the standard deviation with with degree of freedom ddof=0, which is the population standard deviation\n\\[\\sigma = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\mu)^2}\\]\nThis is different from the sample standard deviation formula, which uses ddof=1\n\\[s = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{N} (x_i - \\bar{x})^2}\\]\nThe two have different meanings:\n\nthe population standard deviation is used when you have data for the entire population\nthe sample standard deviation is used when you have a sample from a larger population and want to estimate the population standard deviation.\n\npandas by default uses the sample standard deviation formula (ddof=1).\nIn order to match the two results, we can specify ddof=0 in the function calls\n\n\n\n\n\n\n\n\nMore general mathematical operations\nNumpy has a large set of mathematical functions that can be applied element-wise to arrays, such as np.sin(), np.exp(), np.log(), etc.\nWhat if we want to apply these functions to pandas DataFrames?\nWe can surely create new columns by applying numpy functions to existing columns:\n\n\n\n\n\n\nWe can even apply the functions to the entire DataFrame, and numpy will apply them element-wise:\n\n\n\n\n\n\nThese are fast operations because they are vectorized.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Pandas vs Numpy"
    ]
  },
  {
    "objectID": "16/lecture_pandas_vs_numpy.html#views-vs-copies-a-critical-difference",
    "href": "16/lecture_pandas_vs_numpy.html#views-vs-copies-a-critical-difference",
    "title": "Pandas vs Numpy",
    "section": "Views vs Copies: A Critical Difference",
    "text": "Views vs Copies: A Critical Difference\nWhen working with numpy arrays and pandas DataFrames, understanding the distinction between views and copies is crucial to avoid unexpected behavior.\nA view is a reference to the original data structure - modifying a view will change the original data.\nA copy is an independent duplicate - modifying a copy leaves the original unchanged.\nThis distinction is particularly important when subsetting data or performing operations that might create either views or copies.\n\nViews and copies in NumPy\nIn numpy, slicing creates views by default. This is done for memory efficiency, but it means that modifying a slice will affect the original array.\n\n\n\n\n\n\nNotice that modifying the slice changed the original array! This is because sliced is a view of original, not an independent copy.\nWe can verify this using np.shares_memory():\n\n\n\n\n\n\nTo create an independent copy that won’t affect the original, use the .copy() method explicitly:\n\n\n\n\n\n\n\n\nViews and copies in Pandas\nThe situation in pandas is more complex. Pandas tries to avoid unnecessary copying for performance, but the behavior is not always obvious.\nChained indexing (using multiple [] operations in sequence) can be particularly problematic and may trigger a SettingWithCopyWarning.\n\n\n\n\n\n\nIf we try to filter rows and then modify the result, pandas may issue a warning because it’s unclear whether we’re modifying a view or a copy:\n\n\n\n\n\n\nBest practice 1: Use .copy() explicitly when you want to work with a subset independently:\n\n\n\n\n\n\nBest practice 2: If you want to modify the original DataFrame directly, use .loc[] in a single operation:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLibrary\nDefault behavior\nHow to get a copy\nWhen it matters\n\n\n\n\nNumPy\nSlicing creates views\nUse .copy() explicitly\nWhen modifying slices\n\n\nPandas\nComplex (depends on operation)\nUse .copy() or .loc[]\nWhen subsetting and modifying",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Pandas vs Numpy"
    ]
  },
  {
    "objectID": "16/lecture_pandas_vs_numpy.html#interoperability-with-plotting",
    "href": "16/lecture_pandas_vs_numpy.html#interoperability-with-plotting",
    "title": "Pandas vs Numpy",
    "section": "Interoperability with Plotting",
    "text": "Interoperability with Plotting\nWhile plotting libraries like matplotlib can work directly with pandas DataFrames, there are situations where converting to numpy arrays is useful or even necessary.\nLet’s explore when and why you might convert data for plotting purposes.\n\nPlotting directly with pandas vs numpy\nBoth approaches work, but have different advantages:\n\n\n\n\n\n\nBoth approaches produce identical plots. The pandas approach is more concise for simple plots, while the numpy approach can be clearer when you need the data for other operations.\nFor example, create contour plots to represent fields over a grid can be more straightforward using numpy arrays.\nIn the example below, we take tabulated data, arrange it into a grid using a pivot table, with x and y coordinates as columns and rows, get (x,y) pairs via numpy.meshgrid(), and then plot the contour using matplotlib.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Pandas vs Numpy"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html",
    "href": "16/exercises_pandas_vs_numpy.html",
    "title": "Numpy vs Pandas: Exercises",
    "section": "",
    "text": "We explore a numerical dataset freely avaible under MIT license on Kaggle, a platform for data science competitions and datasets.\nThe dataset focuses on solar system objects and contains several attributes.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-1-extracting-numpy-arrays",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-1-extracting-numpy-arrays",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 1: Extracting numpy arrays",
    "text": "Exercise 1: Extracting numpy arrays\n\nSelect the columns semimajorAxis, density, and gravity from the DataFrame df and convert them into a numpy array named np_solar_data.\nThen, design a test (e.g. using an if/else statement or an assert statement) to verify that np_solar_data is indeed a numpy array. Notice that simply printing the type of np_solar_data is not a test!\n\nReminder. An assert statement is a way to test if a condition in your code returns True. If not, the program will raise an AssertionError.\nIt uses the keyword assert followed by the condition to test and an optional error message.\nassert condition, \"Error message if condition is False\"\nHint. If the conversion to numpy array is correct, then the type of np_solar_data should be np.ndarray",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-2-extracting-basic-statistics",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-2-extracting-basic-statistics",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 2: Extracting basic statistics",
    "text": "Exercise 2: Extracting basic statistics\n\nUsing the numpy array np_solar_data created in Exercise 1, compute the mean and standard deviation for each of the three columns: semimajorAxis, density, and gravity. Store the results in two separate numpy arrays named mean_values and std_values.\nCan you find way to compute these same statistics from the original DataFrame df without converting it to a numpy array? Store these results in two separate pandas Series named mean_series and std_series.\nInspect the stand deviations in the numpy and pandas result. Can you choose parameters such that the results are identical?",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-3-understanding-pandas-settingwithcopywarning",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-3-understanding-pandas-settingwithcopywarning",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 3: Understanding Pandas SettingWithCopyWarning",
    "text": "Exercise 3: Understanding Pandas SettingWithCopyWarning\nYou want to analyze only the rocky planets by creating a subset and adding a calculated column.\nTask: - Create a subset rocky_planets from df filtering for isPlanet == True and density &gt; 3 - Add a new column mass_estimate to rocky_planets calculated as density * gravity - Observe any warnings that pandas displays - What does the warning mean? Why did it appear?",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-4-when-views-and-copies-actually-break-your-code",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-4-when-views-and-copies-actually-break-your-code",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 4: When Views and Copies Actually Break Your Code",
    "text": "Exercise 4: When Views and Copies Actually Break Your Code\nThe warning is nice, but let’s see actual unexpected behavior! You’ll try to add a column categorizing planets as inner or outer solar system objects, but the code won’t work as expected.\nNote. There are two types of chained indexing, both problematic:\n\nColumn-then-row: df['column'][condition] = value (select column, then filter)\nRow-then-column: df[condition]['column'] = value (filter rows, then select column)\n\nBoth create intermediate objects (potential copies) before assignment, so modifications may be lost!\n\nReload the DataFrame: df = pd.read_csv(\"kaggle_solar/sol_data.csv\")\nFilter for planets: planets = df[df['isPlanet'] == True].copy()\nInitialize a column: planets['outer_planet'] = False\nTry row-then-column chained indexing: planets[planets['semimajorAxis'] &gt; 5]['outer_planet'] = TrueNote: Objects with semimajorAxis &gt; 5 AU are beyond Jupiter’s orbit (outer solar system).\nCheck if it worked, then use .loc[] to do it correctly",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-5-extracting-data-and-processing-it-with-numpy-and-matpltolib",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-5-extracting-data-and-processing-it-with-numpy-and-matpltolib",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 5: extracting data and processing it with numpy and matpltolib",
    "text": "Exercise 5: extracting data and processing it with numpy and matpltolib\nWe now want to extract data and process it with numpy functions.\n\nUsing numpy or pandas extract the escape velocity and the mass in kg for all the objects and plot them in a scatter plot using matplotlib.\nConsider that th escape velocity can be calculated as follows:\n\n\\[\nv_{e s c}=\\sqrt{2 g R}\n\\]\nwhere: - \\(g\\) is the surface gravity - \\(R\\) is the radius of the object in\n\nImprove your plotting to illustrate this relationship explicitly (e.g. by changing the scales, plotting guides to the eye, etc.). Note that the radius is in km, the escape veclocity is in m/s, and the gravity is in m/s².",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-6-string-operations---pandas-vs-numpy",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-6-string-operations---pandas-vs-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 6: String Operations - Pandas vs NumPy",
    "text": "Exercise 6: String Operations - Pandas vs NumPy\nExtract planet names and convert them to uppercase using both pandas and numpy approaches.\nTask: - Filter the DataFrame to get only planets (where isPlanet == True) - Extract the planet names (column eName) using pandas methods and convert them to uppercase (UPPERCASE). Store this in a variable named pandas_upper_names - Now try to do the same using numpy: convert the eName column to a numpy array and apply string operations:\n- you can use a for loop to iterate through the names and convert them to uppercase (e.g. via list comprehension)\n- or use `numpy.char` sub module for vectorized string operations\n\nWhich approach is easier for string operations?",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-7-grouping-and-aggregation---pandas-vs-numpy",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-7-grouping-and-aggregation---pandas-vs-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 7: Grouping and Aggregation - Pandas vs NumPy",
    "text": "Exercise 7: Grouping and Aggregation - Pandas vs NumPy\nCalculate the mean density for planets vs non-planets using pandas groupby, then try to replicate this in numpy.\nTask: - Use pandas groupby() to compute the mean density grouped by isPlanet (True/False) - Now try to replicate this result using only numpy arrays: - Convert the relevant columns to numpy arrays - Manually separate the data into two groups (planets and non-planets) - Calculate the mean for each group\n\nWhich approach is more convenient? What happens if you need to group by multiple columns?",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-8-correlation-matrix---pandas-vs-numpy",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-8-correlation-matrix---pandas-vs-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 8: Correlation Matrix - Pandas vs NumPy",
    "text": "Exercise 8: Correlation Matrix - Pandas vs NumPy\nCalculate the correlation matrix for physical properties using pandas and numpy.\nBackground:\nThe covariance between two variables \\(X\\) and \\(Y\\) measures how they vary together: \\[\\text{cov}(X,Y) = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_i - \\bar{x})(y_i - \\bar{y})\\]\nThe correlation coefficient normalizes covariance by the standard deviations: \\[r_{XY} = \\frac{\\text{cov}(X,Y)}{\\sigma_X \\sigma_Y}\\] where \\(\\sigma_X = \\sqrt{\\frac{1}{n-1}\\sum(x_i - \\bar{x})^2}\\) is the standard deviation.\nCorrelation ranges from -1 (perfect negative) to +1 (perfect positive), with 0 meaning no linear relationship.\nStandardization: Transform each variable to have mean = 0 and standard deviation = 1: \\[z_i = \\frac{x_i - \\bar{x}}{\\sigma_x}\\]\nAfter standardization, the correlation matrix can be computed using matrix multiplication.\nTask:\n\nUse pandas .corr() to compute the correlation matrix for density, gravity, and meanRadius\nNow replicate this using numpy by following these steps:\n\nExtract data: Get the three columns as an \\(n \\times 3\\) matrix \\(X\\) (n rows/objects, 3 columns/variables)\nCenter the data: Subtract the mean of each column to get \\(X_{\\text{centered}}\\) (remember that you can use the axis parameter in numpy functions)\nStandardize: Divide each centered column by its standard deviation to get \\(Z\\) (the standardized matrix)\nCompute correlation: The correlation matrix is \\(R = \\frac{1}{n-1} Z^T Z\\) (a \\(3 \\times 3\\) matrix)\nCompare with the pandas result\n\n\nNote: The matrix \\(Z\\) has shape \\((n \\times 3)\\), so \\(Z^T\\) has shape \\((3 \\times n)\\), and their product gives a \\((3 \\times 3)\\) correlation matrix.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "16/exercises_pandas_vs_numpy.html#exercise-9-creating-a-theoretical-model-visualization-with-numpy",
    "href": "16/exercises_pandas_vs_numpy.html#exercise-9-creating-a-theoretical-model-visualization-with-numpy",
    "title": "Numpy vs Pandas: Exercises",
    "section": "Exercise 9: Creating a Theoretical Model Visualization with NumPy",
    "text": "Exercise 9: Creating a Theoretical Model Visualization with NumPy\nCreate a contour plot showing how escape velocity varies with surface gravity and radius, then overlay real solar system objects.\nScientific Background:\nFrom \\(v_{esc} = \\sqrt{2gR}\\), we can predict escape velocity for any combination of surface gravity \\(g\\) and radius \\(R\\). This creates a “phase space” showing where different types of objects fall.\nTask:\n\nCreate a grid of theoretical values using numpy:\n\nUse np.linspace() to create arrays of gravity values (0.1 to 30 m/s²) and radius values (100 to 100,000 km)\nUse np.meshgrid() to create 2D grids for both variables\nCalculate theoretical escape velocity on this grid using the formula (remember unit conversions!)\n\nCreate a contour plot:\n\nUse plt.contourf() or plt.contour() to plot the theoretical escape velocity\nAdd contour labels showing escape velocity values\nFilter the dataset for the 8 true planets: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\nOverlay these planets on the contour plot using plt.scatter()\n\nInterpretation:\n\nDo the 8 planets fall on the theoretical contours?\nCan you identify different groups among the planets (rocky vs gas/ice giants)?\n\n\nUse the matplotlib documentation at https://matplotlib.org/stable/contents.html if needed.",
    "crumbs": [
      "Home",
      "16 Pandas vs Numpy",
      "Numpy vs Pandas: Exercises"
    ]
  },
  {
    "objectID": "10/exercises_multid.html",
    "href": "10/exercises_multid.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "10/exercises_multid.html#working-with-multidimensional-arrays---exercises",
    "href": "10/exercises_multid.html#working-with-multidimensional-arrays---exercises",
    "title": "",
    "section": "Working with Multidimensional Arrays - Exercises",
    "text": "Working with Multidimensional Arrays - Exercises\nThese are pair programming exercises. Work with a partner to solve the following problems using multidimensional arrays in your chosen programming language.\n\nPart 1\nPart 2\n\nDiscuss your solutions and reasoning with your partner before moving on to the next exercise."
  },
  {
    "objectID": "10/exercises_part1.html",
    "href": "10/exercises_part1.html",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#pair-programming-part-1",
    "href": "10/exercises_part1.html#pair-programming-part-1",
    "title": "Creating a mask containing a circle",
    "section": "",
    "text": "As part of this activity you have been split into pairs/threes and are being asked to create code together using a technique called pair programming.\nFor this exercise, one of you will be writing the code (the driver) and the others will be directing and advising on what should be written (the navigator(s)) with lots of discussion in between. Decide between yourselves who would like each role to start with. For the second exercise you will swap some of your roles but carry on working together in the same pairs/threes.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#how-a-mask-could-be-used",
    "href": "10/exercises_part1.html#how-a-mask-could-be-used",
    "title": "Creating a mask containing a circle",
    "section": "How a mask could be used",
    "text": "How a mask could be used\nIn this workbook, we want you to create a mask. By this we mean a square (or rectangular) grid of zeros (0s) and ones (1s) with values of 1 in the positions you want to keep and values of 0 in the positions you don’t. This mask could then be applied to another image for example:\n \nWithin the mask the edge would look something like this:\n\nwhere the thin green line represents the edge of where the real circle would be.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1.html#circle-within-a-square",
    "href": "10/exercises_part1.html#circle-within-a-square",
    "title": "Creating a mask containing a circle",
    "section": "Circle within a square",
    "text": "Circle within a square\nThe mask we want you to create should represent a circle (defined within the grid). The equation governing the edge of a circle is:\n\\[ (x-x_0)^2 + (y-y_0)^2 = r^2 \\]\nwhere\n\n\\(x\\), \\(y\\) are the x, y positions within the grid\n\\(x_0\\), \\(y_0\\) are the centre of the circle\n\\(r\\) is the radius\n\nFor example, for a circle with radius of 2 with a centre point of (4, 3), if we looked at position (5, 4), then this would be inside that circle since:\n\\[\\sqrt{((5 - 4)^2 + (4 - 3)^2)}\\] \\[ = \\sqrt{1^2 + 1^2} = \\sqrt{1 + 1} = \\sqrt{2} = 1.41\\]\nwhich is less than the radius of 2.\n\n\nExercise A\nCreate a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n\n\n\n\n\n\n\n\n\n\n\nTake time to discuss this but if you are really stuck, there is a hint notebook available which shows how you would create a mask for a square rather than a circle as an example of how you could approach this.\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)\n\nMore complex:\n\nWhat are some other ways a mask could created using the features of numpy?\n\n\nLook other numpy (np) functions e.g.\n\nmeshgrid() - link (or ogrid() - link)\nwhere() - link functions.\n\nLook at the more complex ways that numpy.array objects can be indexed - indexing multi-dimensional arrays\nConsider how values can be assigned to whole sections of an array directly.",
    "crumbs": [
      "Home",
      "10 Multidimensional Arrays",
      "Creating a mask containing a circle"
    ]
  },
  {
    "objectID": "10/exercises_part1_solutions.html",
    "href": "10/exercises_part1_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)"
  },
  {
    "objectID": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "href": "10/exercises_part1_solutions.html#pair-programming-part-1",
    "title": "Answers",
    "section": "",
    "text": "Create a 100 x 100 square grid containing a circle. The centre of the circle should be at position x = 40, y = 50 and have a radius of 10. Call your output circular_mask.\nBreak this idea down into the different steps: - Start by creating an array - how could you create an array of the right shape? - How would you turn the equation above into code? - How would you evaluate one (x, y) position to start with? - How do you move on to evaluate every position? - …\nImportant note: For numpy remember that the axes are opposite to what you would expect for an x-y grid - they store data as row-major meaning you access the row as the first index (y) and the column as the second index (x). This means position arr[1, 0] would be at position (0, 1) in x, y co-ordinates rather than (1, 0) as you may expect.\nWhen completed, you can use the plotting code below to show your mask. This uses a matplotlib function called imshow (documentation; example from image gallery) which can plot your 2D data on a grid.\n\n\n\n\n\n\n\n\n\n\n\n\n\nExtended:\n\nConsider how you could create a mask for a rectangle rather than a circle (or a square)"
  },
  {
    "objectID": "10/hint1_mask.html",
    "href": "10/hint1_mask.html",
    "title": "Hint 1 - creating a square mask",
    "section": "",
    "text": "Example: Creating a 100 x 100 grid containing a square where the centre of that square is at (80, 40) and the width is 30.\nTo check whether an (x, y) position is within the square we want to define, we want to evaluate if these two conditions are both satisfied: \\[|x - x_0| = w/2\\] and \\[|y - y_0| = w/2\\]\nwhere - \\(x\\), \\(y\\) are the x, y positions within the grid - \\(x_0\\), \\(y_0\\) are the centre of the square - \\(w\\) - is both the full width and height of the square - \\(| |\\) means the magnitude of the difference\nThis code will show one way to create a mask which contains a square. This will take the most direct approach and evaluate every index in the 2D array one at a time.\n\n\n\n\n\n\nStart by creating an array of zeros for our overall grid:\n\n\n\n\n\n\nNext we can define the parameters we need for the square:\n\n\n\n\n\n\nSo, to check whether a given position is within our mask (the square we are defining), we need to find a way to use our equations above and write them in code.\nWe’ve created a grid of size of 100 x 100 so, as an example, let’s use the position (50, 50) for our grid:\n\n\n\n\n\n\nNow we can build this up to look at every element in the 2D array we have created and check whether this is inside the square (we will leave the value as 0) or outside the square (we will set the value to 1). To do this we can loop through every column and every row and check the result of our conditions:\n\n\n\n\n\n\nWe don’t need an else block here because the array we have defined already contains zeros. This means if our conditin doesn’t match we don’t need to update the values within the array.\nWe could check where our mask has been set to 1 using the np.where function. For a two-dimensional array like square_mask, this will return two arrays containing the positions of the match - one for the first dimension and one for the second dimension.\nEach pair of values (one in the first array and one the second) represents a 2D position in our array:\n\n\n\n\n\n\nWe can look at this mask using matplotlib and a plotting option called imshow (documentation; example from image gallery):\n\n\n\n\n\n\nIn this plot, the white represents the values in the mask (values of 1) and the black represents the values outside the mask (values of 0).\n\n\nExtended: Leveraging numpy functionality\nAn alternative and more efficient way to do this would be to leverage the properties of numpy arrays and the available numpy functions and indexing.\nWe can start in the same way and create our array of zeros of the right shape\n\n\n\n\n\n\nWe can represent the pixel position for our x and y dimensions using numbers for 0 to 99 (for x) and 0 to 99 (for y) since our shape is 100 x 100.\nWe can then create a pair of 2D grids, X and Y, to match to the shape of our mask using a function called np.meshgrid(). This stretches our x and y coordinate values to create our 2D numpy arrays.\n\n\n\n\n\n\nWe can find the positions where our conditions are met within our grid using the np.where() function. From here we can filter our mask using integer array indexing and change these values from 0 to 1 within our mask."
  },
  {
    "objectID": "10/exercises_part2_solutions.html",
    "href": "10/exercises_part2_solutions.html",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\n\n\n\n\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\n\n\n\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed.\n\n\n\nThe inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\n\n\n\n\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\n\n\n\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html"
  },
  {
    "objectID": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "href": "10/exercises_part2_solutions.html#masking-a-galaxy",
    "title": "Answers",
    "section": "",
    "text": "One application for using a geometrical mask, like you have been developing, is when looking at images containing real objects like galaxies. In this case we have accessed a galaxy image as a png file. In reality, there are more specific file formats traditionally used to store this type of astronomical data but the principle is similar.\nWe can open the image of the galaxy using the following code. This uses a module called pillow (imported as PIL) which understands how to read image files and we can import the Image sub-module to open this file. We can convert that image into a numpy array object.\n\n\n\n\n\n\nIf we look at the shape of this image data we can see that is is 3D - it has height and width but also three entries for colour: Red, Green and Blue (RGB).\n\n\n\n\n\n\nAs we did when plotting the mask, we can use a matplotlib function called imshow() to display this image, but this time it knows how to interpret the three colour channels to display an image with colour.\n\n\n\n\n\n\nThis is sprial galaxy NGC 253, also known as the Sculpter Galaxy. If we wanted to mask this image so that only the pixels related to the galaxy remain, we can do so using a geometrical mask for an ellipse - similiar to the circular mask you have been developing but with a few additional parameters needed."
  },
  {
    "objectID": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "href": "10/exercises_part2_solutions.html#creating-an-elliptical-mask",
    "title": "Answers",
    "section": "",
    "text": "The inside_ellipse function defined below will allow you to check whether an (x, y) value is inside an ellipse with the supplied parameters. As we’ve seen in previous weeks, functions can be used to avoid having to repeat code.\n\n\n\n\n\n\n\n\nTo understand the parameters that can be passed to the inside_ellipse() function we need to consider the form of an ellipse. The equation govering the edge of an ellipse is similiar to a circle but instead of one radius, \\(r\\), there are now two parameters \\(a\\) and \\(b\\) defined as the semi-major and semi-minor axes (naming can be the other way round depending on which is larger).\nFor an ellipse centred at (\\(x_{0}\\), \\(y_{0}\\)) and with the semi-major axis parallel to the x-axis the equation of the edge of the ellipse would be:\n\\[ \\frac{(x-x_0)^2}{a^2} + \\frac{(y-y_0)^2}{b^2} = 1 \\]\nThis would look something like:\n\nHowever, for our example we also need to consider an ellipse at an angle away from the x-axis, alpha (\\(\\alpha\\)). The edge for this ellipse can be calculated using the full equation:\n\\[ \\frac{((x-x_0)\\cos\\alpha + (y-y_0)\\sin\\alpha)^2}{a^2} + \\frac{((x-x_0)\\sin\\alpha - (y-y_0)\\cos\\alpha)^2}{b^2} = 1 \\]\nThis would look like:\n\nThe parameters needed to use inside_ellipse function are: the centre of the ellipse, the semi-major and semi-minor axes and the angle, \\(\\alpha\\). For example:\n\n\n\n\n\n\n\n\n\n\nFor our example of the galaxy the parameters for a suitable ellipse are as follows:\n\ncentre position \\(x_0\\), \\(y_0\\) at (500, 470)\nsemi-major axis, \\(a\\), of 365\nsemi-minor axis, \\(b\\), of 70\nangle alpha, \\(\\alpha\\), of 38 degrees\n\n\nUse the inside_ellipse function to create an elliptical mask which could be used to mask the galaxy image so only the galaxy is included.\nApply this mask to each of the (R, G, B) channels of the image im (recall this is a 3D np.array object). Call the masked image im_masked.\n\nAs above, you can use the plotting code below which uses the matplotlib function imshow() to plot the 3D im_masked object as a colour image (or to plot a 2D image for one colour channel)."
  },
  {
    "objectID": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "href": "10/exercises_part2_solutions.html#calculating-the-magnitude",
    "title": "Answers",
    "section": "",
    "text": "Now that we have masked out just the pixels related to the galaxy, one parameter we can derive is to calculate the galaxy brightness for a particular colour. Normally, this would not be done from an RGB image but we can use this to make an approximation.\nThe magnitude of an object is given by the equation:\n\\[ m_{AB} = -2.5\\log_{10}(f_v) + 8.90 \\]\nwhere: - \\(m_{AB}\\) is the magnitude (on the AB scale) - \\(f_v\\) is the spectral flux density (in units of Jansky, \\(Jy\\))\n\n\n\nWe can calculate an approximation of the spectral flux density, \\(f_{v}\\), by summing the pixel values from our image and by applying a scale factor of \\(2.8\\times10^{-7}\\).\nFrom your masked image of the galaxy, and using the details above, calculate an approximation of the magnitude of the Blue channel (the third channel) from this image.\nHow does this compare to the true value for “B (AB)”? - available here: http://simbad.u-strasbg.fr/simbad/sim-id?Ident=NGC+253&jsessionid=262A420D60A8A4D72D3384528AA0980A.main\nHint: - Additional numpy functions which will be useful: - sum() - https://numpy.org/doc/stable/reference/generated/numpy.sum.html - log10() - https://numpy.org/doc/stable/reference/generated/numpy.log10.html"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "href": "slides/08_working_numpy_slides.html#array-indexing-slicing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Array Indexing & Slicing",
    "text": "Array Indexing & Slicing\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nimport numpy as np\narr = np.array([10, 20, 30, 40, 50])\n\n# Integer indexing\nprint(\"Element at index 1:\", arr[1])\n\n# Basic slicing\nprint(\"Slice [1:4]:\", arr[1:4])\nAdvanced slicing:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nprint(\"Every other element:\", arr[::2])\nprint(\"Last three elements:\", arr[-3:])\nprint(\"Reversed array:\", arr[::-1])"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#views-vs-copies",
    "href": "slides/08_working_numpy_slides.html#views-vs-copies",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Views vs Copies",
    "text": "Views vs Copies\nSlicing creates views (shared data):\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nslice_view = arr[2:5]\nslice_view[0] = 99\nprint(\"Original after view modification:\", arr)\nCreating independent copies:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\narr = np.array([10, 20, 30, 40, 50])  # Reset\narr_copy = arr[2:5].copy()\narr_copy[0] = 100\nprint(\"Copy:\", arr_copy)\nprint(\"Original unchanged:\", arr)"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#boolean-indexing",
    "href": "slides/08_working_numpy_slides.html#boolean-indexing",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Boolean Indexing",
    "text": "Boolean Indexing\nFilter data with conditions:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\narr = np.array([1, 2, 3, 4, 5, 6])\nthreshold = 3\n\nbool_mask = arr &gt; threshold\nprint(\"Boolean mask:\", bool_mask)\nprint(\"Filtered values:\", arr[bool_mask])\nUsing np.where:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Get indices where condition is True\nindices = np.where(arr &gt; threshold)[0]\nprint(\"Indices:\", indices)\n\n# Conditional selection\nresult = np.where(arr &gt; 3, arr, 0)\nprint(\"Conditional result:\", result)"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#generating-sequences",
    "href": "slides/08_working_numpy_slides.html#generating-sequences",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Generating Sequences",
    "text": "Generating Sequences\nnp.arange - step-based:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nprint(\"Integers:\", np.arange(0, 10, 2))\nprint(\"Floats:\", np.arange(0.0, 1.0, 0.2))\nnp.linspace - count-based:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nprint(\"5 points from 0 to 1:\", np.linspace(0, 1, 5))\n\narange: Use when you know the step size\nlinspace: Use when you know the number of points"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#filled-arrays",
    "href": "slides/08_working_numpy_slides.html#filled-arrays",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Filled Arrays",
    "text": "Filled Arrays\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Create arrays with specific values\nzeros_arr = np.zeros(5)\nones_arr = np.ones(4)\nfull_arr = np.full(3, 7)\n\nprint(\"Zeros:\", zeros_arr)\nprint(\"Ones:\", ones_arr)\nprint(\"Full:\", full_arr)\nSame shape as existing array:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\ntemplate = np.array([1, 2, 3])\nprint(\"Zeros like:\", np.zeros_like(template))\nprint(\"Ones like:\", np.ones_like(template))\nprint(\"Full like:\", np.full_like(template, 9))"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#random-number-generation",
    "href": "slides/08_working_numpy_slides.html#random-number-generation",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Random Number Generation",
    "text": "Random Number Generation\nInitialize generator (for reproducibility):\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nrng = np.random.default_rng(seed=123)\nDifferent distributions:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Random integers\nprint(\"Random integers:\", rng.integers(0, 100, size=5))\n\n# Uniform floats [0, 1)\nprint(\"Uniform [0,1):\", rng.random(5))\n\n# Normal distribution\nnormal_samples = rng.normal(loc=0, scale=1, size=5)\nprint(\"Normal samples:\", normal_samples)"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "href": "slides/08_working_numpy_slides.html#pseudo-random-numbers",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Pseudo-Random Numbers",
    "text": "Pseudo-Random Numbers\nComputers are deterministic - they use algorithms to generate “pseudo-random” sequences\nLinear Congruential Generator example: \\[x_{n+1} = (a \\times x_n + c) \\bmod m\\]\nKey concept: Seeds enable reproducibility\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Same seed = same sequence\nrng1 = np.random.default_rng(seed=42)\nrng2 = np.random.default_rng(seed=42)\n\nprint(\"RNG1:\", rng1.integers(0, 10, size=3))\nprint(\"RNG2:\", rng2.integers(0, 10, size=3))  # Same output!"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#performance-tips",
    "href": "slides/08_working_numpy_slides.html#performance-tips",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Performance Tips",
    "text": "Performance Tips\nPreallocate for efficiency:\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Less efficient: generate one at a time\n# for _ in range(1000):\n#     val = rng.integers(0, 100)\n\n# More efficient: preallocate\nprealloc = rng.integers(0, 100, size=1000)\n# Then use values from prealloc array\nMemory vs Speed tradeoff: - Small tasks: 100-1,000 elements - Medium tasks: 10,000-100,000 elements\n- Large tasks: 1,000,000+ elements"
  },
  {
    "objectID": "slides/08_working_numpy_slides.html#key-takeaways",
    "href": "slides/08_working_numpy_slides.html#key-takeaways",
    "title": "Working with NumPy: Indexing and Random Data",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nViews share data, copies are independent\nBoolean indexing enables powerful data filtering\narange vs linspace serve different use cases\nRandom generators need seeds for reproducibility\nPreallocating arrays improves performance\nChoose array generation method based on your needs"
  },
  {
    "objectID": "slides/test_output.html",
    "href": "slides/test_output.html",
    "title": "Introduction to Coding and Data Analysis",
    "section": "",
    "text": "list_ex = [1, 2, 3, 4]\nprint(list_ex)\nimport numpy as np\n#notice that we explicitly call the np.array()\narr_ex = np.array([1, 2, 3, 4]) \nprint(arr_ex)\nWe are going to see these differences in detail."
  },
  {
    "objectID": "slides/test_output.html#arrays-from-lists",
    "href": "slides/test_output.html#arrays-from-lists",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Arrays from lists",
    "text": "Arrays from lists\nA purely numerical list can readily be converted to an array.\n\nimport numpy as np\n# Create array from list\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\nprint(arr1)\n\n. . .\nThe type of the elements yields the data type of the array\n\nprint(arr1.dtype)\n\n\nTry and change the list1 object to contain only integers and see the change!"
  },
  {
    "objectID": "slides/test_output.html#array-properties",
    "href": "slides/test_output.html#array-properties",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Array properties",
    "text": "Array properties\nArrays possess plenty of properties.\nThese are accessed with the . notation1.\n\nprint(f\"Data type: {arr1.dtype}\")\nprint(f\"Shape: {arr1.shape}\")\nprint(f\"Shape: {arr1.size}\")\n\nFor now, we consider only 1d arrays, i.e. sequences. Their length is is their size and corresponds to the first element of the property shape."
  },
  {
    "objectID": "slides/test_output.html#accessing-array-elements",
    "href": "slides/test_output.html#accessing-array-elements",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Accessing array elements",
    "text": "Accessing array elements\nSimilarly to lists, we access an element in an array via zero-based indexing\n\nprint(arr1[0])    # First element\nprint(arr1[-1])   # Last element\n\nAgain, similarly to lists, we can access regions of the array via slicing\n\nprint(arr1[3:6])  # Elements from index 3 to 6"
  },
  {
    "objectID": "slides/test_output.html#element-wise-operations",
    "href": "slides/test_output.html#element-wise-operations",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe main motivation to use arrays is that lists are cumbersome when performing maths.\nSuppose we have a list and want to double all of its elements:\n\nlist1 = [1,2,3,4]\n\nWe need to loop over all of them and create a new list\n\nlist2 = []\nfor item in list1:\n    list2.append(2*item)\nprint(list2)\n\nIn fact, we can do this in a slightly more compact way using list comprehension\n\nlist2 = [item*2 for item in list1]\n\nStill, an explicit loop is needed. Loops in Python are slow."
  },
  {
    "objectID": "slides/test_output.html#element-wise-operations-1",
    "href": "slides/test_output.html#element-wise-operations-1",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe numpy syntax avoids the explicit Python loop.\n\narr1 = np.array(list1)\narr2 = 2*arr1\nprint(arr2)\n\nThis is not just a cosmetic change: under the hood numpy uses an efficient architecture that performs operations in compiled code, making it much faster than Python loops."
  },
  {
    "objectID": "slides/test_output.html#performance-advantage",
    "href": "slides/test_output.html#performance-advantage",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Performance advantage",
    "text": "Performance advantage\nThis performance difference can be tracked explicitly.\nWe create a large list and a large array with identical content\n\n# Create a large list and array\nlarge_list = list(range(1_000_000))\nlarge_array = np.array(large_list)\n\nAnd then track the time for the two operations\n\nimport time\n#  Track the time taken for the list multiplication\nstart = time.time()\nlist_result = [x * 2 for x in large_list]\nend = time.time()\nprint(f\"List comprehension time: {end - start:.5f} seconds\")\n\n# Time array multiplication\nstart = time.time()\narray_result = large_array * 2\nend = time.time()\nprint(f\"NumPy array time: {end - start:.5f} seconds\")"
  },
  {
    "objectID": "slides/test_output.html#general-mathematical-functions",
    "href": "slides/test_output.html#general-mathematical-functions",
    "title": "Introduction to Coding and Data Analysis",
    "section": "General mathematical functions",
    "text": "General mathematical functions\nThe multiplication we performed earlier is done element-wise: every element is update according to teh same rule.\nWe can apply plenty of element-wise operations to the arrays.\nMany of these are available as numpy functions directly accessed from the np. module\n\n# Element-wise functions\nprint(f\"Square root: {np.sqrt(arr1)}\")\nprint(f\"Mean: {np.mean(arr1)}\")\nprint(f\"Cosine: {np.cos(arr1)}\")\n\n. . .\nThe operations do not modify the original array, but produce new copies\n\narr2 = arr1*3/2 + 5\nprint(f\"Original: {arr1}\")\nprint(f\"Modified: {arr2}\")"
  },
  {
    "objectID": "slides/test_output.html#sums",
    "href": "slides/test_output.html#sums",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Sums",
    "text": "Sums\nOther convenent numpy functions allow you to accumulate values without loops.\nAssume we have an array \\(x\\)\n\nx = np.array([1,2,3,4,5,6,7,8])\n\nSums\n\\[\nS = \\sum_{i=1}^{n} x_i\n\\]\nIn NumPy, this is translated as:\n\nS = np.sum(x)\nprint(S)"
  },
  {
    "objectID": "slides/test_output.html#sums-1",
    "href": "slides/test_output.html#sums-1",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Sums",
    "text": "Sums\nCumulative sums\nA cumulative sum is a sequence where each element is the sum of all previous elements up to that position. \\[\ny_i = \\sum_{j=1}^{i} x_j\n\\]\nIn NumPy, this is translated as:\n\n y = np.cumsum(x)\n print(y)"
  },
  {
    "objectID": "slides/test_output.html#example-molecular-masses",
    "href": "slides/test_output.html#example-molecular-masses",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Example: molecular masses",
    "text": "Example: molecular masses\nLet’s consider the formula for the molecular mass of a compound:\n\\[\nM = \\sum_{i=1}^{n} a_i m_i\n\\]\nwhere\n\n\\(a_i\\) is the number of atoms of element \\(i\\)\n\\(m_i\\) is the atomic mass of element \\(i\\)\n\n. . .\nWith numpy, you can compute this as:\n\na = np.array([2, 1, 4])      # Number of atoms for each element\nm = np.array([12.01, 1.01, 16.00])  # Atomic masses (e.g., C, H, O)\nM = np.sum(a * m)\nprint(f\"Molecular mass: {M}\")"
  },
  {
    "objectID": "slides/test_output.html#operations-between-arrays",
    "href": "slides/test_output.html#operations-between-arrays",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Operations between arrays",
    "text": "Operations between arrays\nYou can perform arithmetic operations directly between arrays of the same shape. Operations like addition, subtraction, multiplication, and division are applied element-wise.\nFor example:\nElement-wise operations:\n\nadded = arr1 + arr2\nmultiplied = arr1 * arr2\nprint(f\"Added: {added}\")\nprint(f\"Multiplied: {multiplied}\")\n\n. . .\nNote: Arrays must have compatible shapes!\n\narr3 = np.array([1, 2, 3])\narr4 = np.array([4, 5])\nresult = arr3 + arr4"
  },
  {
    "objectID": "slides/test_output.html#combining-arrays",
    "href": "slides/test_output.html#combining-arrays",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Combining arrays",
    "text": "Combining arrays\nWith lists, the + operator concatenated different lists. Since for arrays the sign + corresponds to true mathematical addition, a dedicated concatenation function exists:\n\ncombined = np.concatenate([arr1, arr2])\nprint(f\"Unique elements: {combined}\")\n\nMany other variations of concatenation exist. Consult the documentation."
  },
  {
    "objectID": "slides/test_output.html#key-takeaways",
    "href": "slides/test_output.html#key-takeaways",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy arrays are optimized for numerical operations\nElement-wise operations work implicitly\nPerformance benefits for large datasets\nMathematical functions apply to entire arrays\nShape compatibility required for operations\nChoose the right tool for your task"
  },
  {
    "objectID": "slides/test_output.html#footnotes",
    "href": "slides/test_output.html#footnotes",
    "title": "Introduction to Coding and Data Analysis",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nuse . and then TAB to see all of the properties↩︎"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "href": "slides/09_intro_matplotlib_slides.html#introduction-to-matplotlib",
    "title": "Plotting with matplotlib",
    "section": "Introduction to matplotlib",
    "text": "Introduction to matplotlib\nmatplotlib - Powerful Python library for creating visualizations\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nKey concepts: - Figure: The canvas - Axes: The x-y plotting area - Object-oriented approach (recommended)\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nfig, ax = plt.subplots()  # Create figure and axes"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "href": "slides/09_intro_matplotlib_slides.html#two-plotting-approaches",
    "title": "Plotting with matplotlib",
    "section": "Two Plotting Approaches",
    "text": "Two Plotting Approaches\nPyplot (MATLAB-style):\nplt.plot(x, y)  # Direct plotting\nObject-oriented (Recommended):\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nfig, ax = plt.subplots()\nax.plot(x, y)  # Plot using axes object\nWhy object-oriented? - More explicit control - Better for complex plots - Modern best practice"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "href": "slides/09_intro_matplotlib_slides.html#basic-plot-types",
    "title": "Plotting with matplotlib",
    "section": "Basic Plot Types",
    "text": "Basic Plot Types\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Sample data\nrng = np.random.default_rng(seed=124)\nx = np.arange(1, 20, 2)\ny1 = x**2\ny2 = x**2 + rng.normal(size=len(x))*50\n\nfig, ax = plt.subplots()\nax.plot(x, y1, label=\"Line plot\")        # Line plot\nax.scatter(x, y2, label=\"Scatter plot\")  # Scatter plot\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "href": "slides/09_intro_matplotlib_slides.html#customizing-appearance",
    "title": "Plotting with matplotlib",
    "section": "Customizing Appearance",
    "text": "Customizing Appearance\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nfig, ax = plt.subplots(figsize=(8, 4))\n\n# Styling options\nax.plot(x, y1, color=\"slategrey\", linestyle=\"--\", linewidth=2)\nax.scatter(x, y2, color=\"indianred\", marker='+', s=60)\n\n# Labels and limits\nax.set_xlabel(\"X values\")\nax.set_ylabel(\"Y values\")\nax.set_xlim(0, 20)\nax.set_title(\"Customized Plot\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "href": "slides/09_intro_matplotlib_slides.html#common-style-options",
    "title": "Plotting with matplotlib",
    "section": "Common Style Options",
    "text": "Common Style Options\nColors: Named colors, hex codes, RGB - color=\"red\", color=\"#FF0000\", color=(1,0,0)\nLine styles: - linestyle=\"-\" (solid), \"--\" (dashed), \":\" (dotted)\nMarkers: - marker=\"o\" (circle), \"+\" (plus), \"^\" (triangle)\nTransparency: - alpha=0.7 (70% opaque)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "href": "slides/09_intro_matplotlib_slides.html#legends-and-annotations",
    "title": "Plotting with matplotlib",
    "section": "Legends and Annotations",
    "text": "Legends and Annotations\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nfig, ax = plt.subplots()\n\nax.plot(x, y1, label=\"Fitted line\", color=\"blue\", linestyle=\"--\")\nax.scatter(x, y2, label=\"Measurements\", color=\"red\", marker='o')\n\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\") \nax.legend()  # Uses the label parameters\nax.set_title(\"Plot with Legend\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histograms",
    "href": "slides/09_intro_matplotlib_slides.html#histograms",
    "title": "Plotting with matplotlib",
    "section": "Histograms",
    "text": "Histograms\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Generate random data\nrng = np.random.default_rng(seed=68)\ndata1 = rng.normal(0, 1, 5000)\ndata2 = rng.normal(1, 1.5, 1000)\n\nfig, ax = plt.subplots()\nbins = np.arange(-4, 6, 0.3)\n\nax.hist(data1, bins=bins, alpha=0.7, color=\"skyblue\", \n        density=True, label=\"Dataset 1\")\nax.hist(data2, bins=bins, alpha=0.7, color=\"orange\", \n        density=True, label=\"Dataset 2\")\n\nax.set_xlabel(\"Value\")\nax.set_ylabel(\"Density\")\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "href": "slides/09_intro_matplotlib_slides.html#histogram-options",
    "title": "Plotting with matplotlib",
    "section": "Histogram Options",
    "text": "Histogram Options\nKey parameters: - bins: Number or explicit bin edges - alpha: Transparency (0-1) - density: Normalize to show probability density - histtype: ‘bar’, ‘step’, ‘stepfilled’\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nfig, ax = plt.subplots()\nax.hist(data1, bins=30, alpha=0.6, histtype='step', \n        color='purple', linewidth=2)"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "href": "slides/09_intro_matplotlib_slides.html#multiple-plots-on-same-axes",
    "title": "Plotting with matplotlib",
    "section": "Multiple Plots on Same Axes",
    "text": "Multiple Plots on Same Axes\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\nfig, ax = plt.subplots(figsize=(10, 5))\n\n# Multiple data series\nx_vals = np.linspace(0, 2*np.pi, 100)\ny1 = np.sin(x_vals)\ny2 = np.cos(x_vals)\ny3 = np.sin(2*x_vals)\n\nax.plot(x_vals, y1, label=\"sin(x)\")\nax.plot(x_vals, y2, label=\"cos(x)\", linestyle='--')\nax.scatter(x_vals[::10], y3[::10], label=\"sin(2x)\", marker='o')\n\nax.legend()\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "href": "slides/09_intro_matplotlib_slides.html#anatomy-of-a-figure",
    "title": "Plotting with matplotlib",
    "section": "Anatomy of a Figure",
    "text": "Anatomy of a Figure\n\nMatplotlib anatomy shows the components: Figure, Axes, Labels, Legend, Ticks, etc.Key components: - Figure: Overall container - Axes: Plot area with data - Axis labels: x/y descriptions\n- Ticks: Scale markers - Legend: Data series identification"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "href": "slides/09_intro_matplotlib_slides.html#figure-size-and-layout",
    "title": "Plotting with matplotlib",
    "section": "Figure Size and Layout",
    "text": "Figure Size and Layout\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Control figure size\nfig, ax = plt.subplots(figsize=(12, 6))\n\n# Multiple subplots (brief example)\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))\nax1.plot([1, 2, 3], [1, 4, 2])\nax2.scatter([1, 2, 3], [2, 1, 3])\nax1.set_title(\"Plot 1\")\nax2.set_title(\"Plot 2\")"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#best-practices",
    "href": "slides/09_intro_matplotlib_slides.html#best-practices",
    "title": "Plotting with matplotlib",
    "section": "Best Practices",
    "text": "Best Practices\n\nAlways label your axes\nUse legends for multiple data series\nChoose appropriate plot types for your data\nControl figure size for readability\nUse colors wisely - consider colorblind accessibility\nKeep it simple - don’t over-decorate\n\n#| caption: \"▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+[\"\n# Good example\nfig, ax = plt.subplots(figsize=(8, 5))\nax.plot(x, y1, label=\"Data\")\nax.set_xlabel(\"Time (s)\")\nax.set_ylabel(\"Amplitude (V)\")\nax.set_title(\"Signal vs Time\")\nax.legend()"
  },
  {
    "objectID": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "href": "slides/09_intro_matplotlib_slides.html#key-takeaways",
    "title": "Plotting with matplotlib",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nmatplotlib is the standard Python plotting library\nObject-oriented approach with fig, ax is recommended\nCustomization options for colors, styles, markers\nMultiple plot types: line, scatter, histogram\nAlways annotate with labels, legends, titles\nPractice with different plot types and styling options"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#aims",
    "href": "slides/07_intro_numpy_slides.html#aims",
    "title": "The numpy module",
    "section": "Aims",
    "text": "Aims\nBy the end of this lecture, you will be able to:\n\nExplain what the NumPy module is and why it is used\nCreate and manipulate NumPy arrays\nPerform element-wise operations and mathematical functions on arrays\nCompare NumPy arrays with Python lists in terms of performance and functionality\nUse basic aggregation and array manipulation functions in NumPy"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "href": "slides/07_intro_numpy_slides.html#what-is-numpy",
    "title": "The numpy module",
    "section": "What is numpy?",
    "text": "What is numpy?\nNumPy is a Python library that makes working with numbers and large collections of data fast and easy.\n\nComplete description at https://numpy.orgIt provides special array objects and tools for doing math efficiently, which is useful for data analysis and scientific computing.\n\nIt is imported in your session using the following command\nimport numpy\n\n\nWe will follow a common practice and use a shorthand with the as syntax\nimport numpy as np\n\n\nSo np will always mean numpy for us."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-vs-lists",
    "title": "The numpy module",
    "section": "Arrays vs lists",
    "text": "Arrays vs lists\n\n\nPython Lists\n\nOrdered, Mutable\n\nMixed data types\nExplicit operations needed\nSlower performance\n\n\nNumPy Arrays\n\nOrdered, Mutable\nOne data type per array\nElement-wise operations\nFast & memory efficient\n\n\n\n\n\nlist_ex = [1, 2, 3, 4]\nprint(list_ex)\n\nimport numpy as np\n#notice that we explicitly call the np.array()\narr_ex = np.array([1, 2, 3, 4]) \nprint(arr_ex)\n\nWe are going to see these differences in detail."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "href": "slides/07_intro_numpy_slides.html#arrays-from-lists",
    "title": "The numpy module",
    "section": "Arrays from lists",
    "text": "Arrays from lists\nA purely numerical list can readily be converted to an array.\nimport numpy as np\n# Create array from list\nlist1 = [1.,1.,2.,3.,5.,8.]\narr1 = np.array(list1)\nprint(arr1)\n\nThe type of the elements yields the data type of the array\nprint(arr1.dtype)\n\nTry and change the list1 object to contain only integers and see the change!"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#array-properties",
    "href": "slides/07_intro_numpy_slides.html#array-properties",
    "title": "The numpy module",
    "section": "Array properties",
    "text": "Array properties\nArrays possess plenty of properties.\nThese are accessed with the . notation1.\nprint(f\"Data type: {arr1.dtype}\")\nprint(f\"Shape: {arr1.shape}\")\nprint(f\"Shape: {arr1.size}\")\nFor now, we consider only 1d arrays, i.e. sequences. Their length is is their size and corresponds to the first element of the property shape.\nuse . and then TAB to see all of the properties"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "href": "slides/07_intro_numpy_slides.html#accessing-array-elements",
    "title": "The numpy module",
    "section": "Accessing array elements",
    "text": "Accessing array elements\nSimilarly to lists, we access an element in an array via zero-based indexing\nprint(arr1[0])    # First element\nprint(arr1[-1])   # Last element\nAgain, similarly to lists, we can access regions of the array via slicing\nprint(arr1[3:6])  # Elements from index 3 to 6"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe main motivation to use arrays is that lists are cumbersome when performing maths.\nSuppose we have a list and want to double all of its elements:\nlist1 = [1,2,3,4]\nWe need to loop over all of them and create a new list\nlist2 = []\nfor item in list1:\n    list2.append(2*item)\nprint(list2)\nIn fact, we can do this in a slightly more compact way using list comprehension\nlist2 = [item*2 for item in list1]\nStill, an explicit loop is needed. Loops in Python are slow."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "href": "slides/07_intro_numpy_slides.html#element-wise-operations-1",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe numpy syntax avoids the explicit Python loop.\narr1 = np.array(list1)\narr2 = 2*arr1\nprint(arr2)\nThis is not just a cosmetic change: under the hood numpy uses an efficient architecture that performs operations in compiled code, making it much faster than Python loops."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#performance-advantage",
    "href": "slides/07_intro_numpy_slides.html#performance-advantage",
    "title": "The numpy module",
    "section": "Performance advantage",
    "text": "Performance advantage\nThis performance difference can be tracked explicitly.\nWe create a large list and a large array with identical content\n# Create a large list and array\nlarge_list = list(range(1_000_000))\nlarge_array = np.array(large_list)\nAnd then track the time for the two operations\nimport time\n#  Track the time taken for the list multiplication\nstart = time.time()\nlist_result = [x * 2 for x in large_list]\nend = time.time()\nprint(f\"List comprehension time: {end - start:.5f} seconds\")\n\n# Time array multiplication\nstart = time.time()\narray_result = large_array * 2\nend = time.time()\nprint(f\"NumPy array time: {end - start:.5f} seconds\")"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "href": "slides/07_intro_numpy_slides.html#general-mathematical-functions",
    "title": "The numpy module",
    "section": "General mathematical functions",
    "text": "General mathematical functions\nThe multiplication we performed earlier is done element-wise: every element is update according to teh same rule.\nWe can apply plenty of element-wise operations to the arrays.\nMany of these are available as numpy functions directly accessed from the np. module\n# Element-wise functions\nprint(f\"Square root: {np.sqrt(arr1)}\")\nprint(f\"Mean: {np.mean(arr1)}\")\nprint(f\"Cosine: {np.cos(arr1)}\")\n\nThe operations do not modify the original array, but produce new copies\narr2 = arr1*3/2 + 5\nprint(f\"Original: {arr1}\")\nprint(f\"Modified: {arr2}\")"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums",
    "href": "slides/07_intro_numpy_slides.html#sums",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nOther convenent numpy functions allow you to accumulate values without loops.\nAssume we have an array \\(x\\)\nx = np.array([1,2,3,4,5,6,7,8])\nSums\n\\[\nS = \\sum_{i=1}^{n} x_i\n\\]\nIn NumPy, this is translated as:\nS = np.sum(x)\nprint(S)"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#sums-1",
    "href": "slides/07_intro_numpy_slides.html#sums-1",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nCumulative sums\nA cumulative sum is a sequence where each element is the sum of all previous elements up to that position. \\[\ny_i = \\sum_{j=1}^{i} x_j\n\\]\nIn NumPy, this is translated as:\n y = np.cumsum(x)\n print(y)"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "href": "slides/07_intro_numpy_slides.html#example-molecular-masses",
    "title": "The numpy module",
    "section": "Example: molecular masses",
    "text": "Example: molecular masses\nLet’s consider the formula for the molecular mass of a compound:\n\\[\nM = \\sum_{i=1}^{n} a_i m_i\n\\]\nwhere\n\n\\(a_i\\) is the number of atoms of element \\(i\\)\n\\(m_i\\) is the atomic mass of element \\(i\\)\n\n\nWith numpy, you can compute this as:\na = np.array([2, 1, 4])      # Number of atoms for each element\nm = np.array([12.01, 1.01, 16.00])  # Atomic masses (e.g., C, H, O)\nM = np.sum(a * m)\nprint(f\"Molecular mass: {M}\")"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "href": "slides/07_intro_numpy_slides.html#operations-between-arrays",
    "title": "The numpy module",
    "section": "Operations between arrays",
    "text": "Operations between arrays\nYou can perform arithmetic operations directly between arrays of the same shape. Operations like addition, subtraction, multiplication, and division are applied element-wise.\nFor example:\nElement-wise operations:\nadded = arr1 + arr2\nmultiplied = arr1 * arr2\nprint(f\"Added: {added}\")\nprint(f\"Multiplied: {multiplied}\")\n\nNote: Arrays must have compatible shapes!\narr3 = np.array([1, 2, 3])\narr4 = np.array([4, 5])\nresult = arr3 + arr4"
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#combining-arrays",
    "href": "slides/07_intro_numpy_slides.html#combining-arrays",
    "title": "The numpy module",
    "section": "Combining arrays",
    "text": "Combining arrays\nWith lists, the + operator concatenated different lists. Since for arrays the sign + corresponds to true mathematical addition, a dedicated concatenation function exists:\ncombined = np.concatenate([arr1, arr2])\nprint(f\"Unique elements: {combined}\")\nMany other variations of concatenation exist. Consult the documentation."
  },
  {
    "objectID": "slides/07_intro_numpy_slides.html#key-takeaways",
    "href": "slides/07_intro_numpy_slides.html#key-takeaways",
    "title": "The numpy module",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy arrays are optimized for numerical operations\nElement-wise operations work implicitly\nPerformance benefits for large datasets\nMathematical functions apply to entire arrays\nShape compatibility required for operations\nChoose the right tool for your task"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html",
    "href": "07/exercises_numpy_solutions.html",
    "title": "numpy Exercises",
    "section": "",
    "text": "These exercises test your understanding of the NumPy concepts covered in the introduction notebook."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "href": "07/exercises_numpy_solutions.html#exercise-1-import-and-basic-array-creation",
    "title": "numpy Exercises",
    "section": "Exercise 1: Import and Basic Array Creation",
    "text": "Exercise 1: Import and Basic Array Creation\nTask: Import NumPy with the standard import command and create a NumPy array from the list [2, 4, 6, 8, 10, 12]. Print the array, its data type, and its shape."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "href": "07/exercises_numpy_solutions.html#exercise-2-array-indexing-and-slicing",
    "title": "numpy Exercises",
    "section": "Exercise 2: Array Indexing and Slicing",
    "text": "Exercise 2: Array Indexing and Slicing\nTask: Using the array you created in Exercise 1:\n\nPrint the first element\nPrint the last element\nPrint elements from index 2 to 4 (inclusive of 2, exclusive of 5)\nPrint every second element"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-3-element-wise-operations",
    "title": "numpy Exercises",
    "section": "Exercise 3: Element-wise Operations",
    "text": "Exercise 3: Element-wise Operations\nTask: Create a NumPy array arr = np.array([1, 4, 9, 16, 25]). Perform the following operations and print the results:\n\nMultiply each element by 3\nAdd 10 to each element\nCalculate the square root of each element\nApply the sine function to each element"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "href": "07/exercises_numpy_solutions.html#exercise-4-array-operations-with-two-arrays",
    "title": "numpy Exercises",
    "section": "Exercise 4: Array Operations with Two Arrays",
    "text": "Exercise 4: Array Operations with Two Arrays\nTask: Create two NumPy arrays:\n\narr1 = np.array([1, 2, 3, 4, 5])\narr2 = np.array([10, 20, 30, 40, 50])\n\nPerform element-wise operations and print the results:\n\nAdd the two arrays\nSubtract arr1 from arr2\nMultiply the two arrays\nDivide arr2 by arr1"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "href": "07/exercises_numpy_solutions.html#exercise-5-shape-mismatch-error",
    "title": "numpy Exercises",
    "section": "Exercise 5: Shape Mismatch Error",
    "text": "Exercise 5: Shape Mismatch Error\nTask: Create two arrays with different lengths:\n\narr_a = np.array([1, 2, 3, 4])\narr_b = np.array([10, 20])\n\nTry to add these arrays together. What happens? Write the code and explain the error in a comment."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-6-reductive-operations",
    "title": "numpy Exercises",
    "section": "Exercise 6: Reductive Operations",
    "text": "Exercise 6: Reductive Operations\nTask: Create a NumPy array data = np.array([12, 8, 15, 3, 7, 20, 11, 9]). Calculate and print:\n\nThe sum of all elements\nThe mean (average) of all elements\nThe maximum value\nThe minimum value\nThe standard deviation"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "href": "07/exercises_numpy_solutions.html#exercise-7-array-manipulation",
    "title": "numpy Exercises",
    "section": "Exercise 7: Array Manipulation",
    "text": "Exercise 7: Array Manipulation\nTask: Create a NumPy array numbers = np.array([5, 2, 8, 1, 9, 3]). Perform the following operations:\n\nSort the array and print the result\nCalculate the cumulative sum and print the result\nCreate a new array with duplicates: with_duplicates = np.array([5, 2, 8, 1, 9, 3, 5, 2, 1]) and find the unique elements"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-8-list-vs-numpy-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 8: List vs NumPy Comparison",
    "text": "Exercise 8: List vs NumPy Comparison\nTask: Compare the flexibility of lists vs NumPy arrays:\n\nCreate a Python list containing mixed data types: mixed_list = [1, 'hello', 3.14, True]\nTry to create a NumPy array from this list. What happens to the data types?\nCreate a list of numbers: num_list = [1, 2, 3, 4, 5]\nTry to multiply the entire list by 2 using num_list * 2. What happens?\nCreate a NumPy array from the same numbers and multiply by 2. Compare the results."
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "href": "07/exercises_numpy_solutions.html#exercise-9-performance-comparison",
    "title": "numpy Exercises",
    "section": "Exercise 9: Performance Comparison",
    "text": "Exercise 9: Performance Comparison\nTask: Compare the performance of list comprehension vs NumPy operations:\n\nImport the time module\nCreate a range of 50,000 numbers using numpy np.arange()\nTime how long it takes to square each number using a list comprehension, i.e. the syntax [x**2 for x in myarray]\nTime how long it takes to square each number using NumPy operations\nCalculate and print how many times faster the NumPy operation is"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "href": "07/exercises_numpy_solutions.html#exercise-10-complex-operations",
    "title": "numpy Exercises",
    "section": "Exercise 10: Complex Operations",
    "text": "Exercise 10: Complex Operations\nTask: Create a NumPy array representing angles in degrees: angles_deg = np.array([0, 30, 45, 60, 90, 120, 180])\n\nConvert these angles to radians (hint: multiply by π/180, use np.pi)\nCalculate the sine and cosine of each angle\nVerify that sin²(x) + cos²(x) = 1 for each angle (use np.sin() and np.cos())\nPrint all results"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "href": "07/exercises_numpy_solutions.html#challenge-exercise-temperature-conversion",
    "title": "numpy Exercises",
    "section": "Challenge Exercise: Temperature Conversion",
    "text": "Challenge Exercise: Temperature Conversion\nTask: You have temperature readings in Celsius: celsius_temps = np.array([0, 10, 20, 25, 30, 35, 40])\n\nConvert all temperatures to Fahrenheit using the formula: F = (C × 9/5) + 32\nConvert all temperatures to Kelvin using the formula: K = C + 273.15\nCalculate the temperature range (max - min) for each scale\n\n\n\n\n\n\n\n## Challenge 2: Kinetic energy\n\n**Task** Given arrays of mass (kg) and velocity (m/s) for several objects:\n```python\n# copy and paste this code below\nmasses = np.array([2.0, 1.5, 3.0, 0.5])      # in kilograms\nvelocities = np.array([10.0, 20.0, 15.0, 5.0]) # in meters per second\n```\n\n1. Calculate the kinetic energy $K$ for each object using the formula: \n\n$$K =  \\dfrac{1}{2}m v^2$$\n\n2. Calculate the total kinetic energy of the system (sum of all objects)"
  },
  {
    "objectID": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "href": "07/exercises_numpy_solutions.html#challenge-3-temperature-analysis",
    "title": "numpy Exercises",
    "section": "Challenge 3: Temperature Analysis",
    "text": "Challenge 3: Temperature Analysis\nTask: Given a NumPy array of daily temperatures for 30 days:\ntemperatures = np.array([23.5, 24.0, 21.2, 25.6, 22.8, 23.9, 26.1, 27.3, 21.7, 22.5,\n                         24.6, 25.8, 20.9, 22.3, 24.7, 26.0, 27.5, 21.0, 22.9, 24.8,\n                         25.9, 27.6, 20.8, 22.7, 24.5, 26.2, 27.7, 20.5, 22.6, 24.9])\nPerform the following tasks:\n\nFind the top 3 hottest days and their temperatures.\nCalculate the day-to-day percentage change in temperature."
  },
  {
    "objectID": "07/07_intro_numpy_slides.html",
    "href": "07/07_intro_numpy_slides.html",
    "title": "The numpy module",
    "section": "",
    "text": "By the end of this lecture, you will be able to:\n\nExplain what the NumPy module is and why it is used\nCreate and manipulate NumPy arrays\nPerform element-wise operations and mathematical functions on arrays\nCompare NumPy arrays with Python lists in terms of performance and functionality\nUse basic aggregation and array manipulation functions in NumPy"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#aims",
    "href": "07/07_intro_numpy_slides.html#aims",
    "title": "The numpy module",
    "section": "",
    "text": "By the end of this lecture, you will be able to:\n\nExplain what the NumPy module is and why it is used\nCreate and manipulate NumPy arrays\nPerform element-wise operations and mathematical functions on arrays\nCompare NumPy arrays with Python lists in terms of performance and functionality\nUse basic aggregation and array manipulation functions in NumPy"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#what-is-numpy",
    "href": "07/07_intro_numpy_slides.html#what-is-numpy",
    "title": "The numpy module",
    "section": "What is numpy?",
    "text": "What is numpy?\nNumPy is a Python library that makes working with numbers and large collections of data fast and easy.\n\n\n\nComplete description at https://numpy.org\n\n\nIt provides special array objects and tools for doing math efficiently, which is useful for data analysis and scientific computing.\n. . .\nIt is imported in your session using the following command\nimport numpy\n. . .\nWe will follow a common practice and use a shorthand with the as syntax\nimport numpy as np\nSo np will always mean numpy for us."
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#arrays-vs-lists",
    "href": "07/07_intro_numpy_slides.html#arrays-vs-lists",
    "title": "The numpy module",
    "section": "Arrays vs lists",
    "text": "Arrays vs lists\nPython Lists\n\nOrdered, Mutable\n\nMixed data types\nExplicit operations needed\nSlower performance\n\nNumPy Arrays\n\nOrdered, Mutable\nOne data type per array\nElement-wise operations\nFast & memory efficient\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe are going to see these differences in detail."
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#arrays-from-lists",
    "href": "07/07_intro_numpy_slides.html#arrays-from-lists",
    "title": "The numpy module",
    "section": "Arrays from lists",
    "text": "Arrays from lists\nA purely numerical list can readily be converted to an array.\n\n\n\n\n\n\n. . .\nThe type of the elements yields the data type of the array\n\n\n\n\n\n\n\nTry and change the list1 object to contain only integers and see the change!"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#array-properties",
    "href": "07/07_intro_numpy_slides.html#array-properties",
    "title": "The numpy module",
    "section": "Array properties",
    "text": "Array properties\nArrays possess plenty of properties.\nThese are accessed with the . notation1.\n\n\n\n\n\n\nFor now, we consider only 1d arrays, i.e. sequences. Their length is is their size and corresponds to the first element of the property shape."
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#accessing-array-elements",
    "href": "07/07_intro_numpy_slides.html#accessing-array-elements",
    "title": "The numpy module",
    "section": "Accessing array elements",
    "text": "Accessing array elements\nSimilarly to lists, we access an element in an array via zero-based indexing\n\n\n\n\n\n\nAgain, similarly to lists, we can access regions of the array via slicing"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#element-wise-operations",
    "href": "07/07_intro_numpy_slides.html#element-wise-operations",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe main motivation to use arrays is that lists are cumbersome when performing maths.\nSuppose we have a list and want to double all of its elements:\n\n\n\n\n\n\nWe need to loop over all of them and create a new list\n\n\n\n\n\n\nIn fact, we can do this in a slightly more compact way using list comprehension\n\n\n\n\n\n\nStill, an explicit loop is needed. Loops in Python are slow."
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#element-wise-operations-1",
    "href": "07/07_intro_numpy_slides.html#element-wise-operations-1",
    "title": "The numpy module",
    "section": "Element-wise Operations",
    "text": "Element-wise Operations\nThe numpy syntax avoids the explicit Python loop.\n\n\n\n\n\n\nThis is not just a cosmetic change: under the hood numpy uses an efficient architecture that performs operations in compiled code, making it much faster than Python loops."
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#performance-advantage",
    "href": "07/07_intro_numpy_slides.html#performance-advantage",
    "title": "The numpy module",
    "section": "Performance advantage",
    "text": "Performance advantage\nThis performance difference can be tracked explicitly.\nWe create a large list and a large array with identical content\n\n\n\n\n\n\nAnd then track the time for the two operations"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#general-mathematical-functions",
    "href": "07/07_intro_numpy_slides.html#general-mathematical-functions",
    "title": "The numpy module",
    "section": "General mathematical functions",
    "text": "General mathematical functions\nThe multiplication we performed earlier is done element-wise: every element is update according to teh same rule.\nWe can apply plenty of element-wise operations to the arrays.\nMany of these are available as numpy functions directly accessed from the np. module\n\n\n\n\n\n\n. . .\nThe operations do not modify the original array, but produce new copies"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#sums",
    "href": "07/07_intro_numpy_slides.html#sums",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nOther convenent numpy functions allow you to accumulate values without loops.\nAssume we have an array \\(x\\)\n\n\n\n\n\n\nSums\n\\[\nS = \\sum_{i=1}^{n} x_i\n\\]\nIn NumPy, this is translated as:"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#sums-1",
    "href": "07/07_intro_numpy_slides.html#sums-1",
    "title": "The numpy module",
    "section": "Sums",
    "text": "Sums\nCumulative sums\nA cumulative sum is a sequence where each element is the sum of all previous elements up to that position. \\[\ny_i = \\sum_{j=1}^{i} x_j\n\\]\nIn NumPy, this is translated as:"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#example-molecular-masses",
    "href": "07/07_intro_numpy_slides.html#example-molecular-masses",
    "title": "The numpy module",
    "section": "Example: molecular masses",
    "text": "Example: molecular masses\nLet’s consider the formula for the molecular mass of a compound:\n\\[\nM = \\sum_{i=1}^{n} a_i m_i\n\\]\nwhere\n\n\\(a_i\\) is the number of atoms of element \\(i\\)\n\\(m_i\\) is the atomic mass of element \\(i\\)\n\n. . .\nWith numpy, you can compute this as:"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#operations-between-arrays",
    "href": "07/07_intro_numpy_slides.html#operations-between-arrays",
    "title": "The numpy module",
    "section": "Operations between arrays",
    "text": "Operations between arrays\nYou can perform arithmetic operations directly between arrays of the same shape. Operations like addition, subtraction, multiplication, and division are applied element-wise.\nFor example:\nElement-wise operations:\n\n\n\n\n\n\n. . .\nNote: Arrays must have compatible shapes!"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#combining-arrays",
    "href": "07/07_intro_numpy_slides.html#combining-arrays",
    "title": "The numpy module",
    "section": "Combining arrays",
    "text": "Combining arrays\nWith lists, the + operator concatenated different lists. Since for arrays the sign + corresponds to true mathematical addition, a dedicated concatenation function exists:\n\n\n\n\n\n\nMany other variations of concatenation exist. Consult the documentation."
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#key-takeaways",
    "href": "07/07_intro_numpy_slides.html#key-takeaways",
    "title": "The numpy module",
    "section": "Key Takeaways",
    "text": "Key Takeaways\n\nNumPy arrays are optimized for numerical operations\nElement-wise operations work implicitly\nPerformance benefits for large datasets\nMathematical functions apply to entire arrays\nShape compatibility required for operations\nChoose the right tool for your task"
  },
  {
    "objectID": "07/07_intro_numpy_slides.html#footnotes",
    "href": "07/07_intro_numpy_slides.html#footnotes",
    "title": "The numpy module",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nuse . and then TAB to see all of the properties↩︎"
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html",
    "href": "09/fun_matplotlib_decoration.html",
    "title": "Add some decoration",
    "section": "",
    "text": "There are two options below of template plots to build upon: a tree and a snowman.\nAs a group or individually, decorate an image (or multiple images) and when completed you can save this figure to file (uncomment the appropriate cell to do so). This can then be downloaded from Noteable and uploaded to the Padlet with your group name:\nhttps://uob.padlet.org/fturci/adding-decorations-zk4khqfwj17l2377",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-tree",
    "title": "Add some decoration",
    "section": "Decorate a tree",
    "text": "Decorate a tree\nThe code below creates the outline of a tree which you can add your decoration to:",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "href": "09/fun_matplotlib_decoration.html#decorate-a-snowman",
    "title": "Add some decoration",
    "section": "Decorate a snowman",
    "text": "Decorate a snowman\nAs an alternative, the code below creates the outline of a snowman which you can add features to:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSome options in matplotlib\nHere are some examples of some matplotlib options and functionality that you could use:\n\n\n\n\n\n\n\n\nMore options\nColour options:\n\nhttps://matplotlib.org/3.1.0/gallery/color/named_colors.html\n\nMarker and line style options:\n\nhttps://matplotlib.org/stable/api/markers_api.html\nhttps://matplotlib.org/stable/gallery/lines_bars_and_markers/linestyles.html\n\nPatches (Rectangle, Circle, Polygon)\n\nhttps://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Rectangle.html\nhttps://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Polygon.html\nhttps://matplotlib.org/stable/api/_as_gen/matplotlib.patches.Circle.html\n\nOr look in the matplotlib gallery to see if anything provides inspiration:\n\nhttps://matplotlib.org/stable/gallery/index.html\n\n\nExtra Challenge: can you use random number generation to add detail to your picture?",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Add some decoration"
    ]
  },
  {
    "objectID": "09/exercises_plotting_data_from_file.html",
    "href": "09/exercises_plotting_data_from_file.html",
    "title": "Plotting data from file",
    "section": "",
    "text": "How can we use what we have learnt in the past few workshops to read data from a file? And how can we plot this?\nOne way to then plot this data would be to extract the index and/or multiple columns we are interested in plotting and use matplotlib as we have done before.\nAs an example, we’ll look at a new data file. This contains a simulation of the (fractional) concentration change for two species in a reaction, “A” and “B” where \\(A \\rightarrow B\\).\n\n\n\n\n\n\nIf we open this file more directly in Python when we looked at a text file) we can take quick look at the contents to see what this looks like:\n\n\n\n\n\n\nFrom printing out the first 200 characters, we can see this looks like a table of data with each column separated by spaces. This looks nicely formatted with a title row including the column names and no extra header rows.\nWe will see in the next year that there are dedicate packages to manipulate large tabulated files. However, for now we can exploit numpy as a quick and effective way to read such input.\n\n\n\n\n\n\nThis is a special kind of array called a structured array, because it has named fields. You can check this by querying the subproperties of the array:\n\n\n\n\n\n\nThese various names are the fields of the array, corresponding to the columns in the file. This syntax is reminiscent of what we have seen in the case of dictionaries, where keys are used to specific other objects stored in the dictionary.\n\n\n\n\n\n\nThis data also has a column for “Time” as the number of seconds elapsed.\n\n\n\n\n\n\nTo create a plot for time vs concentration of A, we can extract this data from our array\n\n\n\n\n\n\nWe could then use matplotlib to plot this:\n\n\n\n\n\n\nThis simulation shows a clean relationship as concentration decreases over time (in an exponential way).\nSuppose we want to filter our data and plot only concentrations less than 0.5. We can simply create a boolean array that masks the invalid data.\n\n\n\n\n\n\nHere we have filtered our data to include all fractional concentrations less than (or equal to) 0.5. Notice we have also matched our time values to plot to these concentrations by extracting the index from our new array concentration_A_low.\n\n\n\n\n\n\nYou can also see the slope is similiar (in fact it is the same) between our unfiltered and filtered data (this is due to the exponential relationship).\n\n\nExercise\n\nRe-plot the un-filtered graph created above and add another line to show concentration of B vs time from the data_kinetic_k0005 array on the same plot.\n\n\nCan you include a label for A and B?\n\n\nCalculate the the sum of the concentrations for these two columns (A and B).\nRe-plot the graph created in the previous question and add this sum as a third line.\n\n\nConsider: What does this sum tell us about “A” is decaying into “B”?",
    "crumbs": [
      "Home",
      "09 Introduction to Matplotlib",
      "Plotting data from file"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html",
    "href": "08/lecture_working_with_numpy.html",
    "title": "Indexing and Random Data Generation",
    "section": "",
    "text": "NumPy is a powerful library for numerical computing in Python, providing efficient multi-dimensional array operations and a wide range of mathematical functions. With NumPy, you can perform fast element-wise computations, advanced indexing, slicing, and generate random data for simulations and analysis.\nThis notebook illustrates array indexing, boolean arrays, generating sequences using np.arange and np.linspace, and generating random samples with NumPy’s random number generator.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "href": "08/lecture_working_with_numpy.html#array-indexing-slicing-views-and-copies",
    "title": "Indexing and Random Data Generation",
    "section": "Array indexing, slicing, views and copies",
    "text": "Array indexing, slicing, views and copies\nIndexing in NumPy allows you to access and modify individual elements or groups of elements within an array. You can use integer indices, slices, and even boolean arrays to select data efficiently. For example:\n\nInteger Indexing: Select a single element by its position.\nSlicing: Extract a range of elements.\nBoolean Indexing: Filter elements based on a condition.\n\n\nInteger indexing\nWe have already seen that the lements of an array are idnexed similarly to lists. The syntax simply requires you to enter the integer index of the element you want to access. For example, if you have an array arr, you can access the element at index 1 using arr[1]. You can also slice arrays using the same syntax as lists, such as arr[1:4] to get elements from index 1 to 3.\n\n\n\n\n\n\n\n\nSlicing\nSlicing allows you to extract a portion of an array by specifying a start index, an end index, and an optional step. The syntax is similar to that used for lists in Python. For example, arr[1:4] retrieves elements from index 1 to 3 (the end index is exclusive).\n\n\n\n\n\n\n\n\nAdvanced Slicing Techniques\nNumPy slicing can be extended beyond basic start and end indices:\n\nStep Size: Use a third parameter to specify the step, e.g., arr[::2] selects every other element.\nNegative Indices: Negative values index from the end, e.g., arr[-3:] gets the last three elements.\nReverse Slicing: Use a negative step to reverse an array, e.g., arr[::-1].\n\n\n\n\n\n\n\nSlicing creates views, not copies, so modifying a slice affects the original array. Use arr.copy() to create a copy if needed.\nA view is a new array object that looks at the same data as the original array. Changes made to a view will affect the original array, since they share the same underlying data. For example, arr[1:4] returns a view of arr, not a separate copy.\n\n\n\n\n\n\nSlices can be programmaticaly generated using the slice function, which allows you to create a slice object that can be reused. For example, s = slice(1, 4) creates a slice object that can be used as arr[s] to get the same result as arr[1:4].\n\n\n\n\n\n\nTo create an independent copy of an array (rather than a view), use the copy() method. For example, arr_copy = arr[1:4].copy() creates a new array with its own data, so changes to arr_copy will not affect the original arr. This is useful when you want to modify a subset of an array without altering the original data.\n\n\n\n\n\n\n\n\nBoolean Indexing\nBoolean indexing allows you to select elements from an array based on a condition. When you apply a condition to a NumPy array, it returns a boolean (an array that contains only True/False values ) array indicating which elements satisfy the condition. You can then use this boolean array to filter the original array, extracting only the elements that meet the criteria. This technique is powerful for data selection and analysis.\n\n\n\n\n\n\n\n\nUsing np.where for conditional selection\nThe np.where function in NumPy is a powerful tool for conditional selection and element-wise operations. It allows you to choose values from arrays based on a condition, returning indices or constructing new arrays.\n\nBasic usage:\nnp.where(condition) returns the indices where the condition is True.\n\n\n\n\n\n\n\nnp.where(arr &gt; threshold) returns a tuple because, for 1D arrays, it provides the indices where the condition is True. In NumPy, the output is always a tuple of arrays—one for each dimension of the input array. For a 1D array, it’s a single-element tuple containing the indices. For higher dimensions, it returns a tuple with arrays for each axis. This consistent tuple format makes it easy to handle multi-dimensional indexing.\nSo, for 1D arrays as the ones considered up to now, we should get the indices by extracting the first element of the tuple returned by np.where\n\n\n\n\n\n\n\nElement-wise selection:\nnp.where(condition, x, y) returns elements from x where the condition is True, and from y where it is False. Here the result is an array of the same shape as x and y, containing values from x where the condition is met, and from y otherwise. This is useful for creating new arrays based on conditions without using loops.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "href": "08/lecture_working_with_numpy.html#function-to-generate-numerical-arrays",
    "title": "Indexing and Random Data Generation",
    "section": "Function to generate numerical arrays",
    "text": "Function to generate numerical arrays\nNumPy provides automated methods for generating numerical sequences, which are essential for simulations, sampling, and creating structured data.\n\nGenerating sequences\nThe two most used functions for generating ordered numerical sequences in NumPy are np.arange and np.linspace.\n\nnp.arange(start, stop, step): Generates an array of evenly spaced values within a specified range. The start value is inclusive, while the stop value is exclusive. The step parameter defines the spacing between values.\nExample: np.arange(0, 10, 2) produces [0, 2, 4, 6, 8].\nnp.linspace(start, stop, num): Creates an array of num evenly spaced values between start and stop, inclusive. This is useful for generating a specific number of points in a range.\n\n\n\n\n\n\n\nMost importantly, these functions can be used to create arrays of any kinds of numerical data, including integers and floating-point numbers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotice that linspace is useful when we know the start and end value and the specific number of points we want to generate, while arange is useful when we know the start and end value and the step size between the points.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "href": "08/lecture_working_with_numpy.html#generating-filled-arrays",
    "title": "Indexing and Random Data Generation",
    "section": "Generating filled arrays",
    "text": "Generating filled arrays\nNumPy provides functions to create arrays filled with specific values, such as zeros, ones, or a constant value. These functions are useful for initializing arrays before performing computations.\nThe main functions for generating filled arrays are: - np.zeros(shape): Creates an array filled with zeros, where shape specifies the dimensions of the array. - np.ones(shape): Creates an array filled with ones. - np.full(shape, fill_value): Creates an array filled with a specified value (fill_value), where shape defines the dimensions of the array.\n- np.empty(shape): Creates an uninitialized array with the specified shape. The values in this array are not set to any particular value, so they may contain random data.\nThere are also functions that create arrays with the same shape and type as an existing array, which can be useful for initializing arrays that will be used in computations:\n\nnp.zeros_like(array): Creates an array of zeros with the same shape and type as the input array.\nnp.ones_like(array): Creates an array of ones with the same shape and type as the input array.\nnp.full_like(array, fill_value): Creates an array filled with a specified value, with the same shape and type as the input array.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#random-data-generation",
    "href": "08/lecture_working_with_numpy.html#random-data-generation",
    "title": "Indexing and Random Data Generation",
    "section": "Random Data Generation",
    "text": "Random Data Generation\nRandom data generation is essential for simulations, statistical modeling, and testing algorithms.\nFor example, you might want to generate random samples from a normal distribution to simulate real-world data or create random datasets for testing purposes. Or you may want to simulate the effect of measurement errors in your data analysis. Or you may want to sub-sample a large dataset randomly to take a representative sample without bias.\nTo do all this, one needs methods to sample numbers that possess the statistical properties of the desired distribution, such as uniform, normal, or binomial distributions.\nStrictly speaking (classical) computers are deterministic machines, meaning they follow a set of rules and produce the same output for the same input every time. We have therefore to use algorithms to produce sequences of numbers that mimic the properties of random numbers.\nThese are called pseudo-random numbers. Pseudo-random number generators (PRNGs) use algorithms to produce sequences of numbers that appear random but are actually deterministic.\nA simple and classic example of a pseudo-random number generator is the Linear Congruential Generator (LCG). The LCG produces a sequence of numbers using the recurrence relation:\n\\[x_{n+1} = (a \\times  x_{n} + c)\\,\\mathrm{mod}\\, m\\]\nwhere\n- \\(x_n\\) is the current value,\n- \\(a\\) is the multiplier,\n- \\(c\\) is the increment,\n- \\(m\\) is the modulus.\nIn vanilla Python this looks like the following custom function\n\n\n\n\n\n\n\n\n\n\n\n\nThis will generate a sequence of pseudo-random integers. The choice of parameters (a, c, m) affects the quality and period of the generator.\n\n\n\n\n\n\nThe seed is crucial: it is the initial value that starts the algorithm to determin the subsequent values in the sequence. By setting the seed, you can ensure that the sequence is reproducible, meaning that running the same code with the same seed will produce the same sequence of numbers every time.\nIn numpy, we do not need to implement our own LCG, as it provides a built-in random number generator that is based on the Mersenne Twister algorithm, which is a widely used and efficient pseudo-random numbwer generator.\nWhat we do instead is to use the numpy.random sub-module, which provides a wide range of functions for generating random numbers from various distributions, including uniform, normal, and binomial distributions.\nThe standard way to to use it is the following:\n\nfirst, one initialises a new kind of object called a random number generator (RNG) using np.random.default_rng(). This is a numpy object capable of generating random numbers from various distributions. It allows us in particular to set the seed and therefore ensure reproducibility.\n\n\n\n\n\n\n\nWe can do this at any point in our code, but it is a good practice to do it at the beginning of our script or notebook, so that we can ensure that all random numbers generated in the script are reproducible. Putting the generator elsewhere (for example, inside a function) could lead to unexpected results, as the generator would be re-initialised each time the function is called.\nOnce we have a generator we can access any of its method to sample numbers from various distributions\nFor example:\n\nIntegers\nTo sample uniformly distributed integers, we can use the integers method of the generator. This method allows us to specify a range and the number of integers to generate.\n\n\n\n\n\n\n\n\n[0-1) uniform floats\nTo sample uniformly distributed floats between 0 and 1, we can use the random method of the generator. This method generates random floats in the range [0.0, 1.0) (which means 0 included and 1 excluded).\n\n\n\n\n\n\nAlternatively, we can use the uniform method to sample uniformly distributed floats in a specified range. This method allows us to specify the lower and upper bounds of the range, as well as the number of samples to generate.\n\n\n\n\n\n\n\n\nNormal distribution\nTo sample from a normal distribution, we can use the normal method of the generator. This method allows us to specify the mean and standard deviation of the distribution, as well as the number of samples to generate. The generated samples will follow a normal (Gaussian) distribution with the specified parameters.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "href": "08/lecture_working_with_numpy.html#sampling-a-siingle-value",
    "title": "Indexing and Random Data Generation",
    "section": "Sampling a siingle value",
    "text": "Sampling a siingle value\nIf we only want to sample a single value, we can simply not specify the size parameter, or set it to 1. This will return a single value sampled from the specified distribution.\n\n\n\n\n\n\nHowever, this can sometimes be more computationally costly than generating a larger sample and then selecting a single value from it.\n\n\n\n\n\n\nThis is a good example of the tradeoff between memory usage and computational efficiency: in modern machines, memory is quite cheap, so it is often more efficient to preallocate a larger array and then sample from it, rather than generating a single value at a time.\nA good size for preallocated numbers depends on your use case and available memory. Typical choices are:\n\nSmall tasks: 100 to 1,000 elements\nMedium tasks: 10,000 to 100,000 elements\nLarge tasks: 1,000,000 or more elements\n\nFor most data analysis or simulation tasks, starting with 100,000 elements is practical and efficient. Always ensure the size fits within your system’s memory limits.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Indexing and Random Data Generation"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html",
    "href": "08/exercises_lecture_working_with_numpy.html",
    "title": "Working with numpy: Exercises",
    "section": "",
    "text": "Create a 1D NumPy array arr of integers from 10 to 19. Access the element at index 3.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with `numpy`: Exercises"
    ]
  },
  {
    "objectID": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "href": "08/exercises_lecture_working_with_numpy.html#exercise-9-problem-solving-with-numpy",
    "title": "Working with numpy: Exercises",
    "section": "Exercise 9: Problem solving with NumPy",
    "text": "Exercise 9: Problem solving with NumPy\nConsider the following problem:\n\nA panoramic wheel (a Ferris wheel) with a radius of 10 meters rotates anti-clockwise at a constant speed of 2 revolutions per minute. A passenger is seated in a car at the edge of the wheel. Calculate the trajectory of the passenger with respect to the center of the wheel for the duration of 30 seconds, with a time resolution of 2 seconds, assuming they start at the rightmost point of the wheel.\n\nThe problem is a two-dimensional problem. The passenger has coordinates \\(x(t), y(t)\\) and is performing uniform rotational motion, with angular velocity \\(\\omega\\) and radius \\(R\\).\nThe angle formed at which the passenger is located is \\(\\theta(t)\\) and simply evolves as\n\\[\\theta(t) = \\omega t +\\theta_0\\]\nwhere \\(\\theta_0\\) is the initial angle (\\(\\theta_0=0\\) in our case).\nHence, the trajectory is expressed by\n\\[\n\\begin{align}\nx(t) & = R\\cos\\theta(t) = R \\cos{\\omega t}+x_0\\\\\ny(t) & = R\\sin\\theta(t)  = R \\sin{\\omega t}+y_0\n\\end{align}\n\\]\nSo, we have all the theoretical knowledge that we need to solve the problem. How can we translate this into code?\nThe first approach is via using vanilla Python\n\n\n\n\n\n\nThe question now is: can you simpify this code by using NumPy? Your focus should be on avoiding for loops and using NumPy’s array operations instead.",
    "crumbs": [
      "Home",
      "08 Working with NumPy",
      "Working with `numpy`: Exercises"
    ]
  },
  {
    "objectID": "01/week_01_solutions.html",
    "href": "01/week_01_solutions.html",
    "title": "Week 1: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 1 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "01/week_01_solutions.html#beginner-basic-data-types",
    "href": "01/week_01_solutions.html#beginner-basic-data-types",
    "title": "Week 1: Solutions",
    "section": "Beginner: Basic Data Types",
    "text": "Beginner: Basic Data Types\nQuestion 1: The solution to the question is given below:\n\n\n\n\n\n\nQuestion 2: The solution to the question is given below:\n\n\n\n\n\n\nQuestion 3: The completed truth table for this question is:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\nTrue\nFalse\nTrue\n\n\nTrue\nTrue\nFalse\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\n\nAnd the code for this question is:\n\n\n\n\n\n\nQuestion 4: The solution to this question is given below:\n\n\n\n\n\n\nQuestion 5: The solution to this question is given by:\n\n\n\n\n\n\nQuestion 6: The solution to this question is given by:\n\n\n\n\n\n\nQuestion 7: A code block containing the examples from the question is given below:\n\n\n\n\n\n\nThe answers follow by standard boolean logic. The only difficult parts are determining the order of operations for the third example (python will interpret this as True or (False and False) rather than (True or False) and False) and the xor (^) on the fourth line.\nQuestion 8: The error in the code occurs when float(x + y) is run.\nWhen x and y are numeric, the + symbol is interpreted as addition and the result is cast to a float (e.g. if x=1 and y=5 as in the first example then x+y yeilds 6). However, if they are instead strings (as in the second example), then the + symbol is interpreted as concatenation rather than addition. Therefore, when x='2' and y='5', we get that 2+5 yeilds 25, not 7.\nThere are two approaches to resolving the issue. The first is to replace x='2' and y='5' with x=2 and y=5. The second, and preferred option, is to replace float(x + y) with float(x)+float(y) so there is no possibility that the + symbol is interpreted as concatenation here.\nQuestion 9: The first box is an assignment of the value 2 + 1 to a variable named three, so does not print anything. The second box prints true as the variable z = (1 + 2 == 3) is interpreted as a Boolean variable, and in Jupyter notebooks, if the last line of a box is simply a variable, with no assignment, then that variable is printed out. z is evaluated as True (as 1 + 2 does equal 3 in Python), so True is printed.\nFor the third box, False is printed as due to rounding errors 0.1 + 0.2 is evaluated to 0.30000000000000004 rather than 0.3. This is a cautionary note that floating point math is not perfect.\nQuestion 10: The final solution is given below:"
  },
  {
    "objectID": "01/week_01_solutions.html#intermediate-collections",
    "href": "01/week_01_solutions.html#intermediate-collections",
    "title": "Week 1: Solutions",
    "section": "Intermediate: Collections",
    "text": "Intermediate: Collections\nQuestion 1: The code for this question is given below:\n\n\n\n\n\n\nQuestion 2: The key to this question is that a list is ordered whilst a set is unordered. When the list is converted to a set, it’s ordering is lost, and when converted back to a list it is now given in increasing (numerical) order by default.\nQuestion 3: The answer to this question is the letter k. To see this, the below code can be used:\n\n\n\n\n\n\nQuestion 4: The code for this question is provided below.\n\n\n\n\n\n\nQuestion 5: There are many ways to approach this question. Two examples are given below:"
  },
  {
    "objectID": "01/week_01_solutions.html#advanced-copying-and-references",
    "href": "01/week_01_solutions.html#advanced-copying-and-references",
    "title": "Week 1: Solutions",
    "section": "Advanced: Copying and References",
    "text": "Advanced: Copying and References\nQuestion 1: The expected output is [1,2,3,4]. This is because list_a and list_b reference the same location in memory.\n\n\n\n\n\n\nQuestion 2: Code A will print [1,2,3] whilst Code B will print [4,5,6]. This is because, when we replace a with [4,5,6] we change the reference to point to a new location in memory, breaking the connection between a and b. However, when we change the elements in a individually, both a and b remain pointing to the same location in memory. Thus, when we print b, we get [4,5,6].\n\n\n\n\n\n\nQuestion 3: The variable names xyz and xyzsquared are pointing to the same array. When we squared xyzsquared we also squared xyz. We could have avoided this by making xyzsquared a seperate copy of xyz using the list constructor like so:\n\n\n\n\n\n\nQuestion 4: When you do backup = list(grid), Python only makes a new outer list. The smaller lists inside ([1, 2], [3, 4], [5, 6]) are still the exact same objects that grid is using. Because of that, if you change one of the inner lists, the same change shows up backup.\nQuestion 5: The reasoning for this question is similar to that of Question 4, but noting that the three inner lists are all pointing to the same place in memory."
  },
  {
    "objectID": "01/week_01_home.html",
    "href": "01/week_01_home.html",
    "title": "Introduction to Data Types",
    "section": "",
    "text": "Welcome to the 2025 SCIF10002 Introduction to Coding and Data Analysis for Scientists course!",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#using-the-notebooks",
    "href": "01/week_01_home.html#using-the-notebooks",
    "title": "Introduction to Data Types",
    "section": "Using the Notebooks",
    "text": "Using the Notebooks\nThe file you have open is aJupyter Notebook. This is an interactive Python environment where you can both write and run code. All of the interactive parts of this course will take place in Jupyter notebooks.\nEach notebook is made up of two types of cells:\n- Text cells (like this one), which introduce and explain new topics.\n- Code cells, which contain Python code you can run and modify.\nTo run a code cell, click inside it and press Shift + Enter. You can also edit the code before running it. Give it a try in the cell below!",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#todays-material",
    "href": "01/week_01_home.html#todays-material",
    "title": "Introduction to Data Types",
    "section": "Today’s Material",
    "text": "Today’s Material\nToday, we will be learning about data types. As there is a range of ability in the class we have prepared three options for today’s work.\n\nImportant: For today, please choose just one of the options below. You’ll have many opportunities to revisit the other concepts later in the course, so focus on building confidence with the Beginner material before tackling more advanced work.\n\n\nOption 1: Beginner\nIf you are new to coding, or still building confidence in Python, today you should work through the Basic Data Types notebook linked below:\n\nBeginner: Basic Data Types\n\nIn this notebook you will find interactive code blocks and plenty of exercises. Coding is best learned by doing, so take your time to work through the material and attempt as many exercises as you can during today’s session!\n\n\nOption 2: Intermediate\nIf you have some coding experience and are already somewhat familiar with basic data types in Python, you may wish to choose this option.\nFirst, please do check over the exercises in the Basic Data Types notebook and ensure you can answer them. Even the most experienced programmers will have gaps in their knowledge, so it is important you check this.\n\nBeginner: Basic Data Types\n\nOnce you feel confident with the material above, move on to the Collections notebook. This will introduce you to Python’s built-in collections and highlight the differences between sets, lists, dicts, and tuples. As always, aim to complete as many of the exercises as you can.\n\nIntermediate: Collections\n\n\n\nOption 3: Advanced\nIf you are an experienced programmer with a strong grasp of Python, begin by reviewing the exercises in the notebooks below to ensure you are fully comfortable with the material:\n\nBeginner: Basic Data Types\n\nIntermediate: Collections\n\nOnce you are confident in your understanding, move on to the following notebook:\n\nAdvanced: Copying and References",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_home.html#getting-help",
    "href": "01/week_01_home.html#getting-help",
    "title": "Introduction to Data Types",
    "section": "Getting Help",
    "text": "Getting Help\nThere is a lot to remember when first learning Python. To get more help see the Python API. Another useful link is the W3 schools series on Python which is very good, especially for new users. Another way to get help if you are ever unsure what a function is doing is to use thehelp function in the Python terminal like so:\n\n\n\n\n\n\nIn class, you can ask for help from the lecturer, demonstrators and your peers around you. We advise you do not ask AI for help unless you are really stuck.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Introduction to Data Types"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html",
    "href": "01/week_01_intro_to_data_types_intermediate.html",
    "title": "Intermediate: Collections",
    "section": "",
    "text": "Welcome to the Week 1 Intermediate Python Notebook. This notebook is designed for students who already have some experience with Python and are ready to build on the basics.\nYour task today is to read through the material carefully and complete the exercises provided at the end. These exercises are designed to deepen your understanding and give you practical experience with new concepts.\nIn this notebook, you will explore Python’s collection data types: tuples, lists, dictionaries, and sets. These are powerful tools for grouping, organizing, and working with data in more complex ways.\nBe sure to work through the examples and attempt all the exercises. They are designed to help you practice, reinforce your learning, and prepare you for the more advanced topics ahead.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#tuples-and-lists",
    "href": "01/week_01_intro_to_data_types_intermediate.html#tuples-and-lists",
    "title": "Intermediate: Collections",
    "section": "Tuples and lists",
    "text": "Tuples and lists\nIn this section, we are going to look at Tuples and Lists.\n\nA tuple is a collection which is ordered and unchangeable. In Python tuples are written with round brackets.\nA list is a collection which is ordered and changeable. In Python lists are written with square brackets.\n\nwhere changeable means that once created, the elements of the list can be modified, added, or removed, while the elements of a tuple cannot be altered after creation.\nBoth tuples and lists are built-in data types, can hold elements of arbitrary datatypes and behave, in many respects, like mathematical vectors. However, for numerical vectors and arrays it is much better to use numpy arrays, which are covered later in the course.\nBelow are some examples of lists and tuples. Note again that lists and tuples can contain data of any type.\n\n\n\n\n\n\nThis means they can also be nested. I.e. we can put a list in a list, a tuple in a tuple, a list in a tuple and a tuple in a list!\n\n\n\n\n\n\n\nAdding to Lists and Tuples\nLists and tuples can be added to using the concatenation operator, +, like so:\n\n\n\n\n\n\n\n\nIndexing Lists and Tuples\nTo index in python, square brackets are used. This is a common convention which applies to almost all vector-like datatypes in Python, e.g. tuples, lists, strings, numpy arrays, etc.\nPython uses zero indexing, which means that the first element in a list of length n is indexed as 0 and the last element is indexed as n-1. For example see the below (note that the same can also be done for tuples):\n\n\n\n\n\n\nNegative numbers can also be used to index lists (and other similar datatypes). For example, the index -1 will give the last element of the list, the index -2 will give the second to last element of the list and so on. This is known as circular wrap-around.\nFor a list of length n any index can be used between -n and (n-1) (inclusive) to access elements in the list. Indices outside of this range, however, will give an “index out of range” error.\n\n\n\n\n\n\nNote that nested lists and tuples support nested indexing but this involve multiple sets of square brackets (for example see below).\nYou may be more familiar with indexing of the form example_list[a,b] (i.e. only one set of square brackets); this syntax does exist in Python but unfortunately not for lists. In fact, this syntax is used heavily by numpy arrays (which we will cover later in the course).\n\n\n\n\n\n\n\n\nSlicing Tuples and Lists\nA range of index values can be specified to extract values from a list using a colon, :. This way of accessing data is known as slicing and can be performed as follows:\n\n\n\n\n\n\n\nWarning: Often, in other languages such as Matlab the syntax 0:3 represents the range [0,1,2,3]; however, in python 0:3 represents only [0,1,2]. In other words the syntax k:n includes [k,k+1,...n-1] but does not include n itself! This is common to all data types in python and should always be remembered when indexing anything in Python!\n\nWhen indexing in python you can leave the start and end values implicit. This will give the same effect as starting from the beginning of the list and ending at the end of the list. For example:\n\n\n\n\n\n\nYou can also indicate a step size when indexing by using the following syntax:\n\n\n\n\n\n\nAnd you can run backwards through the list by using negative integers as the step size. For example:\n\n\n\n\n\n\n\n\nOperations on Lists and Tuples\nOther operations are also available for lists and tuples. Most notably, the * symbol can be used to replicate a list or tuple like so:\n\n\n\n\n\n\nOther notable operations for lists include:\n\ninsert: This function adds an element to the list at a specified position.\npop: This function removes the element in the list at the specified position.\nremove: This function removes the item with the specified value from the list.\nreverse: This function reverses the order of the list.\nsort: This function sorts the list.\n\nA few examples of these functions are given below. Try changing and editing the below code to check your understanding! Again, this is by no means a comprehensive list; more information can be found in the Python API or in the W3 schools documentation.\n\n\n\n\n\n\nNot as many operations are available for tuples as tuples are immutable (not meant to change in value). Two available operations are:\n\ncount: This function returns the number of times a specified value occurs in the tuple.\nindex: This function searches the tuple for a specified value and returns the position of where it was found.\n\nExamples of these are given below. For more information on tuples please visit the Python API or the W3 schools documentation.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#sets-and-dictionarys",
    "href": "01/week_01_intro_to_data_types_intermediate.html#sets-and-dictionarys",
    "title": "Intermediate: Collections",
    "section": "Sets and Dictionarys",
    "text": "Sets and Dictionarys\nIn this section, we are going to look in more detail at Sets and Dictionarys.\n\nA set is a collection which is unordered, changeable and unindexed. In Python sets are written with curly brackets.\nA dictionary is a collection which is unordered, changeable and indexed. In Python dictionarys are also written with curly brackets but also with keys and values.\n\nLike tuples and lists, both sets and dictionarys are built-in python types and can hold elements of arbitrary data types. However, unlike tuples and lists they do not behave like vectors as they are unordered. In other programming languages, such as Java, you may have heard of dictionarys referred to as hashmaps.\nBelow are some examples of sets and dictionarys.\n\n\n\n\n\n\n\nAdding elements to and retreiving elements from Dictionarys\nElements can be added to dictionarys as keys and values. For example; in the first line below the key is a and the value is b. Note that a key does not have to be a string; integers and floats work just as well. Values can be of any data type.\n\n\n\n\n\n\nWe can then retreive values from the dictionary using the keys we stored them under. This can be done with either square brackets or the built-in get function. For example:\n\n\n\n\n\n\n\n\nRemoving elements from a dictionary\nElements can be removed from a dictionary using the pop and del methods. For example:\n\n\n\n\n\n\n\n\nOperations on Dictionarys\nOther operations are also available for dictionarys. Some of the most useful of these are;\n\nkeys: This function returns a list containing the dictionary’s keys.\nvalues: This function returns a list of all the values in the dictionary.\nitems: This function returns a list containing a tuple for each (key, value) pair.\n\nExamples of these functions are given below. For full documentation and details on more functions see the Python API and W3 schools Python documentation.\n\n\n\n\n\n\n\n\nAdding elements to a set\nElements can be added to a set using the add function. For example, see the below code.\nNote that a set is designed to mimic the idea of a set in mathematics and, therefore, sets do not allow for duplicate entries. An entry is either in or not in a set; it cannot be “in” a set twice.\nMultiple elements can also be added to a set at once using the update method.\n\n\n\n\n\n\nHowever, there is no notion of indexing for Python sets as sets are unordered. This means that individual elements cannot be accessed in the same manor as in dictionarys, lists and tuples. We can check if an element is in a set, however, using the in keyword.\n\n\n\n\n\n\n\n\nRemoving elements from a set\nElements can be removed from a set using the remove function. Note: the remove function will errror if the requested value is not in the set.\n\n\n\n\n\n\n\n\nOperations on Sets\nOther operations are also available for sets, many of which are designed to mimic mathematic functions. For example:\n\ndifference: This function returns a set containing the difference between two or more sets.\nintersection: This function returns a set which is the intersection of two other sets.\nissubset: This function returns True if the first set input contains the second set input and False otherwise.\nissuperset: This function returns True if the first set input is contained within the second set input and False otherwise.\nunion: This function returns a set containing the union of input sets.\n\nExamples of these are given below. For full documentation and details on more functions see the Python API and W3 schools Python documentation.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_intro_to_data_types_intermediate.html#exercises",
    "href": "01/week_01_intro_to_data_types_intermediate.html#exercises",
    "title": "Intermediate: Collections",
    "section": "Exercises",
    "text": "Exercises\nQuestion 1: The below code creates a list of numbers:\n\n\n\n\n\n\nUsing this list, write code which does the following: 1. retrieves the third element of the list 2. slice the first three elements of the list 3. replaces the last element with 10 4. appends 7 to the end of the list 5. removes the first occurrence of 2\nMake sure to print the list after each change.\n\n\n\n\n\n\nQuestion 2: The below code creates a list, casts it to a set and then casts it back to a list.\n\n\n\n\n\n\nThe new list doesn’t equal the original list. Why do you think this might be?\nHint: Try printing my_list and my_new_list.\nQuestion 3: A string can be converted to a set using the set() constructor. Use this fact to identify which letter appears in string2 but not in string1 below:\n\n\n\n\n\n\nHint: You might want to recap difference function from this notebook and the lower() function from the beginner notebook.\nQuestion 4: The below code creates a tuple named t.\n\n\n\n\n\n\nWrite some code which does the following:\n\naccess the first and last elements of t\nslice out ('b', 'c', 'd')\ncheck whether 'c' is in t\nfind the index of 'd' in t\ncount how many times 'a' appears in t\n\n\n\n\n\n\n\nQuestion 5: You are given the below dataset for 5 individuals in a clinical trial.\n\n\n\nName\nWeight (kg)\nHeight (cm)\n\n\n\n\nJohn\n82\n178\n\n\nAlice\n68\n165\n\n\nMaria\n74\n170\n\n\nDavid\n90\n185\n\n\nSarah\n60\n160\n\n\n\nUsing the collection types introduced in this notebook (lists, tuples, sets, dictionaries - no loops or user-defined functions), choose an appropriate way to represent the clinical-trial table. Write your code in the box below.",
    "crumbs": [
      "Home",
      "01 Introduction to Data Types",
      "Intermediate: Collections"
    ]
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html",
    "href": "01/week_01_solutions_demonstrator_version.html",
    "title": "Week 1: Solutions",
    "section": "",
    "text": "This notebook contains the solutions to the week 1 Beginner, Intermediate and Advanced exercises."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#beginner-basic-data-types",
    "href": "01/week_01_solutions_demonstrator_version.html#beginner-basic-data-types",
    "title": "Week 1: Solutions",
    "section": "Beginner: Basic Data Types",
    "text": "Beginner: Basic Data Types\nQuestion 1: The solution to the question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The purpose of this question is to prompt students to think about the use of the and and or boolean operators, as well as the syntax for &lt;. When advising students on this question, make sure to help them break the inequalities \\(x^2&lt;y&lt;z^3\\) and \\(z^3&lt;y&lt;x^2\\) down using the and statement.\n\nQuestion 2: The solution to the question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: Last year, many of the students struggled with Boolean logic. This question aims to get them thinking about how to combine logical connectives like and and not. If students are struggling with this, please try and prompt them to convert the natural language sentence it's raining and I don't have my umbrella to logical syntax by breaking it down into smaller sentences. Highlight that I don't have my umbrella is the logical opposite (negation) of I have my umbrella.\n\nQuestion 3: The completed truth table for this question is:\n\n\n\n\n\n\n\n\n\n\n\nA\nB\nC\nA and B\nnot C\n(A and B) or (not C)\n\n\n\n\nTrue\nTrue\nTrue\nTrue\nFalse\nTrue\n\n\nTrue\nTrue\nFalse\nTrue\nTrue\nTrue\n\n\nTrue\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nTrue\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nTrue\nFalse\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nTrue\nFalse\nFalse\nFalse\n\n\nFalse\nFalse\nFalse\nFalse\nTrue\nTrue\n\n\n\nAnd the code for this question is:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is again designed to get students thinking about Boolean logic. It is expected that, for many students, this will be their first encounter with truth tables and first-order logical operators.\nIf a student is struggling with the abstraction, try to relate A, B and C to the example given in the slides. In the slides, A represents the statement The cat is black and B represents the statement The cat has four legs. To extend the example, you could define C to be, for instance, The cat has blue eyes. Once this is understood, try building the truth table column by column, starting with the A and B column, then the not C column and then finally the (A and B) or (not C) column.\nWhen giving examples, try to avoid statements with vague/ambiguous truth values. For instance, The cat is tall has an ambiguous truth value as there is not a clear distinction between tall and not tall.\n\nQuestion 4: The solution to this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: At this stage, students will not know any numpy, so please make sure to use x**(1/2) instead of functions such as np.sqrt(x). These functions will be taught at a later stage. It is expected that many students here will mistakenly write ^ for exponentiation instead of **, so please look out for this mistake. Some students may also need reminding that Pythagoras’ theorem can be used to compute the length of the diagonal.\n\nQuestion 5: The solution to this question is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: Whilst the SUVAT equations are part of the UK A-level Physics syllabus, please be aware that many students may not know them. For instance, data science or chemistry students may not have taken Physics A-level (or potentially even GCSE) and overseas students may have been taught the subject using different notations. For this reason, be aware students may be non-responsive to this question because they do not understand that, e.g., a should be set to 9.81. Try to assess whether the student is comfortable with the subject material before giving advice on how to solve the problem here.\n\nQuestion 6: The solution to this question is given by:\n\n\n\n\n\n\n\nDemonstrator Notes: See comments on previous question. Also be aware that there are multiple solutions to this question, as any of the equations \\(v=u+at\\), \\(s=ut+\\frac{1}{2}at^2\\) or \\(s=\\frac{(u+v)t}{2}\\) can be used. Students who are unsure what to do should be encouraged to look at the linked document for question 5.\n\nQuestion 7: A code block containing the examples from the question is given below:\n\n\n\n\n\n\nThe answers follow by standard boolean logic. The only difficult parts are determining the order of operations for the third example (python will interpret this as True or (False and False) rather than (True or False) and False) and the xor (^) on the fourth line.\n\nDemonstrator Notes: Some students may find this question confusing because we are using the Boolean values True and False directly, rather than naming them as variables (e.g. A and B). Emphasize that there is no difference between the below code:\nA = True\nB = False\nprint(A and B)\nand this code:\nprint(True and False)\nThe logic is identical - the only change is whether we use named variables or literal values. Point this out clearly so students see that the rules of Boolean logic still apply in exactly the same way.\n\nQuestion 8: The error in the code occurs when float(x + y) is run.\nWhen x and y are numeric, the + symbol is interpreted as addition and the result is cast to a float (e.g. if x=1 and y=5 as in the first example then x+y yeilds 6). However, if they are instead strings (as in the second example), then the + symbol is interpreted as concatenation rather than addition. Therefore, when x='2' and y='5', we get that 2+5 yeilds 25, not 7.\nThere are two approaches to resolving the issue. The first is to replace x='2' and y='5' with x=2 and y=5. The second, and preferred option, is to replace float(x + y) with float(x)+float(y) so there is no possibility that the + symbol is interpreted as concatenation here.\n\nDemonstrator Notes: If students are struggling with this question, suggest that they search the document for the + symbol and make sure they understand how it is being used. Hint that the symbol might not be interpreted in the way they first expect, but avoid giving away the full answer unless they are really stuck. The aim is to guide them toward discovering the behaviour themselves.\n\nQuestion 9: The first box is an assignment of the value 2 + 1 to a variable named three, so does not print anything. The second box prints true as the variable z = (1 + 2 == 3) is interpreted as a Boolean variable, and in Jupyter notebooks, if the last line of a box is simply a variable, with no assignment, then that variable is printed out. z is evaluated as True (as 1 + 2 does equal 3 in Python), so True is printed.\nFor the third box, False is printed as due to rounding errors 0.1 + 0.2 is evaluated to 0.30000000000000004 rather than 0.3. This is a cautionary note that floating point math is not perfect.\n\nDemonstrator Notes: First, it aims to get students to think about the difference between the assignment operator = and the equality operator ==. Second, it serves as a cautionary note about floating point arithmetic in Python.\nAfter seeing the result, many students may ask how to properly check whether 0.1 + 0.2 equals 0.3. For now, explain that we will cover this in more detail when we look at numpy. If they push further, encourage them to think about constructing a Boolean expression (similar to Question 1) that checks whether two numbers differ by only a very small amount. The aim here is to prepare them for the np.allclose function later on, while prompting them to reason about the problem themselves rather than being given the solution straight away.\n\nQuestion 10: The final solution is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is designed to give students practice with the string replace function. Encourage them to experiment and work through the task step by step, even if their first attempt doesn’t work. The key learning outcome is to get comfortable with testing, adjusting, and trying again - it aims to enforce good programming habits."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#intermediate-collections",
    "href": "01/week_01_solutions_demonstrator_version.html#intermediate-collections",
    "title": "Week 1: Solutions",
    "section": "Intermediate: Collections",
    "text": "Intermediate: Collections\n\nBroad Notes for Demonstrators: If you see a student attempting the intermediate questions who does not seem at the level of the material, please do encourage them to first try the beginner notebook.\n\nQuestion 1: The code for this question is given below:\n\n\n\n\n\n\n\nDemonstrator Notes: This question aims to give students some initial practice with lists. Common errors to look out for include failing to account for the fact Python uses zero indexing, or that slicing syntax such as nums[:3] doesn’t include nums[3] in the output, only nums[0],nums[1] and nums[2].\n\nQuestion 2: The key to this question is that a list is ordered whilst a set is unordered. When the list is converted to a set, it’s ordering is lost, and when converted back to a list it is now given in increasing (numerical) order by default.\n\nDemonstrator Notes: Hopefully, this should not be a difficult question. Encourage students who are struggling to print out my_set and my_list and describe what is different between them.\n\nQuestion 3: The answer to this question is the letter k. To see this, the below code can be used:\n\n\n\n\n\n\n\nDemonstrator Notes: This question brings together concepts from both the Beginner and Intermediate notebooks, making it a good checkpoint to assess whether students are ready to move into the Intermediate material.\nIf students are struggling, suggest that they try the task on paper first. They will probably start by writing out the letters from each sentence and then comparing the two sets of letters. From there, you can show how Python supports the same process by turning a string into a list of characters and then using the set constructor to remove duplicates. This should hopefully help them connect the manual approach with the Python solution.\nOnce they have these concepts down, encourage students to think about why the lower() function (as suggested in the hint) is useful here. It ensures that comparisons between characters are case-insensitive.\n\nQuestion 4: The code for this question is provided below.\n\n\n\n\n\n\n\nDemonstrator Notes: See notes on Question 1.\n\nQuestion 5: There are many ways to approach this question. Two examples are given below:\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to help students recognise that there are multiple valid ways to represent the same dataset in Python. The important part is thinking about how the data will be used. For example, if we need to look up information by subject name, a dictionary of dictionaries might be best; if we want to work with all weights at once (e.g. to build a histogram), a dictionary of lists is more convenient. Emphasise that the choice of data structure depends on the task - there isn’t one ‘right’ answer."
  },
  {
    "objectID": "01/week_01_solutions_demonstrator_version.html#advanced-copying-and-references",
    "href": "01/week_01_solutions_demonstrator_version.html#advanced-copying-and-references",
    "title": "Week 1: Solutions",
    "section": "Advanced: Copying and References",
    "text": "Advanced: Copying and References\n\nBroad Notes for Demonstrators: If you see a student attempting the intermediate or advanced questions who does not seem at the level of the material, please do encourage them to first try the earlier notebooks.\n\nQuestion 1: The expected output is [1,2,3,4]. This is because list_a and list_b reference the same location in memory.\n\n\n\n\n\n\n\nDemonstrator Notes: The aim of this question is to get students to recognise that lists are mutable. As a list is mutable, both list_a and list_b refer to the same underlying object in memory. When we do list_b = list_a, we are not creating a copy of the list, but simply creating a new reference to the same list object. Therefore, when we perform list_a.append(4), the change is reflected in both list_a and list_b. Encourage students to think about how they could gain the desired behaviour using the .copy() function (e.g. list_b = list_a.copy()).\n\nQuestion 2: Code A will print [1,2,3] whilst Code B will print [4,5,6]. This is because, when we replace a with [4,5,6] we change the reference to point to a new location in memory, breaking the connection between a and b. However, when we change the elements in a individually, both a and b remain pointing to the same location in memory. Thus, when we print b, we get [4,5,6].\n\n\n\n\n\n\n\nDemonstrator Notes: See notes for Question 1.\n\nQuestion 3: The variable names xyz and xyzsquared are pointing to the same array. When we squared xyzsquared we also squared xyz. We could have avoided this by making xyzsquared a seperate copy of xyz using the list constructor like so:\n\n\n\n\n\n\n\nDemonstrator Notes: This question is designed to give students practice debugging code. Try to guide them to the solution where possible, rather than providing the full solution straight away.\n\nQuestion 4: When you do backup = list(grid), Python only makes a new outer list. The smaller lists inside ([1, 2], [3, 4], [5, 6]) are still the exact same objects that grid is using. Because of that, if you change one of the inner lists, the same change shows up backup.\n\nDemonstrator Notes: The aim of this question is to understand why the unexpected behaviour occured. If students ask how to fix this, that’s a natural question, but at this stage they don’t yet have the tools to do so. For now, keep the focus on helping them understand why the behaviour occurs, instead of talking about fixes at this stage.\n\nQuestion 5: The reasoning for this question is similar to that of Question 4, but noting that the three inner lists are all pointing to the same place in memory.\n\nDemonstrator Notes: See the notes for Question 4."
  },
  {
    "objectID": "15/slides_pandas_plotting.html",
    "href": "15/slides_pandas_plotting.html",
    "title": "Plotting with Pandas",
    "section": "",
    "text": "We have seen in Teaching Block 1 that matplotlib is the default go-to library for plotting scientific data.\nWe have now been playing with pandas as a convenient tool to interact directly with datasets\nIt is desirable to find immediate ways to do data exploration from pandas data structures\n\nToday, we are precisely going to see how pandas data frames can be plotted, with an expressive and self-contained syntax."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#plotting-data",
    "href": "15/slides_pandas_plotting.html#plotting-data",
    "title": "Plotting with Pandas",
    "section": "",
    "text": "We have seen in Teaching Block 1 that matplotlib is the default go-to library for plotting scientific data.\nWe have now been playing with pandas as a convenient tool to interact directly with datasets\nIt is desirable to find immediate ways to do data exploration from pandas data structures\n\nToday, we are precisely going to see how pandas data frames can be plotted, with an expressive and self-contained syntax."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#plotting-with-pandas",
    "href": "15/slides_pandas_plotting.html#plotting-with-pandas",
    "title": "Plotting with Pandas",
    "section": "Plotting with Pandas",
    "text": "Plotting with Pandas\nPandas provides built-in plotting capabilities that make it easy to visualize data. It leverages matplotlib under the hood, allowing users to create plots with minimal code.\nThe framework is data-centric: plots are generated directly from DataFrames and Series without needing to manually extract and format data."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#plotting-with-series",
    "href": "15/slides_pandas_plotting.html#plotting-with-series",
    "title": "Plotting with Pandas",
    "section": "Plotting with Series",
    "text": "Plotting with Series\nSeries have a .plot() method that creates various types of plots. The kind parameter specifies the plot type: 'line', 'bar', 'barh', 'hist', 'box', 'pie', etc.\nBy default, the index is used for the x-axis and values for the y-axis."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#plotting-with-dataframes",
    "href": "15/slides_pandas_plotting.html#plotting-with-dataframes",
    "title": "Plotting with Pandas",
    "section": "Plotting with DataFrames",
    "text": "Plotting with DataFrames\nDataFrames also have a .plot() method. By default, each column is plotted as a separate line on the same axes. The DataFrame index is used for the x-axis.\nYou can specify which columns to plot using the x and y parameters."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#creating-subplots",
    "href": "15/slides_pandas_plotting.html#creating-subplots",
    "title": "Plotting with Pandas",
    "section": "Creating Subplots",
    "text": "Creating Subplots\nSetting subplots=True creates separate plots for each column. The layout parameter controls the grid structure as a tuple of rows and columns.\nThe method returns an array of matplotlib Axes objects that can be further customized."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#time-series-plotting",
    "href": "15/slides_pandas_plotting.html#time-series-plotting",
    "title": "Plotting with Pandas",
    "section": "Time Series Plotting",
    "text": "Time Series Plotting\nPandas automatically handles datetime formatting on the x-axis when plotting time series data. Use pd.to_datetime() to convert date columns to datetime objects.\nThe pivot() method can reshape data to make plotting multiple time series straightforward."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#rolling-windows-and-smoothing",
    "href": "15/slides_pandas_plotting.html#rolling-windows-and-smoothing",
    "title": "Plotting with Pandas",
    "section": "Rolling Windows and Smoothing",
    "text": "Rolling Windows and Smoothing\nThe .rolling() method creates a rolling window object for computing moving averages and other aggregations. This is useful for smoothing noisy data and highlighting trends.\nChain .mean(), .sum(), or other aggregation methods after .rolling() to compute the result."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#saving-plots",
    "href": "15/slides_pandas_plotting.html#saving-plots",
    "title": "Plotting with Pandas",
    "section": "Saving Plots",
    "text": "Saving Plots\nPandas plotting returns a matplotlib Axes object. You can save the figure by accessing the figure attribute and calling .savefig(), or by using matplotlib.pyplot.savefig() directly.\nSpecify file format and resolution with parameters like dpi."
  },
  {
    "objectID": "15/slides_pandas_plotting.html#todays-activities",
    "href": "15/slides_pandas_plotting.html#todays-activities",
    "title": "Plotting with Pandas",
    "section": "Today’s activities:",
    "text": "Today’s activities:\nYou will find\n\na lecture notebook with examples of plots from pandas using dummy and realistic datasets. Read through it to understand the range of capabilities.\nan excercises notebook working on real data from Our world in data, guiding you through a realistic visualisation pipeline"
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html",
    "href": "15/exercises_pandas_plotting_solutions.html",
    "title": "Practicing plotting with pandas",
    "section": "",
    "text": "In this suite of exercises, we will practice creating various types of plots using the pandas library in Python.\nAs usual, we will root our work on actual data and perform a realistic (albeit minimal) scientifc analysis."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#deforestation-data",
    "href": "15/exercises_pandas_plotting_solutions.html#deforestation-data",
    "title": "Practicing plotting with pandas",
    "section": "Deforestation Data",
    "text": "Deforestation Data\nWe use the Our World in Data deforestation dataset.\nIt contains data on forest area and deforestation data for various countries over time.\nIts link is\nhttps://ourworldindata.org/grapher/annual-deforestation.csv?v=1&csvType=full&useColumnShortNames=false"
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-1-loading-and-pivoting-the-data",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-1-loading-and-pivoting-the-data",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 1: Loading and pivoting the data",
    "text": "Exercise 1: Loading and pivoting the data\nRead in the dataset using pandas.\nThen, pivot the data so that you have years as the index, countries as the columns, and deforestation as the values."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-2-plotting-deforestation-for-regions",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-2-plotting-deforestation-for-regions",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 2 : Plotting deforestation for regions",
    "text": "Exercise 2 : Plotting deforestation for regions\nThe datasets contains rates in ha/year (hectares per year) for many different countries, as well as the various regions including the world as a whole.\nFind the names of such regions in the dataset and create a plot with multiple lines, one for each region, showing deforestation over time. Include also the world as a whole.\nPlot requirements:\n\nThe plot should have appropriate labels and a legend.\nThe lines should also have markers.\nThe lines should be distinguishable by color and line style.\nThe line for the World should be thicker than the others.\nThe deforestation values should be shown in millions of hectares per year (i.e., divide the values by 1,000,000).\n\nNotes. - If you look carefully at the original dataset, you will notice that you have a Code column that contains codes for countries and regions. - You can provide a list of styles to the style argument of the plot method to have different line styles for each line. - If ax is an axis returned by a plot object, you can access its last plotted line as ax.lines[-1] and sets its properties with methods such as set_linewidth() or set_color()."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-3-share-of-deforestation-by-continent-in-2020",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-3-share-of-deforestation-by-continent-in-2020",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 3 : Share of deforestation by continent in 2020",
    "text": "Exercise 3 : Share of deforestation by continent in 2020\nPick now year 2020 and create a pie chart showing the share of deforestation for that year between the various continents (i.e., Africa, Asia, Europe, North America, Oceania, South America). The share is the fraction of the total deforestation in the world that is due to each continent.\nNotes.\n\nYou can improve the rendering of the pie chart by adding formatted percentage labels with the autopct to plot using the pie kind."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-4-stacked-area-plot-of-regional-deforestation",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-4-stacked-area-plot-of-regional-deforestation",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 4: Stacked area plot of regional deforestation",
    "text": "Exercise 4: Stacked area plot of regional deforestation\nCreate a stacked area plot showing how deforestation is distributed across continents over time (1990-2020).\nRequirements: - Use only the continental regions (Africa, Asia, Europe, North America, Oceania, South America) - Show values in millions of hectares per year - Only include positive values (deforestation, not reforestation) - Add appropriate title and labels\nHint: Use kind='area' and set stacked=True."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-5-bar-plot-of-top-10-countries-with-highest-deforestation-in-2010",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-5-bar-plot-of-top-10-countries-with-highest-deforestation-in-2010",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 5: Bar plot of top 10 countries with highest deforestation in 2010",
    "text": "Exercise 5: Bar plot of top 10 countries with highest deforestation in 2010\nUsing the data for 2010, create a bar plot showing the top 10 countries with the highest deforestation rates in absolute terms.\nPlot them so that they are sorted (ascending or descending, as you prefer).\nYou need to exclude regions and only consider countries.\nNote. - Boolean operators can be used to filter dataframes. For example, if we want to filter a dataframe to include only rows where the column A doe not contain the value foo, we can do:\nfiltered_df = df[~(df['A'] == 'foo')]\nwhere the ~ operator negates the boolean condition. - You can use barh as the kind of plot to create horizontal bar plots."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-6-merging-datasets-and-normalisation-by-area",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-6-merging-datasets-and-normalisation-by-area",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 6: Merging datasets and normalisation by area",
    "text": "Exercise 6: Merging datasets and normalisation by area\nThe comparison above is in part unfair because countries have different sizes (and hence extent of forested surfaces).\nAs a first approximation, we can normalise deforestation rates by the total area of each country.\nTo retrieve the total area data for countries, you’ll need to load a CSV file containing country areas. We can use the Our World in Data dataset on land area.\nHere’s the link to the dataset:\nhttps://ourworldindata.org/grapher/land-area-km.csv\nWe can read this second dataset into a separate dataframe.\nA powerful feature of pandas is the ability to merge dataframes based on common columns.\nThis is done using the pd.merge function as follows:\nmerged_df = pd.merge(df1, df2, on=list_of_common_columns)\nUsing merging, combine the deforestation data for 2010 with the land area data.\nThen, create a new column in the merged dataframe that contains the deforestation rate per square kilometer for each country.\nFinally, create a bar plot showing the top 10 countries with the highest deforestation rates per square kilometer in 2010.\nNotes.\n\nWhen merging, provide a list of common columns to the on argument. In this case, the common columns are likely to be Entity, Year and Code."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-7-bringing-vegetable-oil-data-in",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-7-bringing-vegetable-oil-data-in",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 7: Bringing vegetable oil data in",
    "text": "Exercise 7: Bringing vegetable oil data in\nWe can further extend our analysis by bringing in data on vegetable oil production, which is a significant driver of deforestation in some regions.\nFirst, we load the vegetable oil production dataset from Our World in Data, which contains production data for various types of oils (palm oil, soybean oil, sunflower oil, etc.).\n\n\n\n\n\n\nSince deforestation is driven by various oil crops (not just palm oil), sum all vegetable oil production types to get a total for each country and year and store it as a new column. This provides a more comprehensive view of agricultural oil pressure."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-8-pivot-by-country-the-vegetable-oil-data",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-8-pivot-by-country-the-vegetable-oil-data",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 8: Pivot by country the vegetable oil data",
    "text": "Exercise 8: Pivot by country the vegetable oil data\nTo get a by country view of vegetable oil production, pivot the vegetable oil dataset so that you have years as the index, countries as the columns, and total vegetable oil production as the values."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-9-select-countries-for-comparison",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-9-select-countries-for-comparison",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 9: Select countries for comparison",
    "text": "Exercise 9: Select countries for comparison\nFilter to include only countries that appear in both the top 10 deforestation list (from 2010, Exercise 5) AND have oil production data."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-10-plot-vegetable-oil-production-over-time-for-selected-countries",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-10-plot-vegetable-oil-production-over-time-for-selected-countries",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 10: Plot vegetable oil production over time for selected countries",
    "text": "Exercise 10: Plot vegetable oil production over time for selected countries\nWe normalize all oil production values relative to 1990 (baseline = 100) to make it easier to compare growth rates across countries of different sizes.\nProduce two plots:\n\nfirst the normalised vegetable oil production over time for the selected countries\nthen a smoothened version of the same plot (using a rolling mean with a window of 10 years)."
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#exercise-11-comparing-deforestation-and-oil-production-over-time",
    "href": "15/exercises_pandas_plotting_solutions.html#exercise-11-comparing-deforestation-and-oil-production-over-time",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 11: Comparing deforestation and oil production over time",
    "text": "Exercise 11: Comparing deforestation and oil production over time\nFor each of the following countries (Brazil, the Democratic Republic of Congo, India and Indonesia) plot a figure with the two lines:\n\nthe normalised vegetable oil production over time (use the smoothed version from Exercise 10)\nthe deforestation rate over time (also normalised to 1990)\n\nBoth lines should be on the same plot with the same y-axis scale (since both use 1990 = 100 as baseline).\nNote: You may observe inverse correlations in some countries - this is expected and scientifically meaningful (see interpretation below).\nHints.\n\nYou may need to drop NaN values with the dropna() method to get continuous lines\nYou need first to normalise your deforestation data\nYou may want to create a new dataframe using pd.DataFrame and a suitable dictionary"
  },
  {
    "objectID": "15/exercises_pandas_plotting_solutions.html#interpretation-of-results",
    "href": "15/exercises_pandas_plotting_solutions.html#interpretation-of-results",
    "title": "Practicing plotting with pandas",
    "section": "Interpretation of Results",
    "text": "Interpretation of Results\nYou should observe different trends depending on the countries of consideration that can reflect different modes of production, deforestation and shifts in policies:\n\nSome countries show correlations between deforestation rates and vegetable oil production: this is typically when vegetable oil production requires direct area increases and deforestation is diffuse (small-scale clearing of land)\nOther countries can show inverse correlation: this can have various causes, for example time-lags between extensive deforestation and usage of the land, as well as different means of expanding vegetable oil production (conversion of already cleared land, e.g. pasture, into crops)\n\nThis exercise demonstrates that macroscale data analysis can be rather complex and requires multiple layers of information and datasets to be properly interpreted. In this specific case, we would need more information on the modes of production, land use changes, policies and economic drivers to make sense of the observed trends."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html",
    "href": "15/exercises_pandas_plotting-solutions.html",
    "title": "Practicing plotting with pandas",
    "section": "",
    "text": "In this suite of exercises, we will practice creating various types of plots using the pandas library in Python.\nAs usual, we will root our work on actual data and perform a realistic (albeit minimal) scientifc analysis."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#deforestation-data",
    "href": "15/exercises_pandas_plotting-solutions.html#deforestation-data",
    "title": "Practicing plotting with pandas",
    "section": "Deforestation Data",
    "text": "Deforestation Data\nWe use the Our World in Data deforestation dataset.\nIt contains data on forest area and deforestation data for various countries over time.\nIts link is\nhttps://ourworldindata.org/grapher/annual-deforestation.csv?v=1&csvType=full&useColumnShortNames=false"
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-1-loading-and-pivoting-the-data",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-1-loading-and-pivoting-the-data",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 1: Loading and pivoting the data",
    "text": "Exercise 1: Loading and pivoting the data\nRead in the dataset using pandas.\nThen, pivot the data so that you have years as the index, countries as the columns, and deforestation as the values."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-2-plotting-deforestation-for-regions",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-2-plotting-deforestation-for-regions",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 2 : Plotting deforestation for regions",
    "text": "Exercise 2 : Plotting deforestation for regions\nThe datasets contains rates in ha/year (hectares per year) for many different countries, as well as the various regions including the world as a whole.\nFind the names of such regions in the dataset and create a plot with multiple lines, one for each region, showing deforestation over time. Include also the world as a whole.\nPlot requirements:\n\nThe plot should have appropriate labels and a legend.\nThe lines should also have markers.\nThe lines should be distinguishable by color and line style.\nThe line for the World should be thicker than the others.\nThe deforestation values should be shown in millions of hectares per year (i.e., divide the values by 1,000,000).\n\nNotes. - If you look carefully at the original dataset, you will notice that you have a Code column that contains codes for countries and regions. - You can provide a list of styles to the style argument of the plot method to have different line styles for each line. - If ax is an axis returned by a plot object, you can access its last plotted line as ax.lines[-1] and sets its properties with methods such as set_linewidth() or set_color()."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-3-share-of-deforestation-by-continent-in-2020",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-3-share-of-deforestation-by-continent-in-2020",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 3 : Share of deforestation by continent in 2020",
    "text": "Exercise 3 : Share of deforestation by continent in 2020\nPick now year 2020 and create a pie chart showing the share of deforestation for that year between the various continents (i.e., Africa, Asia, Europe, North America, Oceania, South America). The share is the fraction of the total deforestation in the world that is due to each continent.\nNotes.\n\nYou can improve the rendering of the pie chart by adding formatted percentage labels with the autopct to plot using the pie kind."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-4-stacked-area-plot-of-regional-deforestation",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-4-stacked-area-plot-of-regional-deforestation",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 4: Stacked area plot of regional deforestation",
    "text": "Exercise 4: Stacked area plot of regional deforestation\nCreate a stacked area plot showing how deforestation is distributed across continents over time (1990-2020).\nRequirements: - Use only the continental regions (Africa, Asia, Europe, North America, Oceania, South America) - Show values in millions of hectares per year - Only include positive values (deforestation, not reforestation) - Add appropriate title and labels\nHint: Use kind='area' and set stacked=True."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-5-bar-plot-of-top-10-countries-with-highest-deforestation-in-2010",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-5-bar-plot-of-top-10-countries-with-highest-deforestation-in-2010",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 5: Bar plot of top 10 countries with highest deforestation in 2010",
    "text": "Exercise 5: Bar plot of top 10 countries with highest deforestation in 2010\nUsing the data for 2010, create a bar plot showing the top 10 countries with the highest deforestation rates in absolute terms.\nPlot them so that they are sorted (ascending or descending, as you prefer).\nYou need to exclude regions and only consider countries.\nNote. - Boolean operators can be used to filter dataframes. For example, if we want to filter a dataframe to include only rows where the column A doe not contain the value foo, we can do:\nfiltered_df = df[~(df['A'] == 'foo')]\nwhere the ~ operator negates the boolean condition. - You can use barh as the kind of plot to create horizontal bar plots."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-6-merging-datasets-and-normalisation-by-area",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-6-merging-datasets-and-normalisation-by-area",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 6: Merging datasets and normalisation by area",
    "text": "Exercise 6: Merging datasets and normalisation by area\nThe comparison above is in part unfair because countries have different sizes (and hence extent of forested surfaces).\nAs a first approximation, we can normalise deforestation rates by the total area of each country.\nTo retrieve the total area data for countries, you’ll need to load a CSV file containing country areas. We can use the Our World in Data dataset on land area.\nHere’s the link to the dataset:\nhttps://ourworldindata.org/grapher/land-area-km.csv\nWe can read this second dataset into a separate dataframe.\nA powerful feature of pandas is the ability to merge dataframes based on common columns.\nThis is done using the pd.merge function as follows:\nmerged_df = pd.merge(df1, df2, on=list_of_common_columns)\nUsing merging, combine the deforestation data for 2010 with the land area data.\nThen, create a new column in the merged dataframe that contains the deforestation rate per square kilometer for each country.\nFinally, create a bar plot showing the top 10 countries with the highest deforestation rates per square kilometer in 2010.\nNotes.\n\nWhen merging, provide a list of common columns to the on argument. In this case, the common columns are likely to be Entity, Year and Code."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-7-bringing-vegetable-oil-data-in",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-7-bringing-vegetable-oil-data-in",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 7: Bringing vegetable oil data in",
    "text": "Exercise 7: Bringing vegetable oil data in\nWe can further extend our analysis by bringing in data on vegetable oil production, which is a significant driver of deforestation in some regions.\nFirst, we load the vegetable oil production dataset from Our World in Data, which contains production data for various types of oils (palm oil, soybean oil, sunflower oil, etc.).\n\n\n\n\n\n\nSince deforestation is driven by various oil crops (not just palm oil), sum all vegetable oil production types to get a total for each country and year and store it as a new column. This provides a more comprehensive view of agricultural oil pressure."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-8-pivot-by-country-the-vegetable-oil-data",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-8-pivot-by-country-the-vegetable-oil-data",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 8: Pivot by country the vegetable oil data",
    "text": "Exercise 8: Pivot by country the vegetable oil data\nTo get a by country view of vegetable oil production, pivot the vegetable oil dataset so that you have years as the index, countries as the columns, and total vegetable oil production as the values."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-9-select-countries-for-comparison",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-9-select-countries-for-comparison",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 9: Select countries for comparison",
    "text": "Exercise 9: Select countries for comparison\nFilter to include only countries that appear in both the top 10 deforestation list (from 2010, Exercise 5) AND have oil production data."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-10-plot-vegetable-oil-production-over-time-for-selected-countries",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-10-plot-vegetable-oil-production-over-time-for-selected-countries",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 10: Plot vegetable oil production over time for selected countries",
    "text": "Exercise 10: Plot vegetable oil production over time for selected countries\nWe normalize all oil production values relative to 1990 (baseline = 100) to make it easier to compare growth rates across countries of different sizes.\nProduce two plots:\n\nfirst the normalised vegetable oil production over time for the selected countries\nthen a smoothened version of the same plot (using a rolling mean with a window of 10 years)."
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#exercise-11-comparing-deforestation-and-oil-production-over-time",
    "href": "15/exercises_pandas_plotting-solutions.html#exercise-11-comparing-deforestation-and-oil-production-over-time",
    "title": "Practicing plotting with pandas",
    "section": "Exercise 11: Comparing deforestation and oil production over time",
    "text": "Exercise 11: Comparing deforestation and oil production over time\nFor each of the following countries (Brazil, the Democratic Republic of Congo, India and Indonesia) plot a figure with the two lines:\n\nthe normalised vegetable oil production over time (use the smoothed version from Exercise 10)\nthe deforestation rate over time (also normalised to 1990)\n\nBoth lines should be on the same plot with the same y-axis scale (since both use 1990 = 100 as baseline).\nNote: You may observe inverse correlations in some countries - this is expected and scientifically meaningful (see interpretation below).\nHints.\n\nYou may need to drop NaN values with the dropna() method to get continuous lines\nYou need first to normalise your deforestation data\nYou may want to create a new dataframe using pd.DataFrame and a suitable dictionary"
  },
  {
    "objectID": "15/exercises_pandas_plotting-solutions.html#interpretation-of-results",
    "href": "15/exercises_pandas_plotting-solutions.html#interpretation-of-results",
    "title": "Practicing plotting with pandas",
    "section": "Interpretation of Results",
    "text": "Interpretation of Results\nYou should observe different trends depending on the countries of consideration that can reflect different modes of production, deforestation and shifts in policies:\n\nSome countries show correlations between deforestation rates and vegetable oil production: this is typically when vegetable oil production requires direct area increases and deforestation is diffuse (small-scale clearing of land)\nOther countries can show inverse correlation: this can have various causes, for example time-lags between extensive deforestation and usage of the land, as well as different means of expanding vegetable oil production (conversion of already cleared land, e.g. pasture, into crops)\n\nThis exercise demonstrates that macroscale data analysis can be rather complex and requires multiple layers of information and datasets to be properly interpreted. In this specific case, we would need more information on the modes of production, land use changes, policies and economic drivers to make sense of the observed trends."
  },
  {
    "objectID": "13/slides_pandas.html",
    "href": "13/slides_pandas.html",
    "title": "Introduction to Pandas",
    "section": "",
    "text": "pandas are the Python library for data science"
  },
  {
    "objectID": "13/slides_pandas.html#powerful-tables-the-pandas-dataframe",
    "href": "13/slides_pandas.html#powerful-tables-the-pandas-dataframe",
    "title": "Introduction to Pandas",
    "section": "Powerful tables: The Pandas DataFrame",
    "text": "Powerful tables: The Pandas DataFrame\nTables are the simplest way to store data:\n\nevery line is an observation\nevery column represents a type of measurement\n\nTables in Pandas are a new object: the DataFrame\n\n\n\nimage.png"
  },
  {
    "objectID": "13/slides_pandas.html#powerful-tables-the-pandas-dataframe-1",
    "href": "13/slides_pandas.html#powerful-tables-the-pandas-dataframe-1",
    "title": "Introduction to Pandas",
    "section": "Powerful tables: The Pandas DataFrame",
    "text": "Powerful tables: The Pandas DataFrame\npandas is nice because it can read and write tables from many existing formats, removing the worry of dealing with format specifications\n\n\n\nimage.png"
  },
  {
    "objectID": "13/lecture_pandas.html",
    "href": "13/lecture_pandas.html",
    "title": "Pandas",
    "section": "",
    "text": "The pandas module is a powerful Python library for data manipulation and analysis. It makes reading tabulated data easier and allows various arithmetic or logical operations to be performed. The results can be outputted as tabular forms or plots.\nUsing pandas shares similarities with lists, numpy arrays, and dictionaries - you can add new elements, update them, and manipulate them. However, there are some subtle differences and new features that make pandas particularly powerful for data analysis.\nWe shall start by importing the pandas module. Conventionally, pandas is imported as “pd”:",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#dataframes---the-primary-pandas-structure",
    "href": "13/lecture_pandas.html#dataframes---the-primary-pandas-structure",
    "title": "Pandas",
    "section": "DataFrames - The primary pandas structure",
    "text": "DataFrames - The primary pandas structure\nJust as numpy introduced the array object, pandas introduces new structures which allow more advanced functionality. The primary structure is called a DataFrame, which looks a lot like a table of data.\nOne way to create a DataFrame is using a dictionary where the keys are column names and the values are the column entries:\n\n\n\n\n\n\nIf we examine the pandas DataFrame above, we can see the following features: - This is a two-dimensional “table” of data with rows and columns - Initially, each row has been labelled by number (0, 1, 2). This is known as the index - Each column has been labelled by a column name (“formula”, “name”, “mol_mass”)",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#working-with-rows-the-index",
    "href": "13/lecture_pandas.html#working-with-rows-the-index",
    "title": "Pandas",
    "section": "Working with Rows: The Index",
    "text": "Working with Rows: The Index\nThe index is an important feature of pandas DataFrames. It builds upon other ordered objects (like lists and numpy arrays) but also adds in labelling (like dictionaries). By default, rows are indexed as 0, 1, 2… but we can assign this to anything we like to label our rows in a useful way.\nTo make the rows more meaningful, we can label them using the formula column. We can set a new index from a column using the set_index method:\n\n\n\n\n\n\nNote: by default the set_index() method creates a new DataFrame. To update our original DataFrame this needs to be assigned back to our original variable name.\nThe benefit is that we can now access a row using our meaningful index name. We do this using the .loc[] syntax:\n\n\n\n\n\n\nNote that we use square brackets not round brackets after .loc - this is unique pandas syntax for indexing a DataFrame.\nWe can access the full set of index values using the .index attribute:\n\n\n\n\n\n\nEven though this returns an Index object, we can access elements using positional indexing as we would for a list or numpy array:",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#working-with-columns",
    "href": "13/lecture_pandas.html#working-with-columns",
    "title": "Pandas",
    "section": "Working with Columns",
    "text": "Working with Columns\nEach column can be accessed from a pandas DataFrame by using the name of the column:\n\n\n\n\n\n\nThis is similar to accessing values using keys in a dictionary. Each column is stored as a pandas Series, which is a one-dimensional version of a DataFrame. This is similar to a list or a 1D numpy array but has an index just like a DataFrame.\nTo find the full names of all columns in a DataFrame, we can access the .columns attribute:",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#working-with-values-and-data-types",
    "href": "13/lecture_pandas.html#working-with-values-and-data-types",
    "title": "Pandas",
    "section": "Working with Values and Data Types",
    "text": "Working with Values and Data Types\nA pandas DataFrame contains values for each row and column. Each column (Series) has a particular dtype, which is the data type (e.g. float, int, str) associated with that data. This is the same terminology we saw with numpy.\n\n\n\n\n\n\nTo access one element in a DataFrame, we can: - Select the row using .loc[] and then the column using [] indexing - Use .loc[] with both row and column (similar to multi-indexing in numpy)",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#applying-operations",
    "href": "13/lecture_pandas.html#applying-operations",
    "title": "Pandas",
    "section": "Applying Operations",
    "text": "Applying Operations\nThe pandas module is built on underlying numpy arrays and brings across similar functionality. You can even access the underlying numpy array using the .values attribute:\n\n\n\n\n\n\nAs with numpy arrays, we can perform arithmetic or logical operations across a whole column (a pandas Series) at once:\n\n\n\n\n\n\nWe can also combine multiple pandas Series with the same indices:\n\n\n\n\n\n\nJust as with numpy, this operation combines these two objects element by element. For a pandas Series, this matches on the index rather than the position.",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#statistical-operations",
    "href": "13/lecture_pandas.html#statistical-operations",
    "title": "Pandas",
    "section": "Statistical Operations",
    "text": "Statistical Operations\nSimilar to numpy arrays, pandas provides many methods for performing statistical operations. However, it’s always better to use pandas methods when dealing with pandas objects, as they handle data more intelligently (especially with missing data).\nCommon statistical operations include:",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#updating-dataframes-adding-new-columns",
    "href": "13/lecture_pandas.html#updating-dataframes-adding-new-columns",
    "title": "Pandas",
    "section": "Updating DataFrames: Adding New Columns",
    "text": "Updating DataFrames: Adding New Columns\nLet’s create a new DataFrame to demonstrate how to update and add new information:\n\n\n\n\n\n\nWe can extract a column and perform operations on it:\n\n\n\n\n\n\nTo add this as a new column, we use syntax similar to assigning new values to dictionaries - define a new key and assign the new data:\n\n\n\n\n\n\nWhen assigning a new value, it must be the same length as the number of rows in the DataFrame.\nWe can also apply operations between columns to create new columns. For instance, we can calculate population density:",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#filtering-data",
    "href": "13/lecture_pandas.html#filtering-data",
    "title": "Pandas",
    "section": "Filtering Data",
    "text": "Filtering Data\nSimilar to Boolean array indexing in numpy, we can filter pandas Series or DataFrames based on conditions.\nLet’s filter to find cities with populations over 15 million:\n\n\n\n\n\n\nWe can break this down into steps. First, create the filter:\n\n\n\n\n\n\nThe filter contains True and False values for each index. We can apply this filter to our original column:\n\n\n\n\n\n\nWe can also filter the entire DataFrame:\n\n\n\n\n\n\nThis is equivalent to writing:\n\n\n\n\n\n\n\nFiltering with Multiple Conditions\nWe can filter using multiple conditions with bitwise operators & (and) and | (or). Each condition must be surrounded by round brackets.\nTo find populations in a range between 15 and 25 million:\n\n\n\n\n\n\nWe can filter on multiple columns at once:\n\n\n\n\n\n\nThis shows all rows where the city population is greater than 15 million and the area is greater than 2000 square kilometres.",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#reading-data-from-files",
    "href": "13/lecture_pandas.html#reading-data-from-files",
    "title": "Pandas",
    "section": "Reading Data from Files",
    "text": "Reading Data from Files\nOne of the main strengths of pandas is its powerful tools for reading tabulated data. The read_csv() function is extremely versatile for reading comma separated value (csv) files.\n\nWhat is a CSV file?\nCSV stands for “comma separated values”. These are plain text files where data columns are separated by commas. They are much simpler than Excel files and can be read by any software capable of reading text.\nExample of a CSV file content:\nH2O,Water,18.01528\nCO2,Carbon Dioxide,44.0095\nC6H12O6,Glucose,180.156\n\n\nReading CSV files with pandas\nHere’s an example of reading a csv file:\n\n\n\n\n\n\nIn this code: - We provide the read_csv() function with the filename (required input) - We use the optional skiprows parameter to ignore header lines - This creates a DataFrame object from the data in the file - Column names are pulled from the first row that is read (after skipped rows)\nThis reads the data from the csv file into a pandas DataFrame. From here, we can manipulate and analyze the data using all the tools we’ve discussed above.\nA key option for read_csv() is the sep parameter, which allows you to specify a different delimiter if your data is not comma-separated. For example, if your data is tab-separated, you can use sep='\\t'.\nWe can see some examples here below where (for convenience) we use the StringIO module to simulate reading from a file, so that the content of the “file” is immediately apparent in the code snippet itself:\n\n\n\n\n\n\nA similar example below, but with triple quotes for the multi-line string and an arbitrarily different separator (;):",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "13/lecture_pandas.html#conclusion",
    "href": "13/lecture_pandas.html#conclusion",
    "title": "Pandas",
    "section": "Conclusion",
    "text": "Conclusion\nWe covered the basics of the pandas module, including creating and manipulating DataFrames, accessing rows and columns, performing operations, filtering data, and reading data from CSV files.\npandas is the central tool for data analysis in Python.\nIt may appear to duplicate some of the opearations we have seen earlier with numpy or vanilla Python. However, the case for using pandas lies in its data organisation and teh construction of coherent pipelines.\nCaveats.\n\npandas has a rather specific syntax, and learning it can take a while. It is important to explore the documentation, notably its tutorials:\n\nhttps://pandas.pydata.org/pandas-docs/stable/getting_started/intro_tutorials/index.html\n\npandas is also a good example of a situation where copying and adapting code snippets from online resources (e.g. Stack Overflow) is a common practice.\nIt is also a good idea to keep a “cheat sheet” of common operations handy for reference.\nFinally, LLM have normally a good knowledge of pandas and can be a useful resource for quick questions.",
    "crumbs": [
      "Home",
      "13 `pandas` series and data frames",
      "Pandas"
    ]
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html",
    "href": "14/slides_pandas_preprocessing.html",
    "title": "Pandas Data Preprocessing",
    "section": "",
    "text": "Pandas provides flexible data ingestion capabilities that allow you to read data from various sources. The read_csv() function is particularly versatile, accepting both local file paths and public URLs. This makes it easy to work with data stored on your computer or hosted online without changing your code structure."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#loading-data-from-multiple-sources",
    "href": "14/slides_pandas_preprocessing.html#loading-data-from-multiple-sources",
    "title": "Pandas Data Preprocessing",
    "section": "",
    "text": "Pandas provides flexible data ingestion capabilities that allow you to read data from various sources. The read_csv() function is particularly versatile, accepting both local file paths and public URLs. This makes it easy to work with data stored on your computer or hosted online without changing your code structure."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#initial-data-exploration",
    "href": "14/slides_pandas_preprocessing.html#initial-data-exploration",
    "title": "Pandas Data Preprocessing",
    "section": "Initial Data Exploration",
    "text": "Initial Data Exploration\nBefore manipulating data, always understand its structure. Check the shape, column names, data types, and missing values. The .info() method provides a comprehensive overview in one call."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#statistical-summaries-with-.describe",
    "href": "14/slides_pandas_preprocessing.html#statistical-summaries-with-.describe",
    "title": "Pandas Data Preprocessing",
    "section": "Statistical Summaries with .describe()",
    "text": "Statistical Summaries with .describe()\nThe .describe() method computes summary statistics (count, mean, std, min, max, quartiles) for all numerical columns. The output is itself a DataFrame, allowing further operations."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#converting-to-datetime-types",
    "href": "14/slides_pandas_preprocessing.html#converting-to-datetime-types",
    "title": "Pandas Data Preprocessing",
    "section": "Converting to Datetime Types",
    "text": "Converting to Datetime Types\nDate columns are often read as text by default. Converting them to datetime objects using pd.to_datetime() unlocks temporal operations like filtering by date ranges, extracting components, and creating time-aware visualizations."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#setting-a-meaningful-index",
    "href": "14/slides_pandas_preprocessing.html#setting-a-meaningful-index",
    "title": "Pandas Data Preprocessing",
    "section": "Setting a Meaningful Index",
    "text": "Setting a Meaningful Index\nFor time series data, using the date as the index simplifies plotting and slicing. Use set_index() to assign a column as the index and .drop(axis=1) to remove unnecessary columns."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#detecting-missing-values",
    "href": "14/slides_pandas_preprocessing.html#detecting-missing-values",
    "title": "Pandas Data Preprocessing",
    "section": "Detecting Missing Values",
    "text": "Detecting Missing Values\nReal-world data often has missing values (NaN). Use .isnull() to identify them and .sum() to count missing values per column. Understanding where and why data is missing guides your handling strategy."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#strategies-for-handling-missing-data",
    "href": "14/slides_pandas_preprocessing.html#strategies-for-handling-missing-data",
    "title": "Pandas Data Preprocessing",
    "section": "Strategies for Handling Missing Data",
    "text": "Strategies for Handling Missing Data\nThree main approaches: drop rows/columns (sparse data), fill with values like mean or median (simple imputation), or interpolate from surrounding values (time series). Choose based on your data’s nature and missingness patterns."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#interpolation-for-time-series",
    "href": "14/slides_pandas_preprocessing.html#interpolation-for-time-series",
    "title": "Pandas Data Preprocessing",
    "section": "Interpolation for Time Series",
    "text": "Interpolation for Time Series\nInterpolation estimates missing values from neighboring points. Linear interpolation draws straight lines between known values. More sophisticated methods (polynomial, spline) exist but require more computation and careful application."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#extracting-date-components",
    "href": "14/slides_pandas_preprocessing.html#extracting-date-components",
    "title": "Pandas Data Preprocessing",
    "section": "Extracting Date Components",
    "text": "Extracting Date Components\nDatetime objects have useful attributes like .year, .month, .day, .dayofweek, etc. Extract month names with .month_name() or quarters with .quarter for seasonal analysis and grouping."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#functional-programming-with-.apply",
    "href": "14/slides_pandas_preprocessing.html#functional-programming-with-.apply",
    "title": "Pandas Data Preprocessing",
    "section": "Functional Programming with .apply()",
    "text": "Functional Programming with .apply()\nUse .apply() to apply custom functions to DataFrame columns. Functions are first-class objects that can be passed as arguments, enabling you to create derived features with custom logic."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#creating-derived-features",
    "href": "14/slides_pandas_preprocessing.html#creating-derived-features",
    "title": "Pandas Data Preprocessing",
    "section": "Creating Derived Features",
    "text": "Creating Derived Features\nCreate new columns through arithmetic operations or boolean conditions. Derived features encode domain knowledge into your data structure, like temperature ranges or threshold-based flags."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#grouping-and-aggregation",
    "href": "14/slides_pandas_preprocessing.html#grouping-and-aggregation",
    "title": "Pandas Data Preprocessing",
    "section": "Grouping and Aggregation",
    "text": "Grouping and Aggregation\nThe .groupby() method aggregates data by categories. Chain three operations: group by a column, select columns to aggregate, and apply an aggregation function (mean, sum, count, etc.)."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#exporting-cleaned-data",
    "href": "14/slides_pandas_preprocessing.html#exporting-cleaned-data",
    "title": "Pandas Data Preprocessing",
    "section": "Exporting Cleaned Data",
    "text": "Exporting Cleaned Data\nAfter preprocessing, save your cleaned data for future use. Pandas supports CSV (.to_csv()), Excel (.to_excel()), JSON, SQL, and more. Some formats require additional libraries."
  },
  {
    "objectID": "14/slides_pandas_preprocessing.html#hands-on",
    "href": "14/slides_pandas_preprocessing.html#hands-on",
    "title": "Pandas Data Preprocessing",
    "section": "Hands on!",
    "text": "Hands on!\n\nYou will find a wroked through example in the lecture notebook\nThe exercises will take you through two exercises using real world datasets to practice the concepts covered today."
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html",
    "href": "14/exercises_pandas_preprocessing.html",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "",
    "text": "In this notebook, you’ll practice essential data preprocessing skills with two real-world datasets:\nThrough these exercises, you’ll learn:",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-1-load-weather-data",
    "href": "14/exercises_pandas_preprocessing.html#exercise-1-load-weather-data",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 1: Load Weather Data",
    "text": "Exercise 1: Load Weather Data\nThe UK Met Office provides historical weather data for stations across the UK. Your task is to load data from Yeovilton station in Somerset, England. The data file is text-based but contains metadata lines at the top before the actual data begins.\nData Source: https://www.metoffice.gov.uk/pub/data/weather/uk/climate/stationdata/yeoviltondata.txt\nThe Met Office weather data contains monthly measurements from Yeovilton station:\n\nyyyy: Year (4 digits, e.g., 1964)\nmm: Month (1-12, where 1 = January, 12 = December)\ntmax: Maximum temperature for the month (°C)\ntmin: Minimum temperature for the month (°C)\naf: Air frost days - number of days when temperature fell below 0°C\nrain: Total monthly rainfall (millimeters)\nsun: Total monthly sunshine duration (hours)\n\nGoal: Load the weather data, skipping metadata, and display the first rows to verify.\nHints: - pd.read_csv(url, ...): Reads data from a URL or file path - the option skiprows=[0,1,2,3] can skip specific lines (in this case line 0,1,2,3) - The option sep='\\s+' uses whitespace as separator (regex for “one or more spaces/tabs”) - The option on_bad_lines='skip' skips malformed lines - .head() Display first 5 rows to confirm data loaded correctly - .shape Returns (rows, columns) showing DataFrame dimensions",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-2-clean-and-prepare-weather-data",
    "href": "14/exercises_pandas_preprocessing.html#exercise-2-clean-and-prepare-weather-data",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 2: Clean and Prepare Weather Data",
    "text": "Exercise 2: Clean and Prepare Weather Data\nRaw data requires transformation before analysis. The Met Office data uses separate year and month columns, has ‘—’ for missing values, and some numeric columns may be stored as strings.\nGoal: Create a clean DataFrame with datetime index, proper numeric types, and NaN for missing values. We will remove the NaN afterwards.\nExpected columns: yyyy (year), mm (month), tmax (max temp °C), tmin (min temp °C), af (air frost days), rain (mm), sun (hours)\nHints:\n\nUse .dtypes to check tha data type\ndf.info(): Shows columns, data types, and non-null counts\npd.to_datetime({'year': df['yyyy'], 'month': df['mm'], 'day': 1}): Creates datetime from a dictionary with data from multiple columns\ndf.set_index('column', inplace=True): Sets a column as the DataFrame index\ndf.replace('---', np.nan): Replaces ‘—’ strings with NaN\npd.to_numeric(series, errors='coerce'): Converts to numeric, replacing failures with NaN\ndf.sort_index(inplace=True): Sorts by index to ensure chronological order",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-3-handle-missing-values-in-weather-data",
    "href": "14/exercises_pandas_preprocessing.html#exercise-3-handle-missing-values-in-weather-data",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 3: Handle Missing Values in Weather Data",
    "text": "Exercise 3: Handle Missing Values in Weather Data\nHistorical weather records often have gaps due to equipment failures or missing measurements. Your approach should depend on the nature of each measurement.\nGoal: Analyze missing value patterns and apply appropriate filling strategies. Check that no missing values remain.\nData characteristics: - Temperature: Changes gradually (good for interpolation) - Rainfall: Variable; 0mm vs missing are different - Sunshine/frost: Could be 0 (none) or missing (not recorded)\nHints:\n\ndf.isnull().sum(): Counts missing (NaN) values per column\n.interpolate(method='linear'): Estimates missing values from surrounding values (good for gradual changes)\n.fillna(0): Replaces NaN with 0 (use carefully—only when 0 is plausible or to mark a period where data is missing)\n.fillna(method='ffill'): Forward fill—propagates last valid value forward\n.fillna(method='bfill'): Backward fill—propagates next valid value backward\n\nReflect: Why is interpolation better for temperature than rainfall?",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-4-extract-date-components-and-create-weather-features",
    "href": "14/exercises_pandas_preprocessing.html#exercise-4-extract-date-components-and-create-weather-features",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 4: Extract Date Components and Create Weather Features",
    "text": "Exercise 4: Extract Date Components and Create Weather Features\nFeature engineering creates new variables to reveal patterns. Extract date components (month, season) and create derived measurements (temperature range, extremes).\nGoal: Add columns for\n\nyear\nmonth name\nseason\ntemperature range\nmean temp\nhot months (the maximum temp &gt; 25)\n\nHints:\n\ndf.index.year, df.index.month, df.index.quarter: Extract year, month (1-12), or quarter (1-4)\ndf.index.month_name(): Returns full month name (‘January’, etc.)\nCustom function + .apply(): Create season mapper: def get_season(month): ... then df['season'] = df['month'].apply(get_season)",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-5-analyze-weather-patterns-with-groupby",
    "href": "14/exercises_pandas_preprocessing.html#exercise-5-analyze-weather-patterns-with-groupby",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 5: Analyze Weather Patterns with GroupBy",
    "text": "Exercise 5: Analyze Weather Patterns with GroupBy\nThe groupby() operation splits data into groups, applies functions (like mean), then combines results.\nYou can group by month, season, year, or decade to analyze climate patterns.\nGoal: Calculate the typical (mean) monthly temperature, rainfall, and sunshine for each month and season.\nHints:\n\ndf.groupby('column')['measurement1'].mean(): Groups and calculates mean for one column\ndf.groupby('column')[['col1', 'col2']].mean(): Groups and calculates means for multiple columns\n\nMore advanced question: Can you define decades and analyze trends over decades?\n\n\n\n\n\n\nTo analyse over decades, we need a new column for the 1960s, 1970s, etc etc. We can create this by integer division of the year by 10, then multiplying back by 10. For example, for year 1964:(1964 // 10) * 10 = 1960.",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-6-load-and-explore-wine-quality-data",
    "href": "14/exercises_pandas_preprocessing.html#exercise-6-load-and-explore-wine-quality-data",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 6: Load and Explore Wine Quality Data",
    "text": "Exercise 6: Load and Explore Wine Quality Data\nShift from time series to cross-sectional data. This UCI dataset contains physicochemical measurements of Portuguese red wines with quality ratings from experts.\nDataset: 11 chemical properties + 1 quality score (0-10).\nFeatures (chemical properties, units in parentheses):\n\nfixed acidity (g/L tartaric acid)\nvolatile acidity (g/L acetic acid)\ncitric acid (g/L)\nresidual sugar (g/L)\nchlorides (g/L sodium chloride)\nfree sulfur dioxide (mg/L)\ntotal sulfur dioxide (mg/L)\ndensity (g/cm³)\npH (0-14 scale)\nsulphates (g/L potassium sulphate)\nalcohol (% vol)\n\nTarget:\n\nquality (score 0-10, median expert ratings)\n\nEach row = different wine sample.\nImportant: File uses semicolons as delimiter, not commas.\nData Source: https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv\nGoal: Load data correctly and look at its shape and summary statistics.\nHints:\n\npd.read_csv(url, sep=';'): Specify semicolon delimiter\n.head(), .tail(): Show first/last rows\n.shape: Returns (n_rows, n_columns)\n.info(): Summary of columns, types, non-null counts\n.describe(): Statistics (mean, std, min, max, quartiles) for numeric columns\n.isnull().sum(): Count missing values per column",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-7-create-wine-quality-categories-and-clean-data",
    "href": "14/exercises_pandas_preprocessing.html#exercise-7-create-wine-quality-categories-and-clean-data",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 7: Create Wine Quality Categories and Clean Data",
    "text": "Exercise 7: Create Wine Quality Categories and Clean Data\nConvert continuous variables into categorical groupings for easier pattern recognition. This is called binning or discretization.\nGoal: We will create three categorical columns:\n\nquality_cat: ‘Poor’ (0-4), ‘Average’ (5-6), ‘Good’ (7-10)\nsugar_level: which is ‘Dry’ (&lt;9g/L), ‘Medium-Dry’ (9-18g/L), ‘Sweet’ (&gt;18g/L)\n\nWe then construct a table showing counts of wines in each quality category by sugar level. This is called a contingency table. and can be produced with pd.crosstab().\nHints:\n\npd.cut(series, bins=[...], labels=[...]): Bins continuous data into categories\nbins=[0, 4, 6, 10] creates bins: 0-4, 4-6, 6-10\n.value_counts(): Shows how many items in each category\npd.crosstab(df['cat1'], df['cat2']): Contingency table showing counts for category combinations",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-8-create-derived-features",
    "href": "14/exercises_pandas_preprocessing.html#exercise-8-create-derived-features",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 8: Create Derived Features",
    "text": "Exercise 8: Create Derived Features\nCombine existing variables to create more informative features.\nGoal: Engineer new features by combining chemical measurements:\n\nTotal Acidity: Sum fixed + volatile acidity for total acidity\nAcidity ratio: fixed divided by volatile acidity\nBalance ratios: Create sweetness-to-total-acidity ratio to measure wine balance\nStandardized scores: Calculate z-scores for alcohol to normalize its scale. This is defined for a value in a popluation of given mean and standard deviation as (value - mean) / std deviation.\n\nThen analyze which derived features correlate most strongly with wine quality.\nHints:\n\nThe df[selected_cols].corr() method can help identify strong relationships between selected columns\nThe .describe() method allows you to check derived features have reasonable values",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-9-wine-discovery-through-filtering",
    "href": "14/exercises_pandas_preprocessing.html#exercise-9-wine-discovery-through-filtering",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 9: Wine Discovery Through Filtering",
    "text": "Exercise 9: Wine Discovery Through Filtering\nLet’s use filtering to discover interesting wines in the dataset! Think of this as being a wine explorer—you’ll use boolean conditions to find wines that match specific criteria.\nGoal: Use pandas filtering to discover\n\nHidden gems: Good wines that don’t rely on high alcohol (less than 11%)\nFresh & balanced: Wines with low volatile acidity (&lt; 0.4) and good citric acid (&gt;0.3)\n\nPrint the top 5 results for each query, sorted by quality descending. In particular, print out the following columns: citric acid, total sulfur dioxide, sulphates,alcohol, acidity ratio, quality.\nHints:\n\ndf[df['column'] &gt; value] filters rows where condition is true\nCombine conditions: df[(condition1) & (condition2)] (AND), df[(condition1) | (condition2)] (OR)\n.sort_values('column', ascending=False) sorts by a column\n.head(n) shows top n results",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  },
  {
    "objectID": "14/exercises_pandas_preprocessing.html#exercise-10-export-and-document-your-analysis",
    "href": "14/exercises_pandas_preprocessing.html#exercise-10-export-and-document-your-analysis",
    "title": "Pandas Data Preprocessing - Exercises",
    "section": "Exercise 10: Export and Document Your Analysis",
    "text": "Exercise 10: Export and Document Your Analysis\n(this can only work on Noteable)\nPreserve your work by exporting cleaned data and documenting your process. Specifically, export your data in at least two different formats.\nHints:\n\n.to_csv('file.csv'): Exports to CSV. Use index=False to exclude index (wine) or index=True to include it (weather)\n.to_excel('file.xlsx'): Exports to Excel (requires openpyxl)\n.to_json('file.json', orient='index'): Exports to JSON (orient='records' or orient='index')\npd.read_csv('file.csv'): Read back to verify export\npd.DataFrame(dict): Create documentation tables from dictionaries",
    "crumbs": [
      "Home",
      "14 Pre-processing data frames",
      "Pandas Data Preprocessing - Exercises"
    ]
  }
]