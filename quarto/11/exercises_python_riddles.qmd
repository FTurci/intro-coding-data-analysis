---
title: Consolidation - `Python` riddles
jupyter: python3
---



Solve the following using standard Python features and built-in functions.

If possible, work in the **pair programming** paradigm: work in pairs, with one person taking the role of the **driver** (writing the code) and one taking the role of the **navigator** (reading and understanding the documentation). Alternate the roles. Try to find solutions that are **short** (i.e. few line sof code) but **easy to understand**.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# YOUR CODE HERE
```

**Palyndrome checker**

- Riddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function `is_palindrome(s)` that takes an object `s`, checks that it is a string and returns `True` if `s` is a palindrome and `False` otherwise. 
- Test it with the following test cases: `is_palindrome("racecar")-->True` , `is_palindrome("hello")-->False` and  `is_palindrome(3)-->error`


Hint: an object is a string if `typ(s)` returns `str`.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
#YOUR CODE HERE
```

**The Peak Finder**

- Riddle: In a list of numbers, a "peak" is a number that is greater than both its neighbors. The first and last elements can only be peaks if they're greater than their single neighbor. Write `find_peaks(data)` that returns a list of all peak values (not their positions, just the values).

  Example: In `[1, 3, 2, 5, 4, 6, 1]`, the peaks are `[3, 5, 6]` because:
  - 3 > 1 and 3 > 2 ✓
  - 5 > 2 and 5 > 4 ✓
  - 6 > 4 and 6 > 1 ✓

- Test cases:
  - `find_peaks([1, 3, 2, 5, 4, 6, 1])` → `[3, 5, 6]`
  - `find_peaks([1, 2, 3, 4, 5])` → `[5]` (only the last element)
  - `find_peaks([5, 4, 3, 2, 1])` → `[5]` (only the first element)
  - `find_peaks([1, 1, 1])` → `[]` (no peaks - they must be strictly greater!)

Hint: Loop through indices 0 to len(data)-1 and check neighbors carefully at the boundaries.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Test data for Peak Finder
test_data_peaks_1 = [1, 3, 2, 5, 4, 6, 1]
test_data_peaks_2 = [1, 2, 3, 4, 5]
test_data_peaks_3 = [5, 4, 3, 2, 1]
test_data_peaks_4 = [1, 1, 1]
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# YOUR CODE HERE
```

**The Frequency Detective**

- Riddle: In a dataset, you want to find the value that appears most often (the "mode"). But here's the twist: if there's a tie, return the *smallest* value among the most frequent ones. Write `find_mode(data)` to solve this mystery.

  Example: In `[1, 2, 2, 3, 3, 4]`, both 2 and 3 appear twice. Return `2` (smallest of the tied values).

- Test cases:
  - `find_mode([1, 2, 2, 3, 3, 4])` → `2` (2 and 3 tied at 2 occurrences, but 2 is smaller)
  - `find_mode([5, 5, 3, 3, 3, 1])` → `3` (appears 3 times, most frequent)
  - `find_mode([7, 7, 7, 2, 2, 2])` → `2` (tied at 3 occurrences, 2 is smaller)
  - `find_mode([4])` → `4` (single element)

Hint: Count occurrences with a dictionary, find the maximum count, then among all values with that count, return the minimum.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Test data for Frequency Detective
test_data_mode_1 = [1, 2, 2, 3, 3, 4]
test_data_mode_2 = [5, 5, 3, 3, 3, 1]
test_data_mode_3 = [7, 7, 7, 2, 2, 2]
test_data_mode_4 = [4]
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# YOUR CODE HERE
```

