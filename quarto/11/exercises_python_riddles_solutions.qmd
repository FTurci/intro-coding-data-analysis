---
title: Consolidation - `Python` riddles
jupyter: python3
---



Solve the following using standard Python features and built-in functions.

If possible, work in the **pair programming** paradigm: work in pairs, with one person taking the role of the **driver** (writing the code) and one taking the role of the **navigator** (reading and understanding the documentation). Alternate the roles. Try to find solutions that are **short** (i.e. few line sof code) but **easy to understand**.

**Sum of Digits**
- Riddle: Write a function `sum_digits(n)` that takes an integer `n` and returns the sum of its digits.
- Test it with the following test cases: `sum_digits(145)-->10` and `sum_digits(102)-->3`

Hint: remember that you can convert an integer to a string with `str(n)` and a character `c` to integer with `int(c)`.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
def sum_digits(n):
    return sum(int(c) for c in str(n))

assert sum_digits(102)==3
assert sum_digits(145)==10
```

**Palyndrome checker**

- Riddle: A word is a palyndrome if it reads the same forwards and backwards. Write a function `is_palindrome(s)` that takes an object `s`, checks that it is a string and returns `True` if `s` is a palindrome and `False` otherwise. 
- Test it with the following test cases: `is_palindrome("racecar")-->True` , `is_palindrome("hello")-->False` and  `is_palindrome(3)-->error`


Hint: an object is a string if `typ(s)` returns `str`.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
#YOUR CODE HERE
def is_palindrome(s):
    if type(s) == str:
        return s == s[::-1]
    else:
        print("Error: Input is not a string.")
        return

assert is_palindrome("racecar")==True
assert is_palindrome("hello")==False

is_palindrome(3)
```

**The Peak Finder**

- Riddle: In a list of numbers, a "peak" is a number that is greater than both its neighbors. The first and last elements can only be peaks if they're greater than their single neighbor. Write `find_peaks(data)` that returns a list of all peak values (not their positions, just the values).

  Example: In `[1, 3, 2, 5, 4, 6, 1]`, the peaks are `[3, 5, 6]` because:
  - 3 > 1 and 3 > 2 ✓
  - 5 > 2 and 5 > 4 ✓
  - 6 > 4 and 6 > 1 ✓

- Test cases:
  - `find_peaks([1, 3, 2, 5, 4, 6, 1])` → `[3, 5, 6]`
  - `find_peaks([1, 2, 3, 4, 5])` → `[5]` (only the last element)
  - `find_peaks([5, 4, 3, 2, 1])` → `[5]` (only the first element)
  - `find_peaks([1, 1, 1])` → `[]` (no peaks - they must be strictly greater!)

Hint: Loop through indices 0 to len(data)-1 and check neighbors carefully at the boundaries.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Test data for Peak Finder
test_data_peaks_1 = [1, 3, 2, 5, 4, 6, 1]
test_data_peaks_2 = [1, 2, 3, 4, 5]
test_data_peaks_3 = [5, 4, 3, 2, 1]
test_data_peaks_4 = [1, 1, 1]
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
def find_peaks(data):
    peaks = []
    n = len(data)
    
    for i in range(n):
        # Check first element
        if i == 0:
            if n > 1 and data[i] > data[i+1]:
                peaks.append(data[i])
        # Check last element
        elif i == n - 1:
            if data[i] > data[i-1]:
                peaks.append(data[i])
        # Check middle elements
        else:
            if data[i] > data[i-1] and data[i] > data[i+1]:
                peaks.append(data[i])
    
    return peaks

# Test the function
assert find_peaks(test_data_peaks_1) == [3, 5, 6]
assert find_peaks(test_data_peaks_2) == [5]
assert find_peaks(test_data_peaks_3) == [5]
assert find_peaks(test_data_peaks_4) == []

print("All peak finder tests passed!")
```

**The Frequency Detective**

- Riddle: In a dataset, you want to find the value that appears most often (the "mode"). But here's the twist: if there's a tie, return the *smallest* value among the most frequent ones. Write `find_mode(data)` to solve this mystery.

  Example: In `[1, 2, 2, 3, 3, 4]`, both 2 and 3 appear twice. Return `2` (smallest of the tied values).

- Test cases:
  - `find_mode([1, 2, 2, 3, 3, 4])` → `2` (2 and 3 tied at 2 occurrences, but 2 is smaller)
  - `find_mode([5, 5, 3, 3, 3, 1])` → `3` (appears 3 times, most frequent)
  - `find_mode([7, 7, 7, 2, 2, 2])` → `2` (tied at 3 occurrences, 2 is smaller)
  - `find_mode([4])` → `4` (single element)

Hint: Count occurrences with a dictionary, find the maximum count, then among all values with that count, return the minimum.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Test data for Frequency Detective
test_data_mode_1 = [1, 2, 2, 3, 3, 4]
test_data_mode_2 = [5, 5, 3, 3, 3, 1]
test_data_mode_3 = [7, 7, 7, 2, 2, 2]
test_data_mode_4 = [4]
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
def find_mode(data):
    # Count occurrences using a dictionary
    counts = {}
    for value in data:
        counts[value] = counts.get(value, 0) + 1
    
    # Find the maximum count
    max_count = max(counts.values())
    
    # Find all values with the maximum count and return the smallest
    modes = [value for value, count in counts.items() if count == max_count]
    return min(modes)

# Test the function
assert find_mode(test_data_mode_1) == 2
assert find_mode(test_data_mode_2) == 3
assert find_mode(test_data_mode_3) == 2
assert find_mode(test_data_mode_4) == 4

print("All frequency detective tests passed!")
```

