---
title: 'Intermediate: Flexible Inputs and Outputs'
jupyter: python3
---

### Table of Contents

 - [Welcome Page](./week_04_home.qmd)

 - [Beginner: Defining Functions](./week_04_functions_beginner.qmd)
 - [**Intermediate: Flexible Inputs and Outputs**](./week_04_functions_intermediate.qmd)
    - [Parameters and Arguments](#Parameters-and-Arguments)
    - [Arbitrary Positional and Keyword Arguments](#Arbitrary-Positional-and-Keyword-Arguments)
    - [Positional-Only and Keyword-Only Arguments](#Positional-Only-and-Keyword-Only-Arguments)
    - [Multiple Returns](#Multiple-Returns)
    - [Recursion](#Recursion)
    - [Exercises](#Exercises)
 - [Advanced: Lambda Functions and Functional Programming](./week_04_functions_advanced.qmd)
 - [Slides](./week_04_slides.qmd) ([Powerpoint](./Lecture4_Functions.pptx))

## Parameters and Arguments

In this week's [beginner notebook](./week_04_functions_beginner.qmd), we introduced functions and described the values they take in and give out as *inputs* and *outputs*. In this notebook, we will use some more precise Python terminology for inputs: *parameters* and *arguments*.

 - A *parameter* is the variable listed in a function's definition. It acts as a placeholder that says "this function expects a value here."
 - An *argument* is the actual value you provide when calling the function.

For instance, consider the simple function below:

```{pyodide}
def greet(name):      # here, `name` is a parameter
    print("Hello,", name)

greet("Sofia")        # here, "Sofia" is an argument
```

In this case, `name` is the parameter. It is the label inside the function that will hold the input. `"Sofia"` is the argument. It is the concrete value we supply when calling the function.


There are two main ways to pass arguments to a function in Python:
 - *Positional arguments* are matched to parameters by the order they appear.
 - *Keyword arguments* are matched to parameters by name, using the `parameter=value` syntax.

To see what we mean here, consider the following example:

```{pyodide}
def make_greeting(greeting, name):
    print(f"{greeting}, {name}!")

# Using positional arguments (order matters)
make_greeting("Hello", "Brad")

# Using keyword arguments (order does not matter)
make_greeting(name="Liam", greeting="Hi")
```

The first call to `make_greeting` uses positional arguments. This means that arguments are assigned based on the order they are passed into the function. Here, `"Hello"` is matched to `greeting` and `"Brad"` is matched to `name` by position.

The second call to `make_greeting` uses keyword arguments. This means that the arguments are matched by name, using the `parameter=value` syntax. Here, `"Liam"` goes to `name` and `"Hi"` goes to `greeting`, even though the order is reversed.

In the first half of this notebook, we will look at the different kinds of parameters Python allows us to define, and how arguments can be passed to them in flexible ways.

## Arbitrary Positional and Keyword Arguments

Sometimes when coding you may want a function to allow an arbitrary number of inputs. This can be useful because it reduces repetition and makes your code cleaner.

For example, consider the following repetitive code:

```{pyodide}
def add_two_numbers(x, y):
    return x + y

def add_three_numbers(x, y, z):
    return x + y + z

def add_four_numbers(x, y, z, w):
    return x + y + z + w
 
print(add_two_numbers(8,1))            # 9
print(add_three_numbers(1, 2, 3))      # 6
print(add_four_numbers(4, 5, 6, 7))    # 22
```

This is not very efficient. It would be much easier if we could just write one function that sums *any* number of values. One way to do this is to pass a tuple:

```{pyodide}
def add_tuple_of_numbers(my_tuple):
    total = 0
    for number in my_tuple:
        total = total + number
    return total

print(add_tuple_of_numbers((8,1)))          # 9
print(add_tuple_of_numbers((1, 2, 3)))      # 6
print(add_tuple_of_numbers((4, 5, 6, 7)))   # 22
```

This works, but notice that the function calls require two sets of round brackets, which, even for this simple example, is slightly clunky and could easily lead to mistakes.

Python provides a cleaner way of writing the above code using the `*` operator. This collects all positional arguments into a single tuple inside the function like so:

```{pyodide}
def add_numbers(*my_tuple):
    total = 0
    for number in my_tuple:
        total = total + number
    return total

print(add_numbers(8,1))            # 9             # Note the number of () brackets!!
print(add_numbers(1, 2, 3))        # 6
print(add_numbers(4, 5, 6, 7))     # 22
```

The code inside the function is essentially the same, but now the function calls look much cleaner since we can pass in values directly without square brackets. 

By convention, when using the `*` operator to pass arbitrary positional arguments into a function, we name the tuple we pass in `args`, which stands for "arguments".

```{pyodide}
def add_numbers(*args):
    total = 0
    for number in args:
        total = total + number
    return total

print(add_numbers(8,1))            # 9
print(add_numbers(1, 2, 3))        # 6
print(add_numbers(4, 5, 6, 7))     # 22
```

So far we have seen how to accept an arbitrary number of *positional* arguments. But what if we want to accept an arbitrary number of *keyword* arguments? 

Imagine we tried to write separate functions for describing a person:

```{pyodide}
def describe_person_by_name(name):
    print("This person's name is " + str(name) + ".")
    print("")

def describe_person_by_age(age):
    print("This person's age is " + str(age) + ".")
    print("")

def describe_person_by_name_and_age(name, age):
    print("This person's name is " + str(name) + ".")
    print("This person's age is " + str(age) + ".")
    print("")

def describe_person_by_name_and_age_and_job(name, age, job):
    print("This person's name is " + str(name) + ".")
    print("This person's age is " + str(age) + ".")
    print("This person's job is " + str(job) + ".")
    print("")

# Example function calls
describe_person_by_name("Elliot")
describe_person_by_age(27)
describe_person_by_name_and_age_and_job("Elliot", 27, "doctor")
```

This code is pretty repetitive and messy. One way we could imagine simplifying this code is by using `if` statements and a dictionary, like so:

```{pyodide}
def describe_person_by_dict(my_dict):
    
    if "name" in my_dict:
        print("This person's name is " + str(my_dict["name"]))
        
    if "age" in my_dict:
        print("This person's age is " + str(my_dict["age"]))
        
    if "job" in my_dict:
        print("This person's job is " + str(my_dict["job"]))
        
    print("")

# Example function calls
describe_person_by_dict({"name":"Elliot"})
describe_person_by_dict({"age":27})
describe_person_by_dict({"name":"Elliot", 
                         "age":27, 
                         "job":"doctor"})
```

This works, but again the code feel awkward because we now have to write out a dictionary whenever we call the function.

Python provides a cleaner way of writing the above code the `**` operator. This gathers all keyword arguments into a dictionary inside the function:

```{pyodide}
def describe_person(**my_dict):
    
    if "name" in my_dict:
        print("This person's name is " + str(my_dict["name"]))
        
    if "age" in my_dict:
        print("This person's age is " + str(my_dict["age"]))
        
    if "job" in my_dict:
        print("This person's job is " + str(my_dict["job"]))
        
    print("")


# Example function calls
describe_person(name="Elliot")
describe_person(age=27)
describe_person(name="Elliot", age=27, job="doctor")
```

Instead of naming the dictionary `my_dict` like in the above code, by convention we use tend to use the name `kwargs`, which is short for "*keyword arguments*".

```{pyodide}
def describe_person(**kwargs):
    
    if "name" in kwargs:
        print("This person's name is " + str(kwargs["name"]))
        
    if "age" in kwargs:
        print("This person's age is " + str(kwargs["age"]))
        
    if "job" in kwargs:
        print("This person's job is " + str(kwargs["job"]))
        
    print("")
    

# Example function calls
describe_person(name="Elliot")
describe_person(age=27)
describe_person(name="Elliot", age=27, job="doctor")
```

In the same way that we can write a function which takes as input both a tuple and a dictionary, such as below:

```{pyodide}
def demo_function_with_tuple_and_dict(my_tuple, my_dict):
    print("Tuple:", my_tuple)
    print("Dictionary:", my_dict)

demo_function_with_tuple_and_dict((1, 2, 3), {"name":"Alice", "age":30})
```

We can instead write a function that takes both arbitrary positional arguments and arbitrary keyword arguments, using `*args` and `**kwargs`:

```{pyodide}
def demo_function(*args, **kwargs):
    print("Positional arguments:", args)
    print("Keyword arguments:", kwargs)

demo_function(1, 2, 3, name="Alice", age=30)
```

## Positional-Only and Keyword-Only Arguments

So far, we have seen that function arguments in Python can normally be passed either by position or by keyword:

```{pyodide}
def multiply(x, y):
    return x * y

print(multiply(2, 3))        # by position
print(multiply(x=2, y=3))    # by keyword
```

Both calls work the same way. But sometimes we want more control. Python gives us two special symbols for this:

 - `/` means everything to the left of it must be positional-only.
 - `*` means everything to the right of it must be keyword-only.
 
So you can think of `/` and `*` as markers in the parameter list that divide it into three possible regions:

``` my_function(a,b,/,c,d,*,e,f)```

Here, we have that:

 - `a` and `b` are *positional-only* parameters.
 - `c` and `d` can be specified using *position or keyword*.
 - `e` and `f` are *keyword-only* parameters.
 
Let's, look at some examples. The below function will take positional arguments only:

```{pyodide}
def power(x, y, /):
    return x ** y

print(power(2, 3))       # This code will run
print(power(x=2, y=3))   # This code will error
```

Here, `x` and `y` are to the left of `/`, so they can only be given by position.

Similarly, this example will accept keyword arguments only:

```{pyodide}
def introduce(*, name, age):
    print(f"My name is {name} and I am {age} years old.")

introduce(name="Alice", age=30)   #  This will work
introduce("Alice", 30)            # This will error
```

Here, `name` and `age` are to the right of `*`, so they must be given as keywords.

We can allow a function to have a mix of all three types of parameters (positional-only, keyword or positional, or keyword-only) as follows:

```{pyodide}
def demo(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)

demo(1, 2, 3, d=4, e=5, f=6) 
```

 > **Test your Understanding:** Without writing code, consider the following expressions:
 >
 > - `demo(1, 2, c=3, d=4, e=5, f=6)`
 > - `demo(a=1, 2, 5, e=3, d=4, f=6)`
 > - `demo(1, 2, c=5, e=3, d=4, f=6)`
 > - `demo(1, 2, d=3, 4, e=5, f=6)`
 >
 > What do you think each of the above will print and why? Will any of them error? If so, which?

## Multiple Returns

So far, we've spent time looking at how you can flexibly specify arguments for functions. Now let's shift focus slightly and look at another useful trick when writing functions: *multiple return statements*.

Normally, a function ends when it reaches a `return` statement. But functions can also contain more than one `return`, which allows us to stop the function and send back a result as soon as we know what that result should be.

Here's a simple example:

```{pyodide}
def classify_score(score):
    
    if score < 50:
        return "Fail"
    
    if score < 70:
        return "Pass"
    
    return "Distinction"

print(classify_score(40))   # "Fail"
print(classify_score(65))   # "Pass"
print(classify_score(85))   # "Distinction"
```

The function stops running the moment it hits a `return`. To understand why this feature might be useful, consider the below code which computes the length of each string in a list.

```{pyodide}
def get_string_lengths(my_list):
    
    # Empty variables to store results
    result = None
    result_list = []

    # If we have no strings, the result should report taht
    if len(my_list)==0:
        result = "List was empty"
        
    # Otherwise let's look through the list
    else:
        
        # Loop through list
        for string in my_list:
            
            # If the list isn't a string, we need to record that
            if not isinstance(string, str):
                result = "List had entries which weren't strings"
                
            # Otherwise let's record the length of the strings
            else:
                result_list.append(len(string))

    # Check if we had anything go wrong
    if result is None:
        result = result_list

    # Return the result
    return result

print(get_string_lengths([]))
print(get_string_lengths(["list", "of", "words"]))
print(get_string_lengths(["not", "all", 3, "words"]))
```

This works, but it's a bit cumbersome as we are keeping track of the `result` variable throughout. We can simplify this code substantially using multiple `return` statements:

```{pyodide}
def get_string_lengths(my_list):
    
    # Empty variables to store results
    result_list = []

    # If we have no strings, the result should report taht
    if len(my_list)==0:
        return "List was empty"

    # Loop through list
    for string in my_list:
            
        # If the list isn't a string, we need to record that
        if not isinstance(string, str):
            
            return "List had entries which weren't words"
        
        # Otherwise let's record the length of the strings
        result_list.append(len(string))

    # Return the result
    return result_list

print(get_string_lengths([]))
print(get_string_lengths(["list", "of", "words"]))
print(get_string_lengths(["not", "all", 3, "words"]))
```

Now the logic is much cleaner:

 - If the list is `empty`, `return` immediately.
 - If we find a bad entry, `return` immediately.
 - Otherwise, `return` the processed list.
 
The key idea here is that a `return` statement ends the function immediately. Everything after it is skipped. You can think of it as if Python is automatically wrapping everything after a `return` in an invisible `else`.

This often makes your functions shorter, easier to read, and can help spot errors and bugs.

## Recursion

Another useful feature of the Python programming language is that it allows *recursion*. A *recursive function* is a function that calls itself. For example:

```{pyodide}
def countdown(n):
    if n == 0:
        print("Blast off!")
    else:
        print(n)
        countdown(n - 1)

countdown(5)
```

In this example, the function `countdown` calls itself with a smaller number each time. Eventually, it reaches the base case (`n == 0`) and stops.

 > **Test your Understanding:** See if you can modify the above so that, instead of counting down to zero, it counts up to 10 and then prints `Blast off!`.

Recursion can be useful for problems that can be broken down into smaller versions of the same problem, such as:

 - searching through folders and files,
 - working with tree-like data structures,
 - or classic mathematical problems like factorials.

## Exercises

**Question 1:** Consider the below function.

```{pyodide}
def printing_function(a, b, *args, **kwargs):
    print("a:", a)
    print("b:", b)
    print("args:", args)
    print("kwargs:", kwargs)
```

Without running any code, predict what will happen when you run the following function calls:

 - `printing_function(1, 2)`
 - `printing_function(1, 2, 3, 4)`
 - `printing_function(1, 2, x=10, y=20)`
 - `printing_function(1, 2, 3, 4, x=10, y=20)`

Do you think the function will error for any of the above inputs? If so, which? Verify your answers by running the code.

*Hint: Consider what would happen if you had instead passed `my_tuple` and `my_dict` into the function, like we did in the section on [arbitrary positional and keyword arguments](Arbitrary-Positional-and-Keyword-Arguments).*

**Question 2:** Write a function, `sumstrings` which takes in an arbitrary number of arguments, each a string which represents an integer between 1 and 10 (e.g. `one`, `two`, `three`,... `ten`), and returns the sum of the strings in numeric form. e.g. `sumstrings('ten', 'five', 'eight')` should return the integer 23. 

*Make it so that your function inputs are not case sensitive. I.e. an input of 'ten' should be treated the same as 'tEn', 'TEn', 'TEN', etc.*

```{pyodide}
# Write your answer here...
```

**Question 3:** Below is a function containing an `if` statement. The function has one input and one output.

```{pyodide}
def function_with_if(a=1):
    
    # If a is greater than zero, return 1
    if a > 0:
        print('Here is a print statement.')
        return(1)
    
    # If a is equal to zero, return 0
    elif a == 0:
        return(0)
    
    # Return -1
    print('Here is another print statement.')
    return(-1)
```

What do you think will be printed when you run each of the following commands?

 - `function_with_if(-1)`
 - `function_with_if(0)`
 - `function_with_if(1)`
 - `function_with_if()`

Explain your answers and verify them by running the code.

**Question 4:** Consider the following function, which takes in a positive integer:

```{pyodide}
def mystery_function(my_integer):
    
    for i in range(2, my_integer):
        
        if my_integer % i == 0:
            return False
        
    return True
```

Before running the code, try to work out what this function is supposed to do. You may wish to consider the following questions:

 - What values of `i` will the loop check?
 - What does the expression `my_integer % i` mean?
 - Under what condition does the function return `False`?

Test the function on several inputs, such as `2`, `7`, `9`, `15`, `17`. Based on your tests, describe in plain English what this function is trying to check.

**Question 5:** Consider the following recursive function:

```{pyodide}
def another_mystery_function(word):
    if word == "":
        return ""
    else:
        return mystery(word[1:]) + word[0]
```

Run this function on a few different inputs (e.g. `"hello"`, `"Python"`) and try to work out what the function is doing. Once you understand the logic of the function, try rewriting the function using a loop.

