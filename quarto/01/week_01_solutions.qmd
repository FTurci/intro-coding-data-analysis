---
title: 'Week 1: Solutions'
jupyter: python3
---



This notebook contains the solutions to the week 1 `Beginner`, `Intermediate` and `Advanced` exercises.

### Table of Contents

 - [Welcome Page](./week_01_home.qmd)
 - [Beginner: Basic Data Types](./week_01_intro_to_data_types_beginner.qmd)
 - [Intermediate: Collections](./week_01_intro_to_data_types_intermediate.qmd)
 - [Advanced: Copying and References](./week_01_intro_to_data_types_advanced.qmd)

 - [**Solutions**](./week_01_solutions.qmd)
   - [Beginner: Basic Data Types](#Beginner:-Basic-Data-Types)
   - [Intermediate: Collections](#Intermediate:-Collections)
   - [Advanced: Copying and References](#Advanced:-Copying-and-References)

## Beginner: Basic Data Types

**Question 1:** The solution to the question is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Variables x, y and z
x = 1
y = 2
z = 1.26

my_boolean = ((x**2 < y) and (y < z**3)) or ((z**3 < y) and (y < x**2))
```

**Question 2:** The solution to the question is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Boolean variables
is_raining = True
have_umbrella = False

# Boolean telling you if you are going to get rained on
got_soaked = is_raining and (not have_umbrella)

print('Question: Will I get rained on?')
print('Answer: ' + str(got_soaked))
```

**Question 3:** The completed truth table for this question is:


| `A`     | `B`     | `C`     | `A and B` | `not C` | `(A and B) or (not C)` |
|---------|---------|---------|-----------|---------|------------------------|
| `True`  | `True`  | `True`  | `True`    | `False` | `True`                 | 
| `True`  | `True`  | `False` | `True`    | `True`  | `True`                 | 
| `True`  | `False` | `True`  | `False`   | `False` | `False`                | 
| `True`  | `False` | `False` | `False`   | `True`  | `True`                 | 
| `False` | `True`  | `True`  | `False`   | `False` | `False`                | 
| `False` | `True`  | `False` | `False`   | `True`  | `True`                 | 
| `False` | `False` | `True`  | `False`   | `False` | `False`                | 
| `False` | `False` | `False` | `False`   | `True`  | `True`                 | 

And the code for this question is:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Boolean variables
A = True
B = False
C = True

# Compute new boolean
my_boolean = (A and B) or (not C)
print(my_boolean)
```

**Question 4:** The solution to this question is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Height and width variables
height = 10
width = 3

# Perimeter
perimeter = 2*(height+width)

# Area
area = height*width

# Diagonal
diag = (height**2 + width**2)**(1/2)

# Print results
print(perimeter, area, diag)
```

**Question 5:** The solution to this question is given by:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Known variables
v = 10
u = 0
a = 9.81

# Compute s
s = (v**2-u**2)/(2*a)
print(s)
```

**Question 6:** The solution to this question is given by:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Compute time using variables from Question 5
t = 2*s/(u+v)
print(t)
```

**Question 7:** A code block containing the examples from the question is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
print((True and False) or True)
print(not (False or False))
print(True or False and False)
print(False ^ True)
print((True and not True) and (False or not False))
```

The answers follow by standard boolean logic. The only difficult parts are determining the order of operations for the third example (python will interpret this as `True or (False and False)` rather than `(True or False) and False`) and the xor (`^`) on the fourth line.

**Question 8:** The error in the code occurs when `float(x + y)` is run. 

When `x` and `y` are numeric, the `+` symbol is interpreted as addition and the result is cast to a float (e.g. if `x=1` and `y=5` as in the first example then `x+y` yeilds `6`). However, if they are instead strings (as in the second example), then the `+` symbol is interpreted as concatenation rather than addition. Therefore, when `x='2'` and `y='5'`, we get that `2+5` yeilds `25`, not `7`.

There are two approaches to resolving the issue. The first is to replace `x='2'` and `y='5'` with  `x=2` and `y=5`. The second, and preferred option, is to replace `float(x + y)` with `float(x)+float(y)` so there is no possibility that the `+` symbol is interpreted as concatenation here.

**Question 9:** The first box is an assignment of the value `2 + 1` to a variable named `three`, so does not print anything. The second box prints `true` as the variable `z = (1 + 2 == 3)` is interpreted as a Boolean variable, and in Jupyter notebooks, if the last line of a box is simply a variable, with no assignment, then that variable is printed out. `z` is evaluated as `True` (as `1 + 2` does equal `3` in Python), so `True` is printed.

For the third box, `False` is printed as due to rounding errors `0.1 + 0.2` is evaluated to `0.30000000000000004` rather than `0.3`. This is a cautionary note that floating point math is not perfect.

**Question 10:** The final solution is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# The string we want to transform
start_string = 'Thas as te arang we want!'
print('Start:  ', start_string)

# Helper strings you can use for replacements
string1 = 'a'
string2 = 'st'
string3 = 'he a'
string4 = ' ge'
string5 = 'stri'
string6 = 'sts'
string7 = 'is'
string8 = 'ara'
string9 = 'gen'
string10 = 'e a'

# Step 1
step1 = start_string.replace(string1,string2)
print('Step 1: ', step1)

# Step 2
step2 = step1.replace(string6,string7)
print('Step 2: ', step2)

# Step 3
step3 = step2.replace(string2, string1)
print('Step 3: ', step3)

# Step 4
step4 = step3.replace(string10, string3)
print('Step 4: ', step4)

# Step 5
step5 = step4.replace(string8, string5)
print('Step 5: ', step5)
```

## Intermediate: Collections

**Question 1:** The code for this question is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Original list
nums = [5, 2, 8, 2, 9]
print("Original list:", nums)

# 1. Retrieve the third element (index 2 because indexing starts at 0)
third_element = nums[2]
print("Third element:", third_element)

# 2. Slice the first three elements
first_three = nums[:3]
print("First three elements:", first_three)

# 3. Replace the last element with 10
nums[-1] = 10
print("After replacing last element with 10:", nums)

# 4. Append 7 to the end of the list
nums.append(7)
print("After appending 7:", nums)

# 5. Remove the first occurrence of 2
nums.remove(2)
print("After removing first occurrence of 2:", nums)
```

**Question 2:** The key to this question is that a list is *ordered* whilst a set is *unordered*. When the list is converted to a set, it's ordering is lost, and when converted back to a list it is now given in increasing (numerical) order by default.

**Question 3:** The answer to this question is the letter `k`. To see this, the below code can be used:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Here are two strings
string1 = "This is a long random sentence - I wonder which letters it contains and which letters it doesn't."
string2 = "This task makes a clear and coherent string with words taken inside a small set"

# Make strings lowercase
string1 = string1.lower()
string2 = string2.lower()

# Convert strings to sets
string1 = set(string1)
string2 = set(string2)

# Compute the set difference
print(string2.difference(string1))
```

**Question 4:** The code for this question is provided below.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# given tuple
t = ('a', 'b', 'c', 'd', 'e')

# 1. access the first and last elements of t
first = t[0]
last = t[-1]
print("First element:", first)
print("Last element:", last)

# 2. slice out ('b', 'c', 'd')
slice_part = t[1:4]
print("Slice ('b', 'c', 'd'):", slice_part)

# 3. check whether 'c' is in t
is_c_present = 'c' in t
print("'c' in t?", is_c_present)

# 4. find the index of 'd' in t
index_d = t.index('d')
print("Index of 'd':", index_d)

# 5. count how many times 'a' appears in t
count_a = t.count('a')
print("Count of 'a':", count_a)
```

**Question 5:** There are many ways to approach this question. Two examples are given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# ----------------------------------------------------------------
# Option 1:
# ----------------------------------------------------------------
# clinical trial dataset represented as a dictionary of lists
clinical_data = {
    "Name": ["John", "Alice", "Maria", "David", "Sarah"],
    "Weight (kg)": [82, 68, 74, 90, 60],
    "Height (cm)": [178, 165, 170, 185, 160]
}

print(clinical_data)

# ----------------------------------------------------------------
# Option 2:
# ----------------------------------------------------------------
# clinical trial dataset represented as a dictionary of dictionaries
clinical_data = {
    "John": {"Weight (kg)": 82, "Height (cm)": 178},
    "Alice": {"Weight (kg)": 68, "Height (cm)": 165},
    "Maria": {"Weight (kg)": 74, "Height (cm)": 170},
    "David": {"Weight (kg)": 90, "Height (cm)": 185},
    "Sarah": {"Weight (kg)": 60, "Height (cm)": 160}
}
```

## Advanced: Copying and References

**Question 1:** The expected output is `[1,2,3,4]`. This is because `list_a` and `list_b` reference the same location in memory.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
list_a = [1, 2, 3]
list_b = list_a
list_a.append(4)
print(list_b)
```

**Question 2:** Code A will print `[1,2,3]` whilst Code B will print `[4,5,6]`. This is because, when we replace `a` with `[4,5,6]` we change the reference to point to a new location in memory, breaking the connection between `a` and `b`. However, when we change the elements in `a` individually, both `a` and `b` remain pointing to the same location in memory. Thus, when we print `b`, we get `[4,5,6]`.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
a = [1, 2, 3]
b = a
a = [4, 5, 6]
print(b)

a = [1, 2, 3]
b = a
a[0] = 4
a[1] = 5
a[2] = 6
print(b)
```

**Question 3:** The variable names `xyz` and `xyzsquared` are pointing to the same array. When we squared `xyzsquared` we also squared `xyz`. We could have avoided this by making `xyzsquared` a seperate copy of `xyz` using the `list` constructor like so:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
xyz = [1,2,3]

# Make a list of x squared, y squared, z squared
xyzsquared = list(xyz) # The change was implemented here!
xyzsquared[0] = xyzsquared[0]**2
xyzsquared[1] = xyzsquared[1]**2
xyzsquared[2] = xyzsquared[2]**2

# Get x, y and z from xyz list
x = xyz[0]
y = xyz[1]
z = xyz[2]

# Get x squared, y squared and z squared from
# xyzsquared list
xsquared = xyzsquared[0]
ysquared = xyzsquared[1]
zsquared = xyzsquared[2]

print(x + y + z + xsquared + ysquared + zsquared)
```

**Question 4:** When you do `backup = list(grid)`, Python only makes a new outer list. The smaller lists inside `([1, 2], [3, 4], [5, 6])` are still the exact same objects that grid is using. Because of that, if you change one of the inner lists, the same change shows up `backup`.

**Question 5:** The reasoning for this question is similar to that of Question 4, but noting that the three inner lists are all pointing to the same place in memory.

