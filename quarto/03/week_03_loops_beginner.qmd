---
title: 'Beginner: For and While Loops'
jupyter: python3
---



Welcome to the *Week 3 Beginner Python Notebook*. This notebook is designed for students who are just starting out with the Python programming language.  

Your task today is to read through the material carefully and complete the exercises provided at the end. These exercises are an important part of the learning process and will help you check your understanding.  

> **Important:** You have three options for today’s work:  [`Beginner`](./week_03_loops_beginner.qmd), [`Intermediate`](./week_03_loops_intermediate.qmd), or [`Advanced`](./week_03_loops_advanced.qmd). If you are new to Python, please choose this *Beginner* notebook. You will have plenty of opportunities later in the course to explore the other levels.  

In this notebook, you will be introduced to `loop`s. In particular, you will learn what an `iterator`, `iterable`, `for` loop and `while` loop are. Loops are fundamental to coding as they allow you to automatically repeat computations on a large scale.

Be sure to work through the examples and attempt all the exercises. They are designed to reinforce your learning and build your confidence.  

### Table of Contents

 - [Welcome Page](./week_03_home.qmd)

 - [**Beginner: For and While Loops**](./week_03_loops_beginner.qmd)
   - [Motivation](#Motivation)
   - [Iterators and Iterables](#Iterators-and-Iterables)
   - [`for` loops](#for-loops) 
   - [`while` loops](#while-loops)
   - [Nested Loops](#Nested-Loops)
   - [Exercises](#Exercises)

 - [Intermediate: Advanced Iteration](./week_03_loops_intermediate.qmd)
 - [Advanced: Comprehensions](./week_03_loops_advanced.qmd)
 - [Slides](./week_03_slides.qmd) ([Powerpoint](./Lecture3_Loops.pptx))

## Motivation

Over the past two weeks, we have looked at some basic data types and conditional logic in Python. This week it is time to start scaling up our computation!

To begin today, let's consider a simple coding task. Suppose you are asked to `print` the first `10` [Triangle Numbers](#https://en.wikipedia.org/wiki/Triangular_number). With only what we know so far, the code might look something like this:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# First triangle number
print(1)

# Second triangle number
print(1 + 2)

# Third triangle number
print(1 + 2 + 3)

# Fourth triangle number
print(1 + 2 + 3 + 4)

# ... and so on

# Tenth triangle number
print(1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10)
```

This code is already long and repetitive, but imagine if I'd instead asked you to go up to $100$, or $1,000$! This task would be impossible!

Loops give us a way to automate repetition. Instead of writing the same line of code again and again, we'll learn how to tell Python: "Do this thing repeatedly until I say stop."

By the end of today, you’ll be able to write the same task in just one or two lines of code.

## Iterators and Iterables

So far we've seen several basic data types in Python:

 - Numeric data types: `3`, `-10`, `4.5`
 - Strings: `"hello"`, `"Python"`
 - Booleans: `True`, `False`

But often, we want to work with more than one piece of data at once.
For example: a list of students in a class, a list of prices in a shop, or a list of daily temperatures.

In Python, a `list` is a collection of values, written inside square brackets `[]`:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
numbers = [1, 2, 3, 4, 5]
words = ["apple", "banana", "cherry"]
mixed = [10, "hello", True]
```

In the same way that `float`s, `int`s, `string`s and `boolean`s are data types in Python, so is a `list`. For example:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
type(numbers)
```

A list can contain as many elements as you want, and they don't all have to be the same type.

You can also ask for one item at a time using its `index` (position in the list). Python uses zero-indexing, which means it starts counting from `0`:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
numbers = [10, 20, 30, 40]
print(numbers[0])  # first element - 10
print(numbers[2])  # third element - 30
```

A `list` is an example of an `iterable` object. 

An iterable object is any Python object that contains a countable number of elements; in other words, it's an object that can give you it's elements *one by one*.

We've already seen two examples of *iterables*:

 - `list`s are iterables: `[10,20,30,40]` can give you `10`, `20`, `30`, `40`.
 - `string`s are also iterables: `"hello"` can give you `"h"`, `"e"`, `"l"`, `"l"`, `"o"`.

Given an iterable object, you can create something known as an `iterator`.

An iterator is a special object that lets you step through the elements of an iterable, one at a time, and remembers where you are in the process. In Python, you can create an iterator from an iterable using the built-in function `iter()`:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Create a list
numbers = [2, 3, 4, 6]

# Create an iterator from the list
iterator = iter(numbers)

# Printing the iterator won't show the elements directly.
# But the iterator still "remembers" the list's items and
# can give them to us one at a time.
print(iterator)
```

The useful thing about an iterator is that it lets us print elements out one by one, always remembering where we were up to. Specifically, we can use the built-in next function to get each element in turn:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
numbers = [2, 3, 4, 6]
iterator = iter(numbers)

# Print the first element
print(next(iterator)) 

# Print the one after that
print(next(iterator)) 

# ...and the one after that
print(next(iterator))  

# ...and the one after that
print(next(iterator))  
```

A particularly useful example of an iterable object is the output of the `range` function. You can think of `range(n)` as a compact way of representing the numbers `0, 1, 2, ..., n-1`. In other words, it produces an iterable containing the first n non-negative integers, ready to be used in computations.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Get an iterable range object
range_iterable = range(4)

# Get a range iterator
range_iterator = iter(range_iterable)

# Print the elements
print(next(range_iterator))
print(next(range_iterator))
print(next(range_iterator))
print(next(range_iterator))
```

 > **Test your understanding:** By modifying the above code, work out what happens if you give `range` two inputs instead of one. e.g. what does `range(2,4)` do?

**Recap:** In this section, we introduced a new data type, the `list`, and saw that lists (as well as strings) are examples of iterables. We also learned about iterators, which are the tools Python uses to step through those iterables one element at a time.

To summarize, here are the definitions of `iterable` and `iterator`:
 
 - `Iterable`: an object that multiple elements (like a `list` or `string`) that can be listed off one at a time.

 - `Iterator`: an object that remembers a position within an iterable and produces the next element each time you ask for it.

In the next section, we will see how you can move through values of an iterable object automatically using a `for` loop.

 > **Note:** If you would like to learn more about `list`s, have a look at the week 1 intermediate notebook on `collections`. This will show you various operations that can be performed on lists, as well as introduce you to other iterable data types such as tuples, sets and dictionaries.

## `for` loops

In the last section, we saw how an iterator can give us the elements of an iterable one at a time using the `next()` function. But having to write `next()` repeatedly is a bit repetitive and clunky... 

Python gives us a much simpler way to go through all the elements of an iterable: the `for` loop.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# List of numbers
numbers = [2, 3, 4, 6]

# for each number in my list...
for num in numbers:

    # Print it's value
    print(num)
```

In this code:

 - `numbers` is the iterable.
 - `num` is a variable that takes on the value of each element, one at a time.

The indented block of code under the loop (`print(num)`) runs once for each element.

Let's break down the general syntax of the `for` loop. The first line must contain the `for` keyword and a colon, `:`. These tell us where the `for` loop starts.


 > <pre>
 > <b>`for` keyword</b>                <b>colon</b>
 >   ↓                           ↓
 > <b>for</b> my_variable in my_iterable<b>:</b>
 >     print("My variable now equals", my_variable)
 > </pre>

Then, after the `for`, we must name a variable. Here `my_variable` is just a name you are choosing to represent an arbitrary element in the iterable object.
 > <pre>
 >   <b>variable name</b>  
 >         ↓                    
 > for <b>my_variable</b> in my_iterable:
 >     print("My variable now equals", my_variable)
 > </pre>

After the variable is named we write the the `in` keyword followed by `my_iterable`. Here `my_iterable` is the iterable variable you want to loop through (for instance, a `list` or `string`) and the `in` keyword tells us that we are looking at values *in* that iterable.
 > <pre>
 >      <b>`in` keyword</b>    <b>iterable object</b>  
 >                 ↓        ↓
 > for my_variable <b>in my_iterable</b>:
 >     print("My variable now equals", my_variable)
 > </pre>

Finally, inside the `loop`, we provide the code we want to run for every value of `my_variable`. In this case we are just printing it's value.


 > <pre>
 > for my_variable in my_iterable:
 >     <b>print("My variable now equals", my_variable)  ← body of the for loop</b>
 > </pre>

Let's see some examples.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Example 1: Mixed list, printing each element
for element in [1,3.5,-10,"hello"]:
    
    print("Τhe element is", element)
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Example 2: Integer list, printing the square of each number
numbers = [1,4,5, 9, 10]

# Loop through each number printing the square of them
for x in numbers:

    # Square x
    x_squared = x**2

    # Print the result
    print(x_squared)
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Example 3: List of words
my_string = "This is a sentence"

# Use split to seperate the sentence into words (see notebook 1: beginner)
my_words = my_string.split()

# Loop through the words, printing each
for word in my_words:

    # Print the current word
    print("The current word is:", word)

    # Tell us if the letter 'a' is in the word
    print("Is the letter 'a' in this word?", 'a' in word)

    # Print some -'s to make the output a bit easier to read
    print('----------------------')
    
```

 > **Test your understanding:** Make sure you understand this last example. How would you modify it to print the length of each word in the sentence? *Hint: You might need the `len()` function from the week 1 beginner notebook.*

**Warning:** Just like with an `if` statement, the body of a `for` loop must be indented. If you forget to indent, or if the indentation is inconsistent, Python will raise an error.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Example list
my_list = [1,2,3]

for number in my_list:
print(number) # <----- incorrect indentation will raise an error
```

## `while` loops

A `for` loop is useful when we want to repeat a computation once for every element in an iterable. But sometimes, instead of looping over a collection, we want to keep running a computation until a certain condition is met.

For example, we might want to:

 - keep rolling a die (generating random integers between $1$ and $6$) until we get a six, or
 - keep doubling a value until it becomes larger than 100.

To handle situations like these, Python provides the `while` loop.

A while loop repeatedly runs a block of code so long as a given Boolean statement is `True`. For example, in the below, the block of code is run while the statement `n < 10` is `True`.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Set n = 0
n = 0

# Run this code while n is less than 100
while n < 10:
    
    print(n)
    n = n + 1 # Replace the value of n with n + 1 
```

The syntax for a `while` loop looks very similar to an `if` statement. A while loop is introduced using the keyword `while` and a colon `:`:

 > <pre>
 > <b>while keyword</b>  <b>colon</b>
 >   ↓             ↓
 > <b>while</b> my_boolean<b>:</b>
 >     # Run some code
 > </pre>

In-between these, we must include a booean statement, e.g. `my_boolean`.

 > <pre>
 > <b>Boolean statement</b>
 >           ↓
 > while<b> my_boolean</b>:
 >     # Run some code
 > </pre>

Finally, the indented lines underneath form the body of the loop. This is the part that runs repeatedly:

 > <pre>
 > while my_boolean:
 >     <b># Run some code  ← body of the while loop</b>
 > </pre>

The body will keep running *again and again* as long as the boolean expression evaluates to `True`. It is worth making the comparison between `if` statements and `while` loops explicit:

 - An `if` statement checks its condition once and runs the body a single time (if `True`).
 - A `while` loop keeps checking the condition and repeats the body until the condition becomes `False`.

Let's look at a small worked example to make the while loop syntax clearer.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
i = 0
while i < 3:
    print(i)
    i = i + 1
```

In this example, we can imagine the `while` loop as if Python were repeating the indented code over and over:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
i = 0

# First time through (i = 0, condition True)
print(i)      # 0
i = i + 1     # i becomes 1

# Second time through (i = 1, condition True)
print(i)      # 1
i = i + 1     # i becomes 2

# Third time through (i = 2, condition True)
print(i)      # 2
i = i + 1     # i becomes 3

# Fourth check (i = 3, condition False) -> loop stops here
```

After every repetition, the loop is checking whether the boolean `i < 3` is `True`. Since, on the last repetition `i` is now equal to `3`, the condition is `False`, so the loop does not run another time. That is, the `while` loop ends there.

 > **Warning:** A `while` loop will keep running as long as its boolean condition is `True`. If the condition never becomes `False`, the loop will never end. This is called an infinite loop.
>
> For example, the following code never terminates because `i` is never updated (run this at your peril!):

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
i = 0
while i < 3:
    print(i)   # i is always 0 here!
```

 > To avoid infinite loops, you must ensure that the boolean eventaully becomes `False`.
>
> Of course, mistakes are inevitable. In a Jupyter notebook, an infinite loop can freeze the cell. If this happens, do one of the following:
> 
>  - Click the `"stop"` button (■) in the toolbar, or
>  - Use the menu: `Kernel -> Interrupt`.
>  - Use the menu: `Kernel -> Restart`.
>   
> The last option completely restarts the Python notebook and clears everything from memory, so use it only as a last resort.

## Nested Loops

One of the most useful features of loops is that you can *nest them inside one another*.

That means you can put a `for` loop inside a `while` loop, a `while` loop inside a `for` loop, or even nest loops of the same kind. This is powerful as it lets us perform tasks that require multiple layers of repetition. Here are some examples:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Example 1: A while loop inside a for loop
for i in range(3):
    count = 0
    while count < 2:
        print(f"Outer loop i={i}, inner loop count={count}")
        count += 1
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Example 2: A for loop inside a while loop
for i in range(3):
    for j in range(3):
        print(f"i={i}, j={j}")
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Example 3: A for loop inside a for loop
for i in range(3):
    for j in range(3):
        print(f"i={i}, j={j}")
```

 > **Test your understanding:** If you have already run the three code boxes above, clear the output from each. On paper, use your understanding of loops to predict exactly what each example will `print`. Rerun the code to check your answers.

To see why nested loops are useful, let's work through an example.

Suppose we want to list all [prime numbers](https://en.wikipedia.org/wiki/Prime_number) up to a given number `n`.

Intuitively we need to check whether each number between $1$ and $n$ is prime. We can visualise this like so:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Value of n
n = 10

# loop through 1,..., n
for i in range(1,n+1):

    # Check if i+1 (remember Python starts counting at zero!) is prime
    print("We need to check if", i , "is a prime number")
```

But how do we do the check inside the loop? Well, let's take an example value of `i`, say `i = 7`. If we were doing this task by hand, we'd check if `7` is divisible by `2`, then by `3`, then by `4`, and so on until we reach `7`. This can be done with a loop too:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Consider a single value of i
i = 7

# Boolean asking "Have we found a factor of i?" 
# So far, we haven't checked if i is divisible by anything
# so it's False
found_factor = False

# Loop through values less than i
for j in range(2, i):

      # Check if i is divisible by j
      if i % j == 0:

            # Then we have found a factor of i
            found_factor = True

# After we have looped through all possible j,
# let's check if we ever found a factor
if found_factor:

     # If i had a factor it can't be a prime number
     print(i, "is not a prime number")

else:

     # If we didn't then i must be prime!
     print(i, "is a prime number!")
```

 > **Test your understanding:** Why does the above code work? If you are unsure, ask one of the demonstrators for help!

This code tells us if one value (here `i=7`) is prime. But, how can we relate this to our original problem, checking if all values between `1` and `n` are prime? The answer is simply that we can place this code inside our larger loop from earlier:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Value of n
n = 10

# loop through 1,..., n
for i in range(1,n+1):

    # Boolean asking "Have we found a factor of i?" 
    # So far, we haven't checked if i is divisible by anything
    # so it's False
    found_factor = False

    # Loop through values less than i
    for j in range(2, i):
    
          # Check if i is divisible by j
          if i % j == 0:
    
                # Then we have found a factor of i
                found_factor = True
    
    # After we have looped through all possible j,
    # let's check if we ever found a factor
    if found_factor:
    
         # If i had a factor it can't be a prime number
         print(i, "is not a prime number")
    
    else:
    
         # If we didn't then i must be prime!
         print(i, "is a prime number!")
```

## Exercises

**Question 1:** Given the two strings in the code block below, use a `while` loop and the `split` function to make a new string which contains:
 - the 1st word from the 1st string
 - the 1st word from the 2nd string
 - the 2nd word from the 1st string
 - the 2nd word from the 2nd string
 - the 3rd word from the 1st string
 - ... and so on
 
Each word must be seperated from the last with a space.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
first_string = 'This seems have broken two strings. thats'
second_string = 'sentence to been into seperate Well, annoying.'

# Write your code here...
```

*Hint: You may wish to look up the `split` function in the Week 1 beginner notebook.*

**Question 2:** By looking up the documentation for the [`range` function](https://www.w3schools.com/python/ref_func_range.asp). Write some code which prints the numbers `1` to `100` in reverse order. That is, `100` should be printed first, then `99` and so on...

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Write your code here...
```

**Question 3:** Below is an integer `n`. Using a `while` loop, compute the factorial of $n$ given by $n!=n\times (n-1)\times... \times 2 \times 1$.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Integer n
n = 6

# Write your code here...
```

**Question 4:** Using a `for` loop, print the square of all of the elements in the list below which are greater than $2$ or less than $-2.5$.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
example_list = [1,-2.8,-2.1,-0.03,0.04,-1.9,1.0,20.8,1, -3,3.2]

# Write your code here...
```

Now do the same, but saving the elements in a new list named `output_list`.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Write your code here...
```

*Hint: You can add a new element to a list by using the `append` method. An example of this is given in the below code block.*

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# An empty list (a list with nothing in it)
my_list = []
print(my_list)

# Append an element
my_list.append(1)
print(my_list)

# Append another element
my_list.append(4)
print(my_list)
```

**Question 5:** Without running the below code, predict how many times the word `"Python"` will be printed. Explain your answer, and then verify it by running the below code.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
n = 16
while n > 1:
    print("Python")
    n = n // 2
```

**Question 6:** The below code uses a `while` loop to count the number of vowels in the word `word`. However, something has gone wrong! The below code will never terminate when run. Explain why this has happened and implement a fix.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Word to count vowels in
word = "education"

# String of vowels
vowels = "aeiou"

# Variable to count the number of vowels we've seen so far
vowel_count = 0

# Variable to keep track of where we are looking in the code.
position = 0

# While the position is still within the word
while position < len(word):
    
    # Get the letter at the position
    letter = word[position]
    
    # Check if letter is a vowel
    if letter.lower() in vowels:
        vowel_count = vowel_count + 1

        # Move the position one along
        position = position + 1

# print result
print("Vowel count:", vowel_count)
```

 > **Note:** Be careful running this code! As mentioned above, in it's current form, the code will never terminate.

**Question 7:** Using a loop, work through the dictionary of exam results below to find the difference between the highest and lowest scores. Print the names of the students who achieved those scores. *You may assume that all scores like between $0$ and $100$.*

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Dictionary of exam scores
exam_results = {
    'Liam Turner': 54,
    'Sophie Grant': 91,
    'Ethan Walsh': 62,
    'Isabella Patel': 77,
    'Noah Murphy': 38,
    'Mia Douglas': 85,
    'Lucas Reed': 43,
    'Ava Brooks': 99,
    'Mason Clarke': 71,
    'Olivia Hayes': 58
}

# Write your code here...
```

 > **Note:** In this question, we are using the dictionary datatype. Dictionaries in Python allow us to store data as key-value pairs. In this case, the key is a student's name, and the value is their exam score. For this question, you need to know that you can access individual items like `print(exam_results['Liam Turner'])` and you can obtain a list of all the keys (student names) using `names_in_dict = exam_results.keys()`. If you would like to learn more about the dictionary datatype, please have a look at the [week 1 intermediate notebook](../01/week_01_intro_to_data_types_intermediate.qmd).

**Question 8:** Use two nested `for` loops to print the first `n` lines of [Pascal's Triangle](https://en.wikipedia.org/wiki/Binomial_theorem). For instance, if $n=5$ your code should print:

```
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1 5 10 10 5 1 
```

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Set the value of n
n = 5
```

**Question 9:** A [palendromic number](https://en.wikipedia.org/wiki/Palindromic_number) is an integer that reads the same when its digits are reversed.

For example:

 - $124$ is not palindromic, because reversing the digits gives $421\neq 124$.
 - $121$ is palindromic, because reversing the digits gives $121=121$.

Using the `range` function together with a `for` loop, compute all palindromic numbers between $0$ and $1000$.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Write your code here...
```

*Hint: You can reverse a string using `[::-1]` as shown below:*

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Here's a string
x = "string"

# This will reverse the string
x_reversed = x[::-1]

# Print the result
print(x_reversed)
```

*This is an example of slicing. If you would like to learn more about slicing lists see the [Week 1 (Intermediate) notebook](../01/week_01_intro_to_data_types_intermediate.qmd).*

**Question 10:** Using a `while` loop and a `for` loop, compute the smallest positive number that is evenly divisible by all of the numbers from $1$ to $8$.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Write your answer here...
```

*Hint: These loops may need to be nested inside one another!*

