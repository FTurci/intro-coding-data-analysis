---
title: Loops - Solutions
jupyter: python3
---



This notebook contains the solutions to the week 3 `Beginner`, `Intermediate` and `Advanced` exercises.

### Table of Contents

 - [Welcome Page](./week_03_home.qmd)

 - [Beginner: For and While Loops](./week_03_loops_beginner.qmd)
 - [Intermediate: Advanced Iteration](./week_03_loops_intermediate.qmd)
 - [Advanced: Comprehensions](./week_03_loops_advanced.qmd)

 - [**Solutions**](./week_03_solutions_demonstrator_version.qmd)
     - [Beginner: For and While Loops](#Beginner:-For-and-While-Loops)
     - [Intermediate: Advanced Iteration](#Intermediate:-Advanced-Iteration)
     - [Advanced: Comprehensions](#Advanced:-Comprehensions)
 - [Slides](./week_03_slides.qmd) ([Powerpoint](./Lecture3_Loops.pptx))

## Beginner: For and While Loops

**Question 1:** The below code box contains an answer to this question.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
first_string = 'This seems have broken two strings. thats'
second_string = 'sentence to been into seperate Well, annoying.'

words_first_string = first_string.split()
words_second_string = second_string.split()
new_string = ''

i = 0
while i < len(words_first_string):
    
    new_string = new_string + words_first_string[i] + ' ' + words_second_string[i] + ' '
    i = i + 1
    
print(new_string)
```

 > **Demonstrator Notes:** The aim of this question is to give students some practice thinking about `while` loops, and in particular, when they should terminate. If students are struggling, emphasize the fact that, if we were doing this task by hand, we would look at the words one by one, and that we only stop writing when there are no more words left. Try to get the students to translate this natural language into code.

**Question 2:** A solution is given below.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
for i in range(100, 0, -1):
    print(i)
```

 > **Demonstrator Notes:** The aim of this question is to encourage students to form a habit of looking up documentation for themselves. Please do not give them the answer straight away, but instead encourage them to look up online resources.

**Question 3:** The below code computes the factorial with a `while` loop.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
n = 6

factorial = 1
i = n

while i > 0:
    factorial = factorial * i
    i = i - 1

print(factorial)
```

 > **Demonstrator Notes:** Like Question 1, this question aims to get students thinking about `while` loops and when they should terminate. If the students are struggling, have them perform the computation by hand on paper. They will likely compute $6 \times 5$ first, then multiply that by $4$ and so on, stopping only when they hit $1$. Try to relate the steps they perform to the process of coding the `while` loop.

**Question 4:** An answer to this question is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
example_list = [1,-2.8,-2.1,-0.03,0.04,-1.9,1.0,20.8,1, -3,3.2]

# First part
output_list = []
for i in example_list:
    if i>2 or i <-2.5:
        print(i**2)
        
# Second part
output_list = []
for i in example_list:
    if i>2 or i <-2.5:
        output_list.append(i**2)
```

 > **Demonstrator Notes:** This question aims to give students practice combining conditional logic with loops. For many students, this may also be the first time they are encountering the idea of appending value to a list inside each iteration of a `for` loop. A common error in this question is `AttributeError: 'NoneType' object has no attribute 'append'`. If you see this error, the chances are the student has written `output_list = output_list.append(i**2)` when they should just have `output_list.append(i**2)`. The `append` function does not return anything, it just adds the element to the list, so writing `output_list = ...` just sets `output_list` to `None`.

**Question 5:** The code will print `"Python"` four times, one for each power of two.

 > **Demonstrator Notes:** Encourage students to write this one out on paper if they are stuck. Again, this question is mainly for practice so try to avoid giving them the answer directly where possible.

**Question 6:** The problem here is that the `position = position + 1` is incorrectly indented and thus the `position` only changes when we encounter vowels. Once we encounter a consonant, we get stuck at that position indefinitely, never updating. The solution is as follows:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Word to count vowels in
word = "education"

# String of vowels
vowels = "aeiou"

# Variable to count the number of vowels we've seen so far
vowel_count = 0

# Variable to keep track of where we are looking in the code.
position = 0

# While the position is still within the word
while position < len(word):
    
    # Get the letter at the position
    letter = word[position]
    
    # Check if letter is a vowel
    if letter.lower() in vowels:
        vowel_count = vowel_count + 1

    # Move the position one along                   #  <--------------------------- Unindented lines
    position = position + 1                         #  <--------------------------- Unindented lines

# print result
print("Vowel count:", vowel_count)
```

 > **Demonstrator Notes:** The aim of this question is to give students practice debugging code. Encourage them to use the `print` function to help them understand what is happening on each iteration of the `while` loop.

**Question 7:** An example answer is given below.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Dictionary of exam scores
exam_results = {
    'Liam Turner': 54,
    'Sophie Grant': 91,
    'Ethan Walsh': 62,
    'Isabella Patel': 77,
    'Noah Murphy': 38,
    'Mia Douglas': 85,
    'Lucas Reed': 43,
    'Ava Brooks': 99,
    'Mason Clarke': 71,
    'Olivia Hayes': 58
}

# Initialize variables to track highest and lowest scores
highest_score = -1  # Start with a very low value
lowest_score = 101  # Start with a value higher than any possible score

# Loop through the dictionary
for student in exam_results.keys():
    score = exam_results[student]
    
    # Check if this is the highest score so far
    if score > highest_score:
        highest_score = score
        highest_student = student
    
    # Check if this is the lowest score so far
    if score < lowest_score:
        lowest_score = score
        lowest_student = student

# Calculate and print the difference
difference = highest_score - lowest_score
print("Difference between highest and lowest scores: " + str(difference))
print("Highest score: " + str(highest_student) + " with " + str(highest_score))
print("Lowest score: " + str(lowest_student) + " with " + str(lowest_score))
```

 > **Demonstrator Notes:** The correct output for this question is:
 >  ```
 > Difference between highest and lowest scores: 61
 > Highest score: Ava Brooks with 99
 > Lowest score: Noah Murphy with 38
 >  ```
 > This is the first time students have been asked to compute a maximum/minimum using loops. If students are struggling with this, simplify the problem and ask them to work out only the maximum of a single `list` using a `for` loop, working through the solution with them on paper first if you need to.

**Question 8:** A solution to this question is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Set the value of n
n = 5

# Loop through each row (from 0 to n)
for row in range(n + 1):
    
    # First number in the row is always 1
    value = 1       
    
    # Start with an empty string for this row
    line = ""       

    # Loop through each entry in the row
    for col in range(row + 1):
        
        if col != row:
            # Add the current number directly (no spaces this time)
            line = line + str(value) + " "
        else:
            line = line + str(value) + " "

        # Update 'value' for the next column using binomial relation
        value = value * (row - col) // (col + 1)

    # Print the row
    print(line)
```

 > **Demonstrator Notes:** This question is tough, so reassure students if they are struggling with it. Also, be aware that many students may not have studied Pascal's triangl and be unaware of it's construction. Make sure the student understands the context of the question (i.e. what Pascal's triangle actually is), before offering to help them solve it.

**Question 9:** One possible solution is provided below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Compute all palindromic numbers between 0 and 1000 
palindromes = []
for n in range(1001):
    string_n = str(n)
    if string_n == string_n[::-1]:
        palindromes.append(n)

# Output the list
print(palindromes)
```

 > **Demonstrator Notes:** A common stumbling point is that students don't realize they must convert the integer to a string to reverse its digits. To help them see this, suggest working through a simple example like `n=102` (ignoring the loop for now): guide them step-by-step on converting to a string, reversing it, and checking if it's a palindrome.

**Question 10:** Here is an example solution.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Initialize the candidate number to start checking from 1
candidate = 1

# Initialize a flag to track if we've found the number (start as False)
found = False

# Continue looping while we haven't found the number yet
while not found:
    
    # Assume it is divisible until proven otherwise
    is_divisible = True
    
    # Check divisibility by each number from 1 to 8
    for i in range(1, 9):
        # If not divisible by i, mark as not divisible
        if candidate % i != 0:
            is_divisible = False
    
    # If it is divisible by all, we've found it
    if is_divisible:
        
        # Set the flag to stop the loop
        found = True
        
        # Output the result
        print(candidate)
        
    else:
        # Otherwise, try the next candidate
        candidate += 1
```

 > **Demonstrator Notes:** The expected solution is $840$. If a student is struggling, provide them with a candidate number (e.g. `candidate=480`) and have them write some code to check whether this `candidate` is divisibly by $1,...,8$. Then ask them how they might expand on this code by looping over all possible candidates.

## Intermediate: Advanced Iteration

**Question 1:** Here is the solution:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
names = ["Alice", "Bob", "Charlie"]
scores = [85, 92, 78]

for name, score in zip(names, scores):
    print(name + " scored " + str(score))
```

 > **Demonstrator Notes:** This question is fairly straightforward and just involves using the `zip` function. If students need help on this question, advise them to read over the section on `enumerate` and `zip`. If they are still struggling, advise them to drop a level and attempt the beginner notebook.

**Question 2:** Below is a solution for this question.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
my_list = ["tent", "moon", "star", "guitar", "lamp", "tree", "ocean", "kite", "hat", 
           "rain", "butter", "frog", "nest", "tiger", "apple", "water", "sun", "toast", 
           "cloud", "ant"]

indices = []
for i, word in enumerate(my_list):
    if "t" in word:
        indices.append(i)

print(indices)  
```

 > **Demonstrator Notes:** Many students may still be fairly new to the idea of an `index`, so it is worth checking they understand the question correctly before helping with the code on this question. It is also expected that many will forget that Python is zero-indexed, but will not voice their confusion. Make sure they understand which index corresponds to which element in the list. The expected output for this question is:
 >
 > `[0, 2, 3, 5, 7, 8, 10, 12, 13, 15, 17, 19]`

**Question 3:** The answer to this question is to change the `break` to a `continue`. This is as the `break` ends the loop prematurely, whilst `continue` just skips to the next iteration. The current code gets to `num=1` and then executes the `break` statement, thus terminating the loop early.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
numbers = [1, 2, 3, 4, 5, 6]

for num in numbers:
    if num % 2 == 0:
        continue # <----- Fix implemented here.
    print(num)
```

 > **Demonstrator Notes:** Encourage students who are struggling to consider what the `break` statement is doing in this code. If necessary, advise them to revisit the `break`, `continue` and `pass` section. The hope is that this will prompt them to consider the differences between these keywords.

**Question 4:** Solution code is provided below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
original_dict = {
    'a': 1,
    'b': 2,
    'c': 1,
    'd': 3,
    'e': 2
}

inverted_dict = {}

# Loop through the original dictionary
for key, value in original_dict.items():   # sequence unpacking here
    
    # Check if we've seen this value before
    if value not in inverted_dict:
        
        # If we haven't add it as a new key
        inverted_dict[value] = []
        
    # Save the old key under value
    inverted_dict[value].append(key)

# Print result
print(inverted_dict)
```

 > **Demonstrator Notes:** This question is drawing on several concepts and is technically challenging. It is expected that some students will have forgotten how to `append` to a list. If a student is struggling with this, prompt them to attempt question 4 from the beginner notebook as a warmup for this question. This should hopefully encourage them to think about building collections one item at a time using `append`.

**Question 5:** The error in this code is the indentation of the `else` block. Here `else` should be at the same level as the `if` to make an `if... else`. However, it is at the level of the `for` creating a `for...else`. This means that it will always be executed for the last `day` so long as a `break` is not encountered in the loop. To rectify this, we just indent like so:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
days = ["Monday", "Saturday", "Tuesday"]

for day in days:
    if day in ["Saturday", "Sunday"]:
        print(day, "is at the weekend")
    else:                                            # <----- Line has been indented
        print(day, "is a weekday")                   # <----- Line has been indented
```

 > **Demonstrator Notes:** Encourage students who are struggling with this to revisit the `for` and `else` section.

## Advanced: Comprehensions

**Question 1:** The solution is below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
my_comprehension = [x**2 for x in range(1, 21) if x % 2 ==0]
print(my_comprehension)
```

 > **Demonstrator Notes:** This question is reasonably straightforward and designed to give students practice with the syntax of comprehensions. If, even with help, a student is really struggling with this, suggest that they drop a difficulty level and look at the intermediate material.

**Question 2:** The answer to this question is as follows:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
my_integer = 347892472349234

# List comprehension for digit sum
sum_of_digits = sum([int(digit) for digit in str(my_integer)])
print(sum_of_digits)
```

 > **Demonstrator Notes:** The "trick" to this question is to convert the integer to a string and loop over the characters of the string. A student who doesn't spot this immediately is unlikely to realise this is how to solve the problem later. So, for this question, it is fine to give them a guided solution rather than trying to give prompts.

**Question 3:** Below is list comprehension for this question.

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
# Compute all "pluriperfect" numbers between 0 and 999 using a list comprehension.

pluriperfect_numbers = [
    n
    for n in range(0, 1000)  # Iterate through all 3-digit numbers
    # Check if the number equals the sum of the cubes of its digits
    if n == sum([int(str(n)[k])**3 for k in range(len(str(n)))])
]

print(pluriperfect_numbers)  
```

> **Demonstrator Notes:** This question is challenging and it is expected that many students will struggle with the inner list comprehension. If a student is struggling, focus on a single value of `n` and talk them through how you might check that `n` is pluriperfect.

**Question 4:** The solution is given below:

```{pyodide}
#| caption: "▶ Ctrl/Cmd+Enter | ⇥ Ctrl/Cmd+] | ⇤ Ctrl/Cmd+["
my_string = "This is a lengthy string. It has many sentences. " + \
            "MaNY LetteRs aRe UpPer caSe. It might " + \
            "have these characters as well ?!,:-'... and numbers like " + \
            "123456789"

# Compute unique vowels using a set comprehension
unique_vowels = {char for char in my_string.lower() if char in "aeiou"}
print(unique_vowels)
```

 > **Demonstrator Notes:** The main objective of this question is for students to recognise that the set comprehension is the most appropriate choice when you need to list *unique* values. If they are using some other form of comprehension, please prompt them to reconsider this decision.

**Question 5:** The correct answer to this question is to use a generator comprehension, so that the values inside the comprehension are computed lazily (only when needed). If we use a list comprehension for this task, we will end up trying to compute `10000000000` values instantly and crash the memory.

 > **Demonstrator Notes:** The actual code for this answer would be very slow, as it is performing a very large computation. This is why the students have been told not to implement any code. However, the equivalent computation, when performed with a list comprehension, would consume too much memory and could crash the notebook entirely, so the generator comprehension is still preferable. If the students ask, tell them that we will cover more efficient tools for this task later in the course when we look at `numpy`.

